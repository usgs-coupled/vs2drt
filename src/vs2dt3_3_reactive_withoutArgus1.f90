      Program Main
      USE vs2dt_rm
      USE PhreeqcRM
      Integer JSTOP
      character*80 filen
      integer :: clock0, clock1, clockmax, clockrate, ticks
      real    :: secs
      integer :: i, count_args
      character(len=32) :: arg
      
!     Argument is number of threads for OpenMP
      nthreads = 1
#ifdef USE_OPENMP      
      count_args = command_argument_count()  
      if (count_args .ge. 1) then
          call get_command_argument(1, arg)
          if (len_trim(arg) > 0) then
              READ(arg,"(I5)") i
              if (i > 1) then
                  nthreads = i
              endif
          endif
      endif
#endif  
#ifdef USE_MPI
  ! MPI
      call MPI_INIT(status)
      if (status .ne. MPI_SUCCESS) then
          stop "Failed to get mpi_myself"
      endif
      call MPI_Comm_rank(MPI_COMM_WORLD, mpi_myself, status)
      call MPI_Comm_size(MPI_COMM_WORLD, mpi_tasks, status)
      if (mpi_myself > 0) then
          rm_id = RM_Create(nxyz, MPI_COMM_WORLD)
          status = RM_MpiWorker(rm_id)
          status = RM_Destroy(rm_id)
          call MPI_FINALIZE(status)
          stop
      endif
#endif
      
      filen = 'vs2drt.fil'
      JSTOP = 0
!     SET UP TO READ FROM DATA FILE GENERATED BY VS2DTI
      call system_clock(count_max=clockmax, count_rate=clockrate)
      call system_clock(clock0)
      call SETUP(filen)
 10   CALL STEP(JSTOP)
      IF (JSTOP.EQ.0) GOTO 10  
      ! call system_clock(clock1)

      !ticks = clock1-clock0
      !ticks = mod(ticks+clockmax, clockmax)   ! reset negative numbers
      !secs = float(ticks)/float(clockrate)
#ifdef USE_MPI
      status = RM_MpiWorkerBreak(rm_id)
#endif
      status = RM_Destroy(rm_id)
#ifdef USE_MPI
      call MPI_FINALIZE(status)
#endif
      call system_clock(clock1, clockrate, clockmax)
      secs = real( clock1 - clock0) / real(clockrate)
      print*,'JSTOP = ',JSTOP
      print*,'Code took ', secs, ' seconds' 
      stop
      end
      !include 'd_modules.inc'
      SUBROUTINE SETUP( filen)
! *** THIS SUBROUTINE IS THE FIRST HALF OF THE ORIGINAL MAIN CODE
! *** THAT READS THE SIMULATION DATA
!***    12/1/98
!
!
!******
!VSEXEC
!******
!-----------------------------------------------------------------
!         ************ PROGRAM VS2DRT *********************
!
!   PROGRAM TO SOLVE FOR:
!      TWO DIMENSIONAL VERTICAL SECTION OR CYLINDRICAL THREE
!          DIMENSIONAL FLUID FLOW AND REACTIVE TRANSPORT UNDER
!         VARIABLY SATURATED CONDITIONS
!
!       FLUID FLOW IS SOLVED FOR BY AN IMPLICIT FINITE DIFFERENCE
!          FORMULATION OF THE COMBINED RICHARDS AND COOPER-JACOB
!          EQUATIONS FOR FLUID CONTINUITY.
!
!.................................................................
!
!      SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use BF
      use COORDIN
      use DISCH
      use DUMM
      use DUMM1
      use DUMM2
      use DUMM3
      use EQUAT
      use EQUATS
      use HCON
      use IDUMM
      use IHDUMM
      use ISDUMM
      use ITEMBLO
      use ITEMTXB
      use JTXX
      use KCON
      use MPROP
      use PHREECC
      use PIT
      use PLOTT
      use PRESS
      use PRICON
      use PTET
      use RPROPSH
      use RSPAC
      use SCON
      use SIP
      use SOLINDEX
      use SOLMASS
      use SPFC
      use TEMP
      use TEMPCC
      use TRXV
      use TRXX
      use TRXXH
      use TRXY1
      use TRXY2

      use rspac
      use kcon
      use mprop
      use press
      use disch
      use hcon
      use equat
      use jtxx
      use dumm
      use ptet
      use trxx
      use trxy1
      use pit
      use sip
      use plott
      use spfc
      use rpropsh
      use scon
      use equats
      use trxy2
      use trxxh
      use trxv
      use temp
      use solmass
      use tempcc
      use compnam
      use pricon
      use coordin
      use solindex    
      use phreecc
      use react
      USE vs2dt_rm
      USE PhreeqcRM
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      COMMON/PND/POND
      COMMON/WGT/WUS,WDS
      COMMON/SCN1/TMPX,TMLT,DLTMX,DLTMIN,TRED
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      COMMON/JCON/JSTOP,JFLAG,jflag1
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p,F14P, &
      F15P,F16P,F17P,F18P,F19P
      LOGICAL THPT,SPNT,PPNT,HPNT,VPNT
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p,F14P, &
      F15P,F16P,F17P,F18P,F19P
      COMMON/LOG4/THPT,SPNT,PPNT,HPNT,VPNT
      CHARACTER*80 TITL,filen,f5,f6,f7,f8,f9,f10,f11,f12,f14, &
      f15,f16,f17,blank,f18,f19
      CHARACTER*6 ZUNIT,CUNX,HUNX
      CHARACTER*7 TUNIT
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX
      COMMON/MASSB/ BL(99),bcmft,bcmth,bl29I,bl29IT,bl29O,bl29OT,  &
      bl95I,bl95IT,bl95o,bl95OT
      integer hydraulicFunctionType,iuTemperature,iuHead,iuConcentration
      common/functiontype/ hydraulicFunctionType
!      COMMON/VERSION/VER2P5
!     LOGICAL VER2P5
      common/iuNumber/ iuHead, iuConcentration,iuTemperature
! *** NEXT STATEMENT CHANGED FROM SAVE TO COMMON
      COMMON/TTT/IFET,IFET1,NITT,NITT1,NITT2
      common/elimit/elimit1,elimit2
      real*8 ang
      integer NHTPROP,NSTPROP
      COMMON/TRANNSPROP/NHTPROP,NSTPROP
      LOGICAL HEAT,SOLUTE,FLOW
      COMMON/TRANSTYPE/HEAT,SOLUTE
      COMMON/TCON1/NIS,NIS1,NIS3
      COMMON/TTT1/NISS,NISS1,NISS2
      COMMON/FLO/FLOW
      COMMON/SCON1/ITESTS
      CHARACTER*80 CHEMFILE,DATABASEFILE,PREFIX
      COMMON/SOLCHAR/CHEMFILE,DATABASEFILE,PREFIX
      logical axes(2) 
      common/axis/axes
      common/conversion/CNVTM,CNVTMI     
      CHARACTER*10 SCOMPNAME(50)
      common/ITEMK/KNLY,KNXR,KNNODE
      !!@@include 'd_kdum.inc'
      integer, allocatable::KDUM(:,:)
      character*256 :: myline
      integer :: myerr
!     include 'c_kdum.inc'
! *** Set version, hydraulic function type, and sorption type
!--------------------------------------------------------------------------------------------
!

!   open files 
!
      iuHead = 5
      iuConcentration = 5
      GRAV = .FALSE.
      blank = ' '
      open(12,file='fort.12',FORM='UNFORMATTED',ACTION='WRITE',  &
      POSITION='REWIND')
      open(2,file=trim(filen))
      read(2,9090)f5
      read(2,9090)f6
      read(2,9090)f7
      read(2,9090)f8
      read(2,9090)f9
      read(2,9090)f11
!      read(2,9090)f14
!      read(2,9090)f15
!      read(2,9090)f16
!      read(2,9090)f17
!      read(2,9090)f18
!      read(2,9090)f19
      read(2,9090,end=9088)f10
      iInitial = index(f10,'#')
      if (iInitial.ne.0) go to 9088
      if(f5.ne.f10.and.f10.ne.blank) then
       open(13,file='fort.13',FORM='UNFORMATTED')
       open(10,file=f10)
!       iuHead = 10
      end if
      read(2,9090,end=9089)f12
 9089 continue     
 9088 open(5,file=f5)
      open(6,file=f6)
      open(7,file=f7)
      open(8,file=f8)
      open(9,file=f9)
      open(11,file=f11)
!      open(14,file=f14)
!      open(15,file=f15)
!      open(16,file=f16)
!      open(17,file=f17)
!      open(18,file=f18)
!      open(19,file=f19)
 9090 format(a80)
!
!-------------------------------------------------------------------
!
!  ---- READ AND WRITE PROBLEM TITLE AND SPACE AND TIME CONSTANTS
!
      JSTOP=0
      READ (5,'(A)') myline
      READ (myline,4000,IOSTAT=myerr) TITL
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  TITL'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  TITL'
      endif
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) TMAX,STIM,ANG
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  TMAX,STIM,ANG'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  TMAX,STIM,ANG'
      endif
      READ (5,'(A)') myline
      READ (myline,4010,IOSTAT=myerr) ZUNIT,TUNIT,CUNX,HUNX
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  ZUNIT,TUNIT,CUNX,HUNX'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  ZUNIT,TUNIT,CUNX,HUNX'
      endif
!      READ (05,4011) TUNIT
!      READ (05,4010) CUNX
!      READ (05,4010) HUNX
      CNVTM = 1.D0
      IF(TUNIT.EQ.'s'.or.TUNIT.EQ.'seconds')then
      CNVTM= 1.D0
      ELSE IF (TUNIT.EQ.'min'.or.TUNIT.EQ.'minutes')then
      CNVTM=60.D0
      ELSE IF (TUNIT.EQ.'h'.or.TUNIT.EQ.'hours')then
      CNVTM=3600.D0
      ELSE IF (TUNIT.EQ.'d'.or.TUNIT.EQ.'days')then
      CNVTM=864000.D0
      ELSE IF (TUNIT.EQ.'yr'.or.TUNIT.EQ.'years')then
      CNVTM=3.155815D7
      END IF
      CNVTMI= 1.D0/ CNVTM    
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) NXR,NLY
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  NXR,NLY'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  NXR,NLY'
      endif
      if(NXR .GT. 2) THEN 
      axes(1)= .true.
      ELSE IF (NXR .EQ. 2)then
      axes(1)= .false.
      END IF
      if(NLY .GT. 2) THEN 
      axes(2)= .true.
      ELSE IF (NLY.EQ. 2)then
      axes(2)= .false.
      END IF
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) NRECH,NUMT
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  NRECH,NUMT'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  NRECH,NUMT'
      endif
!
!  o13p triggers high precisions output
!  o12p triggers p,c unformatted output to file 12
!  o9p = t for MB output only at specified times
!  o11p = t for obsPoint output only at specified times
!
      if(NUMT.lt.0) then
       numt = -numt
       o13p = .TRUE.
      else
       o13p = .FALSE.
      end if
      if (nrech.lt.0) then
       nrech = -nrech
       o12p = .TRUE.
      else
       o12p = .FALSE.
      end if
      WRITE (06,4060)
      WRITE (06,4070) TITL,TMAX,TUNIT,STIM,NRECH,NUMT,NLY,NXR
      WRITE(06,4080) ANG
      IF(ANG.GT.90.0D0.OR.ANG.LT.-90.0D0)THEN
      WRITE(06,4090)
      jstop=2
      return
      END IF
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) RAD,ITSTOP,HEAT,SOLUTE
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  RAD,ITSTOP,HEAT,SOLUTE'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  RAD,ITSTOP,HEAT,SOLUTE'
      endif
      IF (SOLUTE) then
         READ (5,'(A)') myline
         READ (myline,4001,IOSTAT=myerr) CHEMFILE
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  CHEMFILE'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  CHEMFILE'
         endif
         READ (5,'(A)') myline
         READ (myline,4001,IOSTAT=myerr) DATABASEFILE
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  DATABASEFILE'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  DATABASEFILE'
         endif
         READ (5,'(A)') myline
         READ (myline,4001,IOSTAT=myerr) PREFIX
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  PREFIX'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  PREFIX'
         endif
      End if
      IF(HEAT.OR.SOLUTE) then 
        TRANS = .TRUE.
        FLOW = .FALSE.
        else
        TRANS = .FALSE.
        FLOW = .TRUE.
      END IF
      IF (TRANS) then
          READ (5,'(A)') myline
          read (myline,*,IOSTAT=myerr)CIS,CIT
          if (myerr .ne. 0) then
              write(6,'(A)') 'Error reading: CIS,CIT'
              write(6,'(A,A)') 'Last line: ', myline
              flush(6)
              stop 'Error reading: CIS,CIT'
          endif
      endif
      IF(SOLUTE)THEN
         READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr)IPRNTCHE,INPRXZ,IPOUT
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading: IPRNTCHE,INPRXZ,IPOUT'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading: IPRNTCHE,INPRXZ,IPOUT'
      endif
  !    DO 5 I=1,NNODES
  !    NPRCHEM(I)= IPRNTCHE
  !    NPRCHXZ(I)= INPRXZ
  !5   CONTINUE
      END IF     
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) F11P,F7P,F8P,F9P,F6P
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  F11P,F7P,F8P,F9P,F6P'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  F11P,F7P,F8P,F9P,F6P'
      endif
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) THPT,SPNT,PPNT,HPNT,VPNT
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  THPT,SPNT,PPNT,HPNT,VPNT'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  THPT,SPNT,PPNT,HPNT,VPNT'
      endif
      WRITE (06,4100) F8P,ITSTOP,F7P,F11P,F9P,F6P
      WRITE (06,4110) THPT,SPNT,PPNT,HPNT,VPNT   
      NLYY=NLY-1
      NXRR=NXR-1
      NNODES=NLY*NXR
      Nsol=0
      IF (SOLUTE)then
          CALL CreateRM(SOLUTE, NNODES,  PREFIX, DATABASEFILE, CHEMFILE, nSol)
          !#CALL PHREEQC_MAIN(SOLUTE,CHEMFILE,DATABASEFILE,PREFIX)
          !#SCOMPNAME= "          "
          !#CALL COUNT_ALL_COMPONENTS(Nsol, SCOMPNAME)
          do i = 1, nSol
              status = RM_GetComponent(rm_id, i, scompname(i))
          enddo
          Nodesol= NNODES*Nsol  
      END IF
      IF(PPNT.OR.HPNT)THEN
        F14P=.TRUE.
      ELSE
        F14P=.false.
      END IF    
      IF(SOLUTE)THEN
        F15P=.TRUE.
      ELSE
        F15P=.false.
      END IF
      IF(HEAT)THEN
        F16P=.TRUE.
      ELSE
        F16P=.false.
      END IF  
      IF(VPNT)THEN
        F17P=.TRUE.
      ELSE
        F17P=.false.
      END IF
      IF(THPT)THEN
        F18P=.TRUE.
      ELSE
        F18P=.false.
      END IF
      IF(SPNT)THEN
        F19P=.TRUE.
      ELSE
        F19P=.false.
      END IF
      KNLY=NlY-2
      KNXR=NXR-2
      KNNODE=KNLY*KNXR
      !!@@include 'd_arrays.inc' 
!     allocate arrays
      allocate(DELZ(NLY),DZZ(NLY),DXR(NXR),RX(NXR))
      allocate(HX(NNODES),NTYP(NNODES))
      allocate(THETA(NNODES),THLST(NNODES),SATUR(NNODES),POROSITY(NNODES))
      allocate(P(NNODES),PXXX(NNODES),THEAD(NNODES))
      allocate(Q(NNODES),QQ(NNODES))
      allocate(HCND(NNODES),HKLL(NNODES),HKTT(NNODES))
      allocate(A(NNODES),B(NNODES),C(NNODES),D(NNODES),E(NNODES),  &
         RHS(NNODES),XI(NNODES))
     allocate(AS(NNODES),BS(NNODES),CS(NNODES),DS(NNODES),ES(NNODES),  &
         RHSS(NNODES),XIS(NNODES))
      allocate(JTEX(NNODES))
      allocate(DUM(NNODES),PDUM(KNXR))
      allocate(DPTH(NNODES),RT(NNODES))
      allocate(DX1(NNODES),DX2(NNODES),DZ1(NNODES),DZ2(NNODES),  &
          TT(NNODES),TTOLD(NNODES),TS(NNODES),  &
         QT(NNODES),NHTYP(NNODES))
     allocate(VX(NNODES),VZ(NNODES))
     allocate(RHO(NNODES),RHOOLD(NNODES))
     allocate(DXS1(NNODES),DXS2(NNODES),DZS1(NNODES),DZS2(NNODES),  &
          CC(Nsol,NNODES),CCOLD(Nsol,NNODES),CSS(Nsol,NNODES),  &
          QS(NNODES),NCTYP(NNODES),CONC(Nsol))
      allocate(AO(NNODES),BO(NNODES),CO(NNODES),DO(NNODES),EO(NNODES))
      allocate(AOC(NNODES),BOC(NNODES),COC(NNODES),DOC(NNODES),EOC(NNODES))
      allocate(PITT(NNODES))
      allocate(DEL(NNODES),ETA(NNODES),V(NNODES))
      allocate(TempC(NNODES))
      allocate(XNODE(NNODES),ZNODE(NNODES))
      allocate(phreeC(Nodesol))
      allocate(CMIXFARC(7,NNODES),BCSOL(Nsol),INDSOL1(7,NNODES),INDSOL2(7,NNODES))
	  allocate(ic1_reordered(nnodes,7))
      allocate(NPRCHEM(NNODES),NPRCHXZ(NNODES))
      allocate(BLSOL(Nsol,36),bl62I(Nsol),bl62IT(Nsol),bl62O(Nsol),bl62OT(Nsol), &
             bcmtt(Nsol),bcmt(Nsol),bcmtr(Nsol),bltemp36(Nsol),bltemp39(Nsol), &
             bltemp42(Nsol),bltemp45(Nsol),bltemp60(Nsol))
      allocate(COMPNAME(Nsol))       
      allocate(CCBR(Nsol,NNODES),CCAR(Nsol,NNODES))      
      IF (SOLUTE) THEN  
      DO 7 I=1,Nsol 
      compname(I)  = scompname(I)
      WRITE(06,4012)compname(I)
   7  CONTINUE       
      END IF 
!      include 'c_arrays.inc'
! *** SET ALL ARRAYS TO ZERO
      DO 710 I=1, NLY
      DELZ(I) = 0.0D0
      DZZ(I) = 0.0D0
 710  CONTINUE
      DO 715 I=1, NXR
      DXR(I) = 0.0D0
      RX(I) = 0.0D0
 715  CONTINUE
      do 8 I=1, Nodesol
      phreeC(I)=0.d0
  8   continue
      DO 711 I=1, NNODES
      XNODE(I)= 0.0D0
      ZNODE(I)= 0.0D0  
      HX(I) = 0.0D0
      NTYP(I) = 0
      THETA(I) = 0.0D0
      THLST(I) = 0.0D0
      SATUR(I)=0.0D0
      P(I) = 0.0D0
      PXXX(I) = 0.0D0
      THEAD(I)=0.0D0
      Q(I) = 0.0D0
      QQ(I) = 0.0D0
      HCND(I) = 0.0D0
      HKLL(I) = 0.0D0
      HKTT(I) = 0.0D0
      A(I) = 0.0D0
      B(I) = 0.0D0
      C(I) = 0.0D0
      D(I) = 0.0D0
      E(I) = 0.0D0
      RHS(I) = 0.0D0
      XI(I) = 0.0D0
      AS(I) = 0.0D0
      BS(I) = 0.0D0
      CS(I) = 0.0D0
      DS(I) = 0.0D0
      ES(I) = 0.0D0
      RHSS(I) = 0.0D0
      JTEX(I) = 0
      DUM(I) = 0.0D0
      DPTH(I) = 0.0D0
      RT(I) = 0.0D0
      DX1(I) = 0.0D0
      DX2(I) = 0.0D0
      DZ1(I) = 0.0D0
      DZ2(I) = 0.0D0
      DXS1(I) = 0.0D0
      DXS2(I) = 0.0D0
      DZS1(I) = 0.0D0
      DZS2(I) = 0.0D0
      VX(I) = 0.0D0
      VZ(I) = 0.0D0
      TT(I) = 0.0D0
      TTOLD(I) = 0.0D0
      TS(I) = 0.0D0
      QT(I) = 0.0D0
      QS(I) = 0.0D0
      TempC(I)=0.0D0
      NHTYP(I) = 0
      NCTYP(I) = 0
      AO(I) = 0.0D0
      BO(I) = 0.0D0
      CO(I) = 0.0D0
      DO(I) = 0.0D0
      EO(I) = 0.0D0
      AOC(I) = 0.0D0
      BOC(I) = 0.0D0
      COC(I) = 0.0D0
      DOC(I) = 0.0D0
      EOC(I) = 0.0D0
      PITT(I) = 0.0D0
      XIS(I)=0.0D0
      RHO(I) = 0.0D0
      RHOOLD(I) = 0.0D0
      NPRCHEM(I) = 0
      NPRCHXZ(I) = 0 
 711  CONTINUE
      DO 714 I=1, NNODES
      DO 713 M=1, Nsol
      CC(M,I) = 0.0D0
      CCOLD(M,I) = 0.0D0
      CSS(M,I) = 0.0D0
      CCBR(M,I)= 0.0D0
      CCAR(M,I)= 0.0D0
 713  CONTINUE  
 714  CONTINUE
      DO 801 J=1, NNODES
      DO 800 I=1, 7
      INDSOL1(I,J)= -1
      INDSOL2(I,J)= -1
      CMIXFARC(I,J) = 0.0D0
 800  CONTINUE
 801  CONTINUE
      DO 712 I=1,99
      BL(I)=0.0D0
 712  CONTINUE
      bcmft = 0.0D0
      bcmht = 0.0D0
      bl29I = 0.0D0
      bl29IT = 0.0D0
      bl29O = 0.0D0
      bl29OT = 0.0D0
      bl95I = 0.0D0
      bl95IT = 0.0D0
      bl95O = 0.0D0
      bl95OT = 0.0D0
      DO 717 M=1,Nsol
      bl62I(M) = 0.0D0
      bl62IT(M) = 0.0D0
      bl62O(M)= 0.0D0
      bl62OT(M) = 0.0D0
      DO 716 J=1,36
      BLSOL(M,J)= 0.0D0
      bcmtt(M)=0.0D0
 716  CONTINUE
 717  CONTINUE
      
      DO 5 I=1,NNODES
      NPRCHEM(I)= IPRNTCHE
      NPRCHXZ(I)= INPRXZ
5     CONTINUE   
      
!
!   ESTABLISH HORIZONTAL OR RADIAL SPACING
!
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) IFAC,FACX
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  IFAC,FACX'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  IFAC,FACX'
      endif
      IF(IFAC.GT.0) GO TO 20
!
!   READ IN SPACING FOR EACH COLUMN
!
      READ (5,*,IOSTAT=myerr) (DXR(K),K=1,NXR)
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  (DXR(K),K=1,NXR,IOSTAT=myerr)'
         flush(6)
         stop 'Error reading:  (DXR(K),K=1,NXR,IOSTAT=myerr)'
      endif
      DO 10 K=1,NXR
   10 DXR(K)=DXR(K)*FACX
      GO TO 60
   20 IF(IFAC.EQ.2) GO TO 40
      DO 30 K=1,NXR
   30 DXR(K)=FACX
      GO TO 60
!
!  IF IFAC=2, HORIZONTAL NODE SPACING IS INCREMENTED BY A CONSTANT
!    MULTIPLIER UNTIL A USER-SPECIFIED MAXIMUM IS REACHED, WHERE-
!    UPON THE SPACING BECOMES CONSTANT
!
40    continue
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) XMULT,XMAX
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  XMULT,XMAX'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  XMULT,XMAX'
      endif
      DXR(1)=FACX
      DXR(2)=FACX
      DO 50 K=3,NXRR
      DXR(K)=DXR(K-1)*XMULT
      IF(DXR(K) .GT. XMAX)DXR(K)=XMAX
   50 CONTINUE
      DXR(NXR)=DXR(NXRR)
!
!   ESTABLISH VERTICAL SPACING
!
60    continue
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) JFAC,FACZ
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  JFAC,FACZ'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  JFAC,FACZ'
      endif
      IF(JFAC.GT.0) GO TO 80
!
!   READ IN VERTICAL SPACINGS INDIVIDUALLY
!
      READ (5,*,IOSTAT=myerr) (DELZ(K),K=1,NLY)
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  (DELZ(K),K=1,NLY)'
         flush(6)
         stop 'Error reading:  (DELZ(K),K=1,NLY)'
      endif
      DO 70 K=1,NLY
   70 DELZ(K)=DELZ(K)*FACZ
      GO TO 120
   80 IF(JFAC.EQ.2) GO TO 100
      DO 90 K=1,NLY
   90 DELZ(K)=FACZ
      GO TO 120
!
!   ESTABLISH VERTICAL SPACING BY PROGRESSION, AS ABOVE FOR HORIZ.
!
100   continue
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) ZMULT,ZMAX
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  ZMULT,ZMAX'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  ZMULT,ZMAX'
      endif
      DELZ(1)=FACZ
      DELZ(2)=FACZ
      DO 110 K=3,NLYY
      DELZ(K)=DELZ(K-1)*ZMULT
      IF(DELZ(K) .GT. ZMAX)DELZ(K)=ZMAX
  110 CONTINUE
      DELZ(NLY)=DELZ(NLYY)
  120 CONTINUE
!
!    DETERMINE HORIZONTAL AND VERTICAL COORDINATES
!
      RX(1)=-0.5D0 *DXR(1)
      DO 130 N=2,NXR
      RX(N)=RX(N-1)+0.5D0 *(DXR(N-1)+DXR(N))
  130 CONTINUE
      DZZ(1)=-0.5D0 *DELZ(1)
      DO 140 J=2,NLY
  140 DZZ(J)=DZZ(J-1)+0.5D0 *(DELZ(J-1)+DELZ(J))
      DO 11 I=1,NNODES
      IMOD=MOD(I,NLY)
      XNODE(I)= (I-IMOD)/NLY + MIN(1,IMOD)
      IF(IMOD .EQ.0) THEN
      ZNODE(I)=NLY
      ELSE
      ZNODE(I)= IMOD
      END IF      
  11  CONTINUE
!      DO 12 I=1,NNODES 
!      write(6,*)"XNODE(",I,")=", XNODE(I),"ZNODE(",I,")=", ZNODE(I)
!  12  CONTINUE
      WRITE (06,4120) ZUNIT,(DELZ(K),K=1,NLY)
      WRITE (06,4130) ZUNIT,(DXR(K),K=1,NXR)
      PI=3.141592654D0
      PI2=PI+PI
      ANG=ANG/360.0D0
      IF(ANG.EQ.0.0D0) THEN
      CS1=1.0D0
      CS2=0.0D0
      ELSE
      IF(ANG.EQ.0.25D0.OR.ANG.EQ.-0.25D0) THEN
      CS1=0.0D0
      ELSE
      CS1=DCOS(ANG*PI2)
      END IF
      CS2=-DSIN(ANG*PI2)
      END IF
!
!    READ DATA FOR MONITORING TIMES AND POINTS
!
      NPLT=0
      o9p = .false.
      o11p = o9p
      IF(F8P) THEN
         READ (5,'(A)') myline
         READ (myline,*,IOSTAT=myerr) NPLT
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  NPLT'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  NPLT'
         endif
      !!@@include 'd_obst.inc'
      allocate(PLTIM(NPLT+1))
!      include 'c_obst.inc'
      IF(NPLT.EQ.0)NPLT=1
      READ (5,*,IOSTAT=myerr) (PLTIM(K),K=1,NPLT)
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  (PLTIM(K),K=1,NPLT)'
         flush(6)
         stop 'Error reading:  (PLTIM(K),K=1,NPLT)'
      endif
      WRITE (06,4140) (PLTIM(K),K=1,NPLT)
      else
      !!@@include 'd_obst.inc'
      allocate(PLTIM(NPLT+1))      
      END IF
      IF(F11P) THEN
         READ (5,'(A)') myline
         READ (myline,*,IOSTAT=myerr) NOBS
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  NOBS'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  NOBS'
         endif
      if (nobs.lt.0) then
       nobs = -nobs
       o11p = .true.
      end if
      !!@@include 'd_obsp.inc'
      allocate(IJOBS(NOBS))
      if (allocated(KDUM)) deallocate(KDUM)
      allocate(KDUM(NOBS,2))      
      READ (5,*,IOSTAT=myerr) ((KDUM(K,J),J=1,2),K=1,NOBS)
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  ((KDUM(K,J),J=1,2),K=1,NOBS)'
         flush(6)
         stop 'Error reading:  ((KDUM(K,J),J=1,2),K=1,NOBS)'
      endif
      WRITE (06,4150) ((KDUM(K,J),J=1,2),K=1,NOBS)
!      include 'c_obsp.inc'
      DO 150 K=1,NOBS
      N=NLY*(KDUM(K,2)-1)+KDUM(K,1)
      IJOBS(K)=N
  150 continue
      END IF
      IF (F9P) THEN
         READ (5,'(A)') myline
         READ(myline,*,IOSTAT=myerr)NMB9
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading: NMB9'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading: NMB9'
         endif
      if (nmb9.lt.0) then
       nmb9 = -nmb9
       o9p = .true.
      end if
      if (nmb9.gt.99) nmb9 = 99
      READ(5,*,IOSTAT=myerr) (MB9(K),K=1,NMB9)
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  (MB9(K),K=1,NMB9)'
         flush(6)
         stop 'Error reading:  (MB9(K),K=1,NMB9)'
      endif
      WRITE(06,4160) (MB9(K),K=1,NMB9)
      END IF
      PLTIM(NPLT+1)=TMAX+TMAX
!      WRITE (14,4002) NLY,NXR 
!      WRITE (15,4002) NLY,NXR
!      WRITE (16,4002) NLY,NXR
!      WRITE (17,4002) NLY,NXR
!      WRITE (18,4002) NLY,NXR
!      WRITE (19,4002) NLY,NXR
      IF(RAD) THEN
      WRITE(06,4050)
      ELSE
      WRITE (06,4040)
      END IF
      IF(TRANS) THEN
      WRITE(06,4240)
      IF(CIS) THEN
      WRITE(6,4200)
      ELSE
      WRITE(6,4210)
      END IF
      IF(CIT) THEN
      WRITE(6,4220)
      ELSE
      WRITE(6,4230)
      END IF
      END IF
      IF(F11P) then
       if (o13p) then
        if(trans) then
          if(heat.AND.solute)then
            WRITE (11,4033) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT, &
            (COMPNAME(M),M=1,Nsol)
          else if(heat.AND.(.NOT.solute))then
            WRITE (11,4034) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT
          else  
          WRITE (11,4035) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT, &
          (COMPNAME(M),M=1,Nsol)
         end if 
        else
         WRITE (11,4031) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT
        end if
       else
        if(trans) then
         if(heat.AND.solute)then
            WRITE (11,4032) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT, &
            (COMPNAME(M),M=1,Nsol)
          else if(heat.AND.(.NOT.solute))then
            WRITE (11,4036) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT
          else  
          WRITE (11,4037) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT,  &
          (COMPNAME(M),M=1,Nsol)
         end if 
        else
         WRITE (11,4030) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT
        end if
       end if
      end if
!
!     INITIALIZE CONSTANTS
!
      ITEST=0
      ITESTS=0
      KTIM=0
      NITT=0
      NITT1=0
      NITT2=0
      NISS=0
      NISS1=0
      JFLAG=1
      KP=0
      JPLT=0
      WRITE (06,4170) 
!
!
!   READ AND WRITE INITIAL VALUES OF PRESSURE HEAD, TOTAL HEAD,
!    THETA, AND SATURATION
!-------------------------------------------------------------
!
      CALL VSREAD
      CALL VSSIP
      CALL VSSIPSOL
      IFET=0
      IFET2=0
      CALL VSOUTP
      !!@@include 'd_kdumDealloc.inc'
      if(allocated(kdum)) deallocate(kdum)
      RETURN
 4000 FORMAT(A80)
 4001 FORMAT(A15)
 4002 FORMAT(I5,I5)
 4010 FORMAT(4A4)
 4011 FORMAT(A7) 
 4012 FORMAT(A10)
 4020 FORMAT(5X,20(1H*),1X,31HDIMENSIONS TOO LARGE FOR ARRAYS,  &
      1X,20(1H*)/5X,6HNLY = ,I6,2X,6H,NXR = ,I6)
 4030 FORMAT(A80/21HMONITORING POINT FILE/2X,6HTIME,  ,A7,2X,  &
      5x,'NODE',3x,  &
       6H XR,  ,A6,3X,6H Z,    ,A6,3X,6H H,   ,A6,3X,6H  P,  ,A6,  &
      3X,6H THETA,5X,8H     SAT,5x,'      VX',5x,'      VZ' &
      5x,'      ET')
 4031 FORMAT(A80/21HMONITORING POINT FILE/7X,6HTIME,  ,A7,6X,  &
        'NODE',15x,  & 
       6H XR,  ,A6,10X,6H Z,    ,A6,10X,6H H,   ,A6,10X,6H  P,  ,A6,  &
      12X,6H THETA,12X,8H     SAT,12x,'      VX',12x,'      VZ',  &
      12x,'      ET')
 4032 FORMAT(A80/21HMONITORING POINT FILE/2X,6HTIME,  ,A7,2X,  &
      5x,'NODE',3x,  &
       6H XR,  ,A6,3X,6H Z,    ,A6,3X,6H H,   ,A6,3X,6H  P,  ,A6,  &
       3X,6H THETA,5X,8H     SAT,10x,'TEMP',5x,'      VX',5x,  &
      '      VZ', 5x,'      ET',50(1x,A10))
 4033 FORMAT(A80/21HMONITORING POINT FILE/7X,6HTIME,  ,A7,6X,  &
      'NODE',15x,  &
       6H XR,  ,A6,10X,6H Z,    ,A6,10X,6H H,   ,A6,10X,6H  P,  ,A6,  &
       12X,6H THETA,12X,8H     SAT,17x,'TEMP',12x,'      VX',12x,  &
       '      VZ',12x,'      ET',50(1x,A10))
 4034 FORMAT(A80/21HMONITORING POINT FILE/7X,6HTIME,  ,A7,6X,  &
      'NODE',15x,  &
       6H XR,  ,A6,10X,6H Z,    ,A6,10X,6H H,   ,A6,10X,6H  P,  ,A6,  &
       12X,6H THETA,12X,8H     SAT,17x,'TEMP',12x,'      VX',12x,  &
       '      VZ',12x,'      ET')   
 4035 FORMAT(A80/21HMONITORING POINT FILE/7X,6HTIME,  ,A7,6X,  &
      'NODE',15x,  &
       6H XR,  ,A6,10X,6H Z,    ,A6,10X,6H H,   ,A6,10X,6H  P,  ,A6,  &
       12X,6H THETA,12X,8H     SAT,17x,'      VX',12x,  &
       '      VZ',12x,'      ET',50(1x,A10))    
 4036 FORMAT(A80/21HMONITORING POINT FILE/2X,6HTIME,  ,A7,2X,  &
      5x,'NODE',3x,  &
       6H XR,  ,A6,3X,6H Z,    ,A6,3X,6H H,   ,A6,3X,6H  P,  ,A6,  &
       3X,6H THETA,5X,8H     SAT,10x,'TEMP',5x,'      VX',5x,  &
      '      VZ', 5x,'      ET') 
 4037 FORMAT(A80/21HMONITORING POINT FILE/2X,6HTIME,  ,A7,2X,  &
      5x,'NODE',3x,  &
       6H XR,  ,A6,3X,6H Z,    ,A6,3X,6H H,   ,A6,3X,6H  P,  ,A6,  &
       3X,6H THETA,5X,8H     SAT,10x,'      VX',5x,  &
      '      VZ', 5x,'      ET',50(1x,A10))                 
 4040 FORMAT(5X,32HCOORDINATE SYSTEM IS RECTANGULAR)
 4050 FORMAT(5X,27HCOORDINATE SYSTEM IS RADIAL)
 4060 FORMAT(35X,60('+')/35X,'+',26X,7H VS2DRT,25X,'+'/35X,  &
     '+',23x,' VERSION 1.1',23x,'+'/35x,  &
     '+',11X,'SIMULATION OF 2-DIMENSIONAL VARIABLY',11X,'+'/  &
     35X,'+',12X,'SATURATED REACTIVE TRANSPORT',18X,'+'  &
     /35X,'+',11X,'        THROUGH POROUS MEDIA.       ',11X,'+'  &
      /35X,60('+')//)
 4070 FORMAT(//,1X,100(1H*)/5X,A80/1X,100(1H*)//10X,  &
      24HSPACE AND TIME CONSTANTS/10X,23(1H-)/  &
      5X,26HMAXIMUM SIMULATION TIME = ,E14.6,1X,A4/  &
      5X,'STARTING TIME = ',F10.4,/  &
      5X,28HNUMBER OF RECHARGE PERIODS =,I10/ &
      4X,32H MAXIMUM NUMBER OF TIME STEPS = ,I10/  &
      5X,17HNUMBER OF ROWS = ,I6/5X,20HNUMBER OF COLUMNS = ,I6)
 4080 FORMAT(5X,'AXES TILTED BY ANGLE = ',F8.2)
 4090 FORMAT(1X,'ANGLE OF AXES TILTING MUST BE BETWEEN -90 AND 90 ',  &
      'DEGREES',/,1X,'SIMULATION TERMINATED')
 4100 FORMAT(10X,16HSOLUTION OPTIONS/10X,16(1H-)/ &
      5X,'WRITE ALL PRESSURE HEADS TO FILE 8',  &
      23H AT OBSERVATION TIMES? ,L1,/  &
      5X,'STOP SOLUTION IF MAXIMUM NO.',  &
      ' OF ITERATIONS EXCEEDED IN ANY TIME STEP? ',L1/5X,  &
      'WRITE BOUNDARY FLUXES TO FILE 7? ',  &
      L1/5X,'WRITE RESULTS AT SELECTED OBSERVATION POINTS TO ',  &
      'FILE 11? ', L1/,5X,'WRITE MASS BALANCE RATES TO FILE 9? ',L1/ &
      5X,'WRITE MASS BALANCE RATES TO FILE 6? ',L1)
 4110 FORMAT(1H ,4X,35HWRITE MOISTURE CONTENTS TO FILE 6? ,L1/ &
       5X,29HWRITE SATURATIONS TO FILE 6? ,L1/ &
       5X,32HWRITE PRESSURE HEADS TO FILE 6? ,L1/  &
       5X,29HWRITE TOTAL HEADS TO FILE 6? ,L1/  &
       5X,'WRITE VELOCITIES TO FILE 6? ',L1)
 4120 FORMAT(50X,39HGRID SPACING IN VERTICAL DIRECTION, IN ,A4/ &
     (10(F10.3)))
 4130 FORMAT(50X,47HGRID SPACING IN HORIZONTAL OR RADIAL DIRECTION,  &
      ,3H IN,1X,A4/(10F10.3))
 4140 FORMAT(5X,43HTIMES AT WHICH H WILL BE WRITTEN TO FILE 08 &
      /10(5X,10E12.5,/))
 4150 FORMAT(5X,37HROW AND COLUMN OF OBSERVATION POINTS:/ &
      10(2X,2I5))
 4160 FORMAT(5X,'MASS BALANCE COMPONENTS WRITTEN TO FILE 9',  &
      /,5X,24I4)
 4170 FORMAT(5X,36HMATRIX EQUATIONS TO BE SOLVED BY SIP)
 4180 FORMAT(5X,100(1H*)/5X,17HEND OF SIMULATION/ &
        5X,100(1H*))
 4190 FORMAT(5X,'TOTAL NUMBER OF ITERATIONS FOR FLOW EQUATION = ',I6  &
      /5X,'TOTAL NUMBER OF ITERATIONS FOR TRANSPORT EQUATION = ',I6)
 4200 FORMAT(5X,'CENTRAL DIFFERENCING IN SPACE USED FOR TRANSPORT',  &
     ' EQUATION')
 4210 FORMAT(4X,' BACKWARD DIFFERENCING IN SPACE USED FOR TRANSPORT',  &
     ' EQUATION')
 4220 FORMAT(4X,' CENTRAL DIFFERENCING IN TIME USED FOR TRANSPORT',  &
     ' EQUATION')
 4230 FORMAT(4X,' BACKWARD DIFFERENCING IN TIME USED FOR TRANSPORT',  &
     ' EQUATION')
 4240 FORMAT(4X,' TRANSPORT TO BE SIMULATED')
 4250 FORMAT(4X,' NONLINEAR SORPTION TO BE SIMULATED')
      END
      SUBROUTINE STEP(JSTP)
!*** THIS IS THE SECOND HALF OF THE ORIGINAL MAIN CODE. THIS
!*** PERFORMS A SINGLE TIME STEP. THE LOOPING IS DONE IN THE CALLING
! *** PROGRAM. THE SUBROUTINE RETURNS THE SIMULATION TIME, TIME STEP,
! *** AND THE FLAG JSTP. WHEN JSTP EQUALS 1, THIS SIGNIFIES
! *** END OF SIMULATION.
      use rspac
      use kcon
      use mprop
      use press
      use disch
      use hcon
      use equat
      use jtxx
      use dumm
      use ptet
      use trxx
      use trxy1
      use plott
      use spfc
      use rpropsh
      use scon
      use equats
      use trxy2
      use trxxh
      use trxv
      use temp
      use tempcc   
      use pricon
      use coordin
      use solindex
      use phreecc
      use react
      use SCON
      USE vs2dt_rm
      USE PhreeqcRM   
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      common/conversion/CNVTM,CNVTMI 
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      COMMON/PND/POND
      COMMON/WGT/WUS,WDS
      COMMON/SCN1/TMPX,TMLT,DLTMX,DLTMIN,TRED
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      COMMON/JCON/JSTOP,JFLAG,jflag1
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
      F14P,F15P,F16P,F17P,F18P,F19P
      LOGICAL THPT,SPNT,PPNT,HPNT,VPNT
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
      F14P,F15P,F16P,F17P,F18P,F19P
      COMMON/LOG4/THPT,SPNT,PPNT,HPNT,VPNT
      CHARACTER*80 TITL,filen,f5,f6,f7,f8,f9,f10,f11
      CHARACTER*6 ZUNIT,CUNX,HUNX
      CHARACTER*7 TUNIT
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX
      integer hydraulicFunctionType
      common/functiontype/ hydraulicFunctionType      
      COMMON/TTT/ IFET,IFET1,NITT,NITT1,NITT2
      LOGICAL HEAT,SOLUTE,FLOW
      COMMON/TRANSTYPE/HEAT,SOLUTE
      COMMON/TCON1/NIS,NIS1,NIS3
      COMMON/TTT1/NISS,NISS1,NISS2
      COMMON/FLO/FLOW
      COMMON/SCON1/ITESTS
      character(100) msg
      
!
! -------------------------------------------------------------
!       START OF TIME LOOP
! -------------------------------------------------------------
!
160   IF(JFLAG.EQ.1)IFET1=1
      IF (JSTOP.GT.1) THEN
         JSTP=JSTOP
         RETURN
      ENDIF
      CALL VSTMER
!
! *** IF NO MORE PERIODS TO SIMULATE, JSTOP IS SET TO 1 IN VSTMER,
! *** WE JUST RETURN AND LET THE CALLING PROGRAM TERMINATE THE
!*** THE EXECUTION
      IF (JSTOP.GT.1) THEN
         JSTP=JSTOP
         RETURN
      ENDIF
!
       TRANS1=.FALSE.
!     IF(.NOT.SSTATE) THEN
!
!   SET UP AND SOLVE MATRIX EQUATIONS FOR FLOW
!
       NIT3=0
       TRANS2=.FALSE.
 170   TRANS1=.FALSE.
!
!   SET UP AND SOLVE MATRIX EQUATIONS FOR FLOW
!
      if(nit3.gt.100) then
	  jstop = 11
	  jstp = jstop
	  return
	  end if
      nit=0
      CALL VSMGEN
      IF (JSTOP.GT.1) THEN
         JSTP=JSTOP
         RETURN
      ENDIF
!
!   CHECK FOR PONDING DURING THIS TIME STEP
!
      CALL VSPOND(IFET,IFET1,IFET2)
!
!   IF PONDING HAS OCCURRED, EQUATIONS NEED TO BE SOLVED AGAIN
!
      IF(IFET.NE.0) THEN
      IF(NIT.LT.ITMAX) THEN
      DO 50 II=1,NNODES
      IF(NTYP(II).NE.1.AND.HX(II).GT.0.0D0) P(II)=PXXX(II)
   50 CONTINUE
      nit = 1
      GO TO 170
      ELSE
      WRITE(6,4260)
      END IF
      END IF
!
!   REEVALUATE NONLINEAR COEFFICIENTS
!
      CALL VSCOEF
      NITT=NITT+NIT
!     END IF
!      IF((TRANS.OR.VPNT).AND..NOT.SSTATE) CALL VTVELO
      IF(TRANS.OR.VPNT) CALL VTVELO
!
!  Heat transport
!        
      IF(HEAT) THEN
!      IF(.NOT.SSTATE) THEN
!
!   DETERMINE VELOCITIES AND DISPERSION TENSOR
!
      CALL VTDCOEF
!      END IF
      TRANS1=.TRUE.
!
!   SET UP AND SOLVE MATRIX EQUATION FOR TRANSPORT
!
      CALL VTSETUP
      NITT1=NITT1+NIT1
      DMAX1=0.0D0
      NIT3=NIT3+1
      IF(NIT3.LT.2.OR.RHOMAX.GT.EPS2) GO TO 170
      DO 190 N=1,NNODES
      RHOOLD(N)=RHO(N)
 190  CONTINUE
      NITT2=NITT2+NIT3
      END IF
     
!
! Reactive solute transport      
!      
      IF(SOLUTE) THEN
!     
!      IF(.NOT.SSTATE) THEN
!
!   DETERMINE VELOCITIES AND DISPERSION TENSOR
!
      CALL VTDCOEFSOL
! 
!     END IF
      TRANS2=.TRUE.
     
!
!   SET UP AND SOLVE MATRIX EQUATION FOR TRANSPORT
!
      CALL VTSETUPSOL

!      NISS=NISS+ NIS1
!
!   PRINT RESULTS AND COMPUTE MASS BALANCE COMPONENTS
!
      DO 202 I=1, NNODES
      DO 201 J=1, Nsol
!      K=Nsol*(I-1)+J
!      phreeC(K)=CC(J,I)
      CCBR(J,I)=CC(J,I)
  201 CONTINUE
  202 CONTINUE
!      write(*,*)'beforereactionnnnnnnnnnnnnnnnnnn'
!      CALL VSOUTS(1,CC)
      do 161 J=1,NLY
      do 150 N=1,NXR
        IN=NLY*(N-1)+1
        if(hydraulicFunctionType.eq.0)then
          THETA(IN)=VSTHUBC(P(IN),JTEX(IN))
            else if(hydraulicFunctionType.eq.1)then
               THETA(IN)=VSTHUVG(P(IN),JTEX(IN))
              else if(hydraulicFunctionType.eq.2)then
                  THETA(IN)=VSTHUHK(P(IN),JTEX(IN))
                    else if(hydraulicFunctionType.eq.4)then
                      THETA(IN)=VSTHUOT(P(IN),JTEX(IN))
                  end if
  150 CONTINUE
  161 CONTINUE 
      iprrestartflag = 0 
      istopmsg = 0
      !#if (HEAT.AND.SOLUTE)THEN
      !#CALL EQUILIBRATEWHEAT( cc,hx,tt,NNODES,heat,nprconc,xnode,znode,  &
      !#tper,delt,npscrn,cnvtmi,nprchem,nprchxz,ipout,istopmsg,  &
      !#theta,iprrestartflag)
      !#ELSE if((.not.heat).and.solute)then
      !#call EQUILIBRATE( cc,hx,NNODES,nprconc,xnode,znode,  &
      !#tper,delt,npscrn,cnvtmi,nprchem,nprchxz,ipout,istopmsg,  &
      !#theta,iprrestartflag)  
      !#END IF
      IF (SOLUTE) THEN
          call SetConcentrationsRM(cc)
          IF (HEAT) THEN
              status = RM_SetTemperature(rm_id, tt)
          endif
          status = RM_SetTime(rm_id, stim)
          status = RM_SetTimeStep(rm_id, delt)
          status = RM_SetTimeConversion(rm_id, cnvtmi)
          status = RM_SetPrintChemistryMask(rm_id, nprchem)
          status = RM_SetPrintChemistryOn(rm_id, ipout, ipout, ipout)
          DO J=1,NLY
              DO N=1,NXR
                  IN=NLY*(N-1)+J
                  SATUR(IN) = 0.0d0
                  IF(POROSITY(IN).GT.0.0D0.AND.HX(IN).GT.0.0D0) THEN
                      SATUR(IN)=THETA(IN)/POROSITY(IN)
                  END IF
              enddo
          enddo
          status = RM_SetSaturation(rm_id, satur)
          !if (npscrn .ne. 0) then
              write(msg,"(A,F12.2)") "Chemistry at time: ", stim
              status = RM_SetScreenOn(rm_id, 1)
              status = RM_ScreenMessage(rm_id, msg)
              status = RM_SetScreenOn(rm_id, 0)
          !endif
          status = RM_RunCells(rm_id)
          call GetConcentrationsRM(cc)
          !call FH_WriteFiles(rm_id, ihdf, imedia, ixyz, nprchxz, iprrestartflag) 
          call FH_WriteFiles(rm_id, 0, 0, 1, nprchxz, iprrestartflag)
      END IF      
      if (solute) then
          if (heat) then
          endif
      endif
!      write(*,*)'after...reactionnnnnnnnnnnnnnnnnnn'
!      CALL VSOUTS(1,CC)
      DO 204 I=1, NNODES
      DO 203 J=1, Nsol
      K=Nsol*(I-1)+J
      CCAR(J,I)=CC(J,I)
 203  CONTINUE
 204  CONTINUE
      END IF
!
!   PRINT RESULTS AND COMPUTE MASS BALANCE COMPONENTS
!
      CALL VSOUTP
      CALL VSFLUX
!     IF(JSTOP.NE.1) GO TO 160
!
!-------------------------------------------------------------------
!     END OF TIME LOOP
!-------------------------------------------------------------------
!
! *** ASSIGN VALUES TO SUBROUTINE ARGUMENTS TO RETURN
      JSTP = JSTOP
      RETURN
 4260 FORMAT(5X,'-- WARNING --  INFILTRATION/PONDING BOUNDARY WAS NOT',  &
      ' SOLVED ACCURATELY FOR THIS TIME STEP')
      END
    
      SUBROUTINE VSREAD
!******
!VSREAD
!******
!
!   PURPOSE: TO READ INITIAL HEAD AND SATURATION DATA
!
! ----------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use rspac
      use kcon
      use mprop
      use press
      use jtxx
      use dumm
      use ptet
      use trxx
      use idumm
      use rpropsh
      use scon
      use equat
      use BF
      use equats
      use trxy2
      use trxxh
      use trxv
      use temp
      use coordin
      use solindex
      use phreecc
      use compnam
      use itemblo
      use itemtxb
      use react
      USE vs2dt_rm
      USE PhreeqcRM
      USE PRICON
      use SCON
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      
      common/conversion/CNVTM,CNVTMI 
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      COMMON/WGT/WUS,WDS
      COMMON/JCON/JSTOP,JFLAG,jflag1
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      LOGICAL PHRD
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
      F14P,F15P,F16P,F17P,F18P,F19P
      COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
      F14P,F15P,F16P,F17P,F18P,F19P
      COMMON/hinterp/ DELPP,nprop,I1,I2,I3,I4,I5,I6
      CHARACTER*80 TITL
      CHARACTER*80 IFMT,FREE,UNFORMATTED
      CHARACTER*6 ZUNIT,CUNX,HUNX
      CHARACTER*7 TUNIT      
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX
      integer hydraulicFunctionType,iuTemperature,iuHead,iuConcentration
      common/functiontype/ hydraulicFunctionType
!      COMMON/VERSION/VER2P5
!     LOGICAL VER2P5
      common/iuNumber/ iuHead, iuConcentration,iuTemperature
      LOGICAL HEAT,SOLUTE,FLOW
      COMMON/TRANSTYPE/HEAT,SOLUTE
      integer NHTPROP,NSTPROP
      COMMON/TRANNSPROP/NHTPROP,NSTPROP
      COMMON/FLO/FLOW
!      LOGICAL VER1P0
!      COMMON/VERSION/VER1P0   
      !DIMENSION Solcomp(50)
      common/solind/ INSOL1(7),INSOL2(7),Solcomp(50)
      logical axes(2) 
      common/axis/axes
      common/ITEMK/KNLY,KNXR,KNNODE
      integer :: iu = 101
      character*256 :: myline
      integer :: myerr
      !!@@include 'd_idummAlloc.inc'
      allocate(IDUM(NXR))
      !!@@include 'd_itembloAlloc.inc'
      allocate(ITEMBL(KNNODE),ITBDUM(KNXR))
      !!@@include 'd_itemtxbAlloc.inc'
      allocate(ITEMTX(KNNODE),ITDUM(KNXR))
      
!-----------------------------------------------------------------------
!
!   READ AND WRITE INITIAL DATA FOR SIMULATION
!
      FREE = 'free'
      UNFORMATTED = 'unformatted'
!
!     modified for reactive transport
!     
      READ (5,'(A)') myline
      READ(myline,*,IOSTAT=myerr) EPS,HMAX,WUS
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  EPS,HMAX,WUS'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  EPS,HMAX,WUS'
      endif
      EPS1=0.0D0
      EPS2=0.0D0
      EPS3=0.0D0
      IF (HEAT) then
          READ (5,'(A)') myline
          read (myline,*,IOSTAT=myerr)EPS1,EPS2
          if (myerr .ne. 0) then
              write(6,'(A)') 'Error reading: EPS1,EPS2'
              write(6,'(A,A)') 'Last line: ', myline
              flush(6)
              stop 'Error reading: EPS1,EPS2'
          endif
      endif
      if (SOLUTE) then
          READ (5,'(A)') myline
          read (myline,*,IOSTAT=myerr)EPS3
          if (myerr .ne. 0) then
              write(6,'(A)') 'Error reading: EPS3'
              write(6,'(A,A)') 'Last line: ', myline
              flush(6)
              stop 'Error reading: EPS3'
          endif
      endif
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) MINIT,ITMAX
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  MINIT,ITMAX'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  MINIT,ITMAX'
      endif
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) PHRD
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  PHRD'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  PHRD'
      endif
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) NTEX,NPROP
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  NTEX,NPROP'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  NTEX,NPROP'
      endif
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) hydraulicFunctionType
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  hydraulicFunctionType'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  hydraulicFunctionType'
      endif
!      READ (05,*) iuTemperature
      NHTPROP = 0
      NSTPROP = 0
      IF(HEAT) NHTPROP=6
      IF(SOLUTE) NSTPROP=3
!
!  revision for Rossi-Nimmo
!
      if (hydraulicFunctionType.eq.4) nprop = 19
      !!@@include 'd_rpropshAlloc.inc'
      allocate(HK(NTEX,NPROP))
      allocate(HT(NTEX,6))
      allocate(HS(NTEX,3))
      allocate(ANIZ(NTEX))      
      if (hydraulicFunctionType.eq.4) nprop = 6
!
!  end revision
!
!
!   CHECK THAT SUM OF WEIGHTING FACTORS IS EQUAL TO ONE
!
      WRITE (6,4000) EPS,ZUNIT,EPS1,EPS2,EPS3,HMAX
      IF(WUS.EQ.1.0D0) THEN
      WDS=0.0D0
      WRITE(06,4020)
      ELSE
      IF(WUS.EQ.0.5D0) THEN
      WDS=0.5D0
      WRITE(06,4070)
      ELSE
      WUS=0.0D0
      WRITE(06,4010)
      END IF
      END IF
      WRITE (6,4080) NTEX,NPROP,NHTPROP,NSTPROP,MINIT,ITMAX
      !!@@include 'd_sconAlloc.inc'
      allocate (DHMX(ITMAX+1))
!      include 'c_sconItmax
      WRITE (06,4100)
      IF (HEAT) WRITE(06,4110)
      IF (SOLUTE) WRITE(06,4111)
!
!   READ AND WRITE MATERIAL PROPERTIES FOR EACH TEXTURAL CLASS
!

      DO 21 J22=1,NTEX
      DO 10 J23=1,NPROP
   10 HK(J22,J23)=0.0D0
      DO 20 J23=1,NHTPROP
   20 HT(J22,J23)=0.0D0
      DO 21 J23=1,NSTPROP
   21 HS(J22,J23)=0.0D0
      
      DO 30 J22=1,NTEX
         READ (5,'(A)') myline
         READ (myline,*,IOSTAT=myerr) J
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  J'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  J'
         endif
         READ (5,*,IOSTAT=myerr) ANIZ(J),(HK(J,I),I=1,NPROP)
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  ANIZ(J),(HK(J,I),I=1,NPROP)'
            flush(6)
            stop 'Error reading:  ANIZ(J),(HK(J,I),I=1,NPROP)'
         endif
      WRITE (6,4120) J,ANIZ(J),(HK(J,I),I=1,NPROP)
      IF(HEAT) THEN
!
!  modification to read for heat transport 
!
         read(5,*,IOSTAT=myerr) (HT(j,I),I=1,6)
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  (HT(j,I),I=1,6)'
            flush(6)
            stop 'Error reading:  (HT(j,I),I=1,6)'
         endif
         write(6,4130) (HT(j,I),I=1,6)
         HT(J,3)=HT(J,3)*(1.-HK(J,3))
      END IF
      IF(SOLUTE) THEN
!
!  modification to read for solute transport
!
         read(5,*,IOSTAT=myerr) (HS(j,I),I=1,3)
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  (HS(j,I),I=1,3)'
            flush(6)
            stop 'Error reading:  (HS(j,I),I=1,3)'
         endif
         write(6,4130)(HS(j,I),I=1,3)
      END IF
!
!  revsion for Rossi-Nimmo
!
      if(j.ne.1) then
      if (hydraulicFunctionType.eq.4) then
       hk(j,7) = hk(j,4)*(2.0D0/(2.0D0+hk(j,6)))**(-1.0D0/hk(j,6))
       hk(j,8) = .50D0*hk(j,6)*(2.0D0/(2.0D0+hk(j,6)))**((2.0D0+hk(j,6)/hk(j,6)))
       hk(j,9) =  hk(j,6)*exp(1.0D0)*(hk(j,4)/hk(j,5))**hk(j,6)
       hk(j,10) = hk(j,5)*exp(-1.0D0/hk(j,6))
       hk(j,11) = VSTHUOT(-hk(j,7),j)
       hk(j,12) = VSTHUOT(-hk(j,10),j)
       hk(j,14) = (hk(j,6) + 1.0D0)/hk(j,6)
       hk(j,15) = (hk(j,12)/hk(j,3))**hk(j,14)
       hk(j,16) = 2.0D0*(hk(j,8))**(.50D0)/hk(j,4)
       hk(j,17) = (1.0D0 - hk(j,11)/hk(j,3))**(0.50D0)
       hk(j,18) = hk(j,9)*(exp(hk(j,12)/(hk(j,9)*hk(j,3)))-1.0D0)/hk(j,5)
       hk(j,19) = hk(j,18)+((hk(j,11)/hk(j,3))**hk(j,14)-hk(j,15))/(hk(j,4)*hk(j,14))
       hk(j,13) = hk(j,19) + hk(j,16)*hk(j,17)
       hk(j,13) = hk(j,13)*hk(j,13)  
!      pt = 0.0D0

      end if
      end if
!
!  end revisions
!
 30    CONTINUE

!     convert alpha parameter if reading version 2.5 data set
!      IF (VER2P5.AND.(hydraulicFunctionType.EQ.1)) THEN
!         DO 31 J=1,NTEX
!            IF (HK(J,4).NE.0) THEN
!               HK(J,4) = -1.D0/HK(J,4)  
!            END IF
!   31    CONTINUE
!     ENDIF
      WRITE (06,4140)
!
!    READ TEXTURAL CLASS INDEX MAP
!
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) IROW
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  IROW'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  IROW'
      endif
      IF(IROW.EQ.0) THEN
!      DO 54 K=1,NNODES
!        JTEX(K)=1
!        J22=JTEX(K)
!        HX(K)=HK(J22,1)
!  54  CONTINUE        
!      WRITE(06,4090)
!      DO 51 J=1,KNLY
!      READ (05,*)(ITBDUM(N),N=1,KNXR)
!      DO 41 N=1,KNXR
!      IN=KNLY*(N-1)+J
!      I22=ITBDUM(N)
!  41  ITEMBL(IN)=I22
!  51  CONTINUE 
!      DO 52 J=1,KNLY
!      READ (05,*) (ITDUM(N),N=1,KNXR)
!      DO 42 N=1,KNXR
!      IN=KNLY*(N-1)+J
!      NI=NLY*N+J+1
!      NTEMBX=ITDUM(N)
!      ITEMTX(IN)=NTEMBX
!      if(ITEMBL(IN).EQ.0)ITEMTX(IN)=1
!      ITBDUM(N)=ITEMTX(IN) 
!      ITEMTX(IN)=ITBDUM(N)
!      JTEX(NI)=ITEMTX(IN)
!      J22=JTEX(NI)
!      HX(NI)=HK(J22,1)
!  42  CONTINUE
!  52  CONTINUE
  
!      DO 55 J=1,NLY
!      DO 45 N=1,NXR
!      IN=NLY*(N-1)+J
!      IDUM(N)=JTEX(IN)
!  45  CONTINUE
!      if (ntex.gt.9) then
!       write (06,4151) j,(idum(n),n=1,nxr)
!      else
!       WRITE (06,4150) J,(IDUM(N),N=1,NXR)
!      end if
!  55 CONTINUE      
!      ELSE
!Uncoment the next lines until the else statement located below label 50 contiune statement line
! and remove or coment the lines between if you are not using inputfile generated by Argus ONE GUI
     WRITE(06,4090)
     DO 50 J=1,NLY
        READ (5,*,IOSTAT=myerr) (IDUM(N),N=1,NXR)
        if (myerr .ne. 0) then
           write(6,'(A)') 'Error reading:  (IDUM(N),N=1,NXR)'
           flush(6)
           stop 'Error reading:  (IDUM(N),N=1,NXR)'
        endif
      if (ntex.gt.9) then
      write (06,4151) j,(idum(n),n=1,nxr)
      else
       WRITE (06,4150) J,(IDUM(N),N=1,NXR)
      end if
     DO 40 N=1,NXR
     IN=NLY*(N-1)+J
      J22=IDUM(N)
      HX(IN)=HK(J22,1)
  40 JTEX(IN)=J22
  50 CONTINUE
      ELSE
          !
          !    READ TEXTURE CLASSES BY BLOCK--EITHER CONTINUOUS LAYERS OR
          !    LAYERS BOUNDED BY VERTICAL DISCONTINUITIES.
          !
          WRITE (06,4040)
          JTP=1
60        continue
          READ (5,'(A)') myline
          READ (myline,*,IOSTAT=myerr) IL,IR,JBT,JRD
          if (myerr .ne. 0) then
             write(6,'(A)') 'Error reading:  IL,IR,JBT,JRD'
             write(6,'(A,A)') 'Last line: ', myline
             flush(6)
             stop 'Error reading:  IL,IR,JBT,JRD'
          endif
          DO 70 N=IL,IR
              IDUM(N)=JRD
70        CONTINUE
          IF(IR.LT.NXR) GO TO 60
          DO 80 J=JTP,JBT
              if (ntex.gt.9) then
                  write (06,4151) j,(idum(n),n=1,nxr)
              else
                  WRITE (06,4150) J,(IDUM(N),N=1,NXR)
              end if
80        continue
          DO 90 J=JTP,JBT
              DO 90 N=1,NXR
                  IN=NLY*(N-1)+J
                  J22=IDUM(N)
                  HX(IN)=HK(J22,1)
                  JTEX(IN)=J22
90        CONTINUE
          IF(JBT.EQ.NLY) GO TO 100
          JTP=JBT+1
          GO TO 60
      END IF
100   CONTINUE
!
!   BORDERS OF DOMAIN ARE ALL SET TO NO FLOW BOUNDARIES
!
      DO 110 I=1,NLY
      I1=NNODES-I+1
      HX(I)=0.0D0
  110 HX(I1)=0.0D0
      DO 120 I=2,NXR
      I1=(I-1)*NLY
      HX(I1)=0.0D0
  120 HX(I1+1)=0.0D0
!
!   READ INITIAL HEADS OR MOISTURE CONTENTS
!
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) IREAD,FACTOR
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  IREAD,FACTOR'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  IREAD,FACTOR'
      endif
      IF(IREAD.EQ.2) THEN
         READ (5,'(A)') myline
         READ (myline,*,IOSTAT=myerr) DWTX,HMIN
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  DWTX,HMIN'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  DWTX,HMIN'
         endif
      WRITE (06,4190) DWTX,ZUNIT,HMIN,ZUNIT,DWTX,ZUNIT
!
!  CALCULATE EQUILIBRIUM INITIAL HEAD PROFILE
!
      DO 130 J=2,NLYY
      DO 130 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).EQ.0.0D0) GO TO 130
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      P1=Z1-DWTX
      IF(P1.LT.HMIN)P1=HMIN
      P(IN)=P1-Z1
      PXXX(IN)=P(IN)
  130 CONTINUE
      ELSE
      IF(IREAD.EQ.0) THEN
      WRITE (6,4170) FACTOR
      ELSE 
      IF(IREAD.EQ.1) then
         READ (5,'(A)') myline
         READ(myline,*,IOSTAT=myerr)IU,IFMT
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading: IU,IFMT'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading: IU,IFMT'
         endif
      endif
      END IF
!      if(IFMT.eq.UNFORMATTED) then
      if(iread.eq.3) then
       stimStart = -1.d0
       write (6,4181) stim, TUNIT
       if (trans) then
       do 
        read (13,err = 131, end = 132) stimStart, p, cc
        if (stimStart.ge.stim) EXIT
       end do
       else
        do
         read (13,err = 131, end = 132) stimStart, p
         if (stimStart.ge.stim) EXIT
        end do
       end if
 132   continue
       if (stimStart.ne.stim) then
        write (6,4183) stim, TUNIT, stimStart, TUNIT
        stim = stimStart
       end if
       go to 133
 131   write (6,4182)
       jstop = 11
       return
      else
      WRITE (06,4180) IU,FACTOR
       
      DO 160 J=1,NLY
      do I=1,NXR
        DUM(I)=0.0D0
      END DO   
      IF(IREAD.EQ.1) then
      IF(IFMT.eq.FREE) THEN
!
!   READ INITIAL CONDITIONS FROM FILE IU
!
      read (iu,*) (dum(n),n=1,nxr)
      ELSE
!      READ (iuHead,FMT=IFMT) (DUM(N),N=1,NXR)
      READ (IU,FMT=IFMT) (DUM(N),N=1,NXR)
      end if
      else
      DO 140 N=1,NXR
  140 DUM(N)=FACTOR
      end if
      DO 150 N=1,NXR
      IN=NLY*(N-1)+J
      IF(IREAD.ne.0)DUM(N)=DUM(N)*FACTOR
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      IF(.NOT.PHRD) THEN
      IF(DUM(N).LE.0.0D0) THEN
      WRITE(6,4230) J,N
      jstop=4
      return
      END IF
!
!   CONVERT INITIAL MOISTURE CONTENTS TO HEADS
!
      if(hydraulicFunctionType.eq.1) then
       P(IN)=VSTHNVVG(DUM(N),JTEX(IN))-Z1
      else
       if(hydraulicFunctionType.eq.2) then
        P(IN)=VSTHNVHK(DUM(N),JTEX(IN))-Z1
       else
        if(hydraulicFunctionType.eq.0) then
         P(IN)=VSTHNVBC(DUM(N),JTEX(IN))-Z1
        else
         if(hydraulicFunctionType.eq.3) then
          P(IN)=VSTHNVTAB(DUM(N),JTEX(IN))-Z1
         else
          P(IN)=VSTHNVOT(DUM(N),JTEX(IN))-Z1
         end if
        end if
       end if
      end if
      THETA(IN)=DUM(N)
      ELSE
      P(IN)=DUM(N)-Z1
      END IF
      PXXX(IN)=P(IN)
  150 CONTINUE
  160 CONTINUE
      end if
      if(jstop.gt.1) return
!
!   COMPUTE INITIAL NONLINEAR COEFFICIENT VALUES
!
      END IF
      
 133  CALL VSCOEF
!
!   IF ET IS TO BE SIMULATED, ALL VARIABLES MUST BE ENTERED HERE.
!
      READ (5,'(A)') myline
      READ(myline,*,IOSTAT=myerr) BCIT,ETSIM
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  BCIT,ETSIM'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  BCIT,ETSIM'
      endif
      IF(BCIT .OR. ETSIM) THEN
!
!   COMPUTE DEPTHS FOR ET CALCULATIONS
!
      DPTH(1)=-0.5D0 *DELZ(1)
      DO 170 J=2,NLYY
      DO 170 N=2,NXRR
      IN=NLY*(N-1)+J
      JM1=IN-1
      IF(HX(IN).NE.0.0D0) THEN
      IF(HX(JM1).EQ.0.0D0) THEN
      DPTH(IN)=0.0D0
      ELSE
      DPTH(IN)=DPTH(JM1)+DELZ(J-1)
      END IF
      END IF
  170 CONTINUE
      WRITE (6,4200)
      CALL VSOUT(2,DPTH)
!
!   READ EVAPORATION VARIABLES
!
      READ (5,'(A)') myline
      READ(myline,*,IOSTAT=myerr)NPV,ETCYC
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading: NPV,ETCYC'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading: NPV,ETCYC'
      endif
      npv1 = npv
      if(npv.lt.0) npv = -npv
      !!@@include 'd_ptetAlloc.inc'
      allocate(PEVAL(NPV))
      allocate(PTVAL(NPV))
      allocate(RDC(6,NPV))
      DO 713 I=1,NPV
      PEVAL(I) = 0.0D0
      PTVAL(I) = 0.0D0
      DO 714 J=1,6
      RDC(J,I) = 0.0D0
 714  CONTINUE
 713  CONTINUE
      WRITE(6,4030) NPV,ETCYC,TUNIT
      IF(BCIT) THEN
         READ (5,*,IOSTAT=myerr)(PEVAL(I),I=1,NPV)
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading: (PEVAL(I),I=1,NPV)'
            flush(6)
            stop 'Error reading: (PEVAL(I),I=1,NPV)'
         endif
         READ(5,*,IOSTAT=myerr)(RDC(1,I),I=1,NPV)
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading: (RDC(1,I),I=1,NPV)'
            flush(6)
            stop 'Error reading: (RDC(1,I),I=1,NPV)'
         endif
         READ(5,*,IOSTAT=myerr)(RDC(2,I),I=1,NPV)
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading: (RDC(2,I),I=1,NPV)'
            flush(6)
            stop 'Error reading: (RDC(2,I),I=1,NPV)'
         endif
      WRITE (06,4050)ZUNIT,TUNIT,ZUNIT,ZUNIT,(I,PEVAL(I),RDC(1,I),  &
      RDC(2,I),I=1,NPV)
      END IF
      IF (ETSIM )THEN
!
!   READ TRANSPIRATION VARIABLES
!
         READ(5,*,IOSTAT=myerr)(PTVAL(I),I=1,NPV)
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading: (PTVAL(I),I=1,NPV)'
            flush(6)
            stop 'Error reading: (PTVAL(I),I=1,NPV)'
         endif
         READ(5,*,IOSTAT=myerr) (RDC(3,I),I=1,NPV)
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  (RDC(3,I),I=1,NPV)'
            flush(6)
            stop 'Error reading:  (RDC(3,I),I=1,NPV)'
         endif
         READ(5,*,IOSTAT=myerr) (RDC(4,I),I=1,NPV)
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  (RDC(4,I),I=1,NPV)'
            flush(6)
            stop 'Error reading:  (RDC(4,I),I=1,NPV)'
         endif
         READ(5,*,IOSTAT=myerr) (RDC(5,I),I=1,NPV)
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  (RDC(5,I),I=1,NPV)'
            flush(6)
            stop 'Error reading:  (RDC(5,I),I=1,NPV)'
         endif
         READ(5,*,IOSTAT=myerr) (RDC(6,I),I=1,NPV)
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  (RDC(6,I),I=1,NPV)'
            flush(6)
            stop 'Error reading:  (RDC(6,I),I=1,NPV)'
         endif
      WRITE(06,4060)ZUNIT,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT,(I,PTVAL(I),  &
      (RDC(J,I),J=3,6),I=1,NPV)
      NPV = npv1
      END IF
      END IF
      DO 180 IN=1,NNODES
      NTYP(IN)=0
      IF(SOLUTE) NCTYP(IN)=0
      IF(HEAT) NHTYP(IN)=0
      IF(HX(IN).GT.0.0D0) THLST(IN)=THETA(IN)
  180 CONTINUE
!
!    READ INITIAL TEMPERATURES IF TRANSPORT EQUATION IS TO
!    BE SOLVED
!
      IF (HEAT) THEN
         READ (5,'(A)') myline
         READ(myline,*,IOSTAT=myerr) IREAD,FACTOR
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  IREAD,FACTOR'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  IREAD,FACTOR'
         endif
      IF(IREAD.EQ.0) THEN
      WRITE(6,4210) FACTOR
      DO 190 N=1,NNODES
      IF(HX(N).GT.0.0D0) THEN
       TT(N) = FACTOR
       TTOLD(N)= FACTOR
      ELSE
       TT(N) = 0.0D0
       TTOLD(N)= 0.0D0
      END IF
      RHO(N)=VTRHO(TT(N),JTEX(N))
      RHOOLD(N)=RHO(N)
  190 CONTINUE
      ELSE
         READ (5,'(A)') myline
         READ(myline,*,IOSTAT=myerr)IU,IFMT
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading: IU,IFMT'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading: IU,IFMT'
         endif
      if (IFMT.NE.UNFORMATTED) then
      WRITE(06,4220) IU,FACTOR
      DO 202 J=1,NLY
      if (IFMT.EQ.FREE) then
       read(iu,*) (dum(n),n=1,nxr)
      else
!       READ(iuConcentration,FMT=IFMT) (DUM(N),N=1,NXR)
       READ(iu,FMT=IFMT) (DUM(N),N=1,NXR)
      end if
       DO 202 N=1,NXR 
      IN=NLY*(N-1)+J
      IF(HX(IN).GT.0.0D0) THEN
       TT(IN)=DUM(N)*FACTOR
       TTOLD(IN)=TT(IN)
      ELSE
       TT(IN)=0.0D0
       TTOLD(IN)= 0.0D0   
      end if
      RHO(IN)=VTRHO(TT(IN),JTEX(IN))
      RHOOLD(IN)=RHO(IN) 
  202 CONTINUE   
      end if
      end if
      else
      do 210 n = 1,nnodes    
      RHO(N)=VTRHO(TT(N),JTEX(N))
      RHOOLD(N)=RHO(N)
  210 CONTINUE
      END IF
!
!    READ INITIAL MULTI-SOLUTE CONCENTRATION IF SOLUTE TRANSPORT EQUATION IS TO
!    BE SOLVED
!      
      IF (SOLUTE) THEN
         READ (5,'(A)') myline
         READ(myline,*,IOSTAT=myerr) IREAD
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  IREAD'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  IREAD'
         endif
          insol2 = -1
          indsol2 = -1
          cmixfarc = 1.0d0
          !INSOL2(1)=2
          !DO  I=1,7
          !    INSOL2(I)=-1
          !    DO J=1,NNODES
          !        INDSOL2(I,J) = INSOL2(I)
          !        CMIXFARC(I,J) = 1.0d0
          !    END DO
          !END DO  
          IF(IREAD.EQ.0) THEN
             READ(5,*,IOSTAT=myerr)(INSOL1(I),I=1,7)
             if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading: (INSOL1(I),I=1,7)'
                flush(6)
                stop 'Error reading: (INSOL1(I),I=1,7)'
             endif
              INSOL2(1)=2
              DO 212 I=2,7
                  INSOL2(I)=-1
212           CONTINUE       
              DO 182 I=1,7
                  DO 181 J=1,NNODES
                      INDSOL1(I,J) = INSOL1(I)
                      !      INDSOL2(I,J) = INSOL2(I)
                      !      CMIXFARC(I,J) = 1.0d0
181               CONTINUE
182           CONTINUE
          ELSE if (IREAD.EQ.1)then
              DO 403 K=1,7  
                  DO 402 J=1,NLY
                     READ (5,*,IOSTAT=myerr)(DUM(N),N=1,NXR)
                     if (myerr .ne. 0) then
                        write(6,'(A)') 'Error reading: (DUM(N),N=1,NXR)'
                        flush(6)
                        stop 'Error reading: (DUM(N),N=1,NXR)'
                     endif
                      DO 401 N=1,NXR
                          IN=NLY*(N-1)+J
                          INDSOL1(K,IN)=DUM(N)
                          !      write(*,*)"INDSOL1(",K,",",NI,")=ITEMTX(",IN,")=",INDSOL1(K,NI),ITEMTX(IN)
401                   continue
402               continue
403           continue
          END IF 
          DO 185 I=1, Nsol
              Solcomp(I)=0.0d0
185       continue  
          DO 187 I=1, NLY
              DO 186 J=1, NXR
                  IN=NLY*(J-1)+I  
                  if (I.eq.1.or.I.eq.NLY)then
                      INDSOL1(1,IN)=-1
                      NPRCHEM(IN)=0
                      NPRCHXZ(IN)=0
                   else 
                    if (J.eq.1.or.J.eq.NXR)then
                      INDSOL1(1,IN)=-1
                      NPRCHEM(IN)=0
                      NPRCHXZ(IN)=0
                     else 
                      if (HX(IN).LE.0.0D0) then
                       INDSOL1(1,IN)=-1
                       NPRCHEM(IN)=0
                       NPRCHXZ(IN)=0
                     end if
                    end if 
                   end if    
 186           continue      
 187         continue 
          !      do 184 I=1,7
          !      do 183 J=1, NNODES  
          !     write(6,*)"INDSOL1(",I,",",J,")=",INDSOL1(I,J)
          ! 183  continue
          ! 184  continue   
          do 205 I=1, Nodesol
              phreeC(I)= 0.0d0
205       continue
          
          CALL CreateMappingRM(INDSOL1, axes, NXR, NLY) 
          ! Set porosity
          do i = 1, nnodes            
              porosity(i) = HK(jtex(i),3)
          enddo
          status = RM_SetPorosity(rm_id, porosity) 
          CALL InitializeRM(cmixfarc, indsol1, indsol2, ic1_reordered)
          CALL GetConcentrationsRM(cc)
          
          ! Set SolComp
          !status = RM_InitialPhreeqc2Concentrations(rm_id, Solcomp(1), 1, INSOL1(1))  
          do i = 1, Nsol
              WRITE(06,4012)COMPNAME(I), Solcomp(I)
          enddo  
          
          ! Set ccold
          do 203 J=1,NLY
          DO 203 N=1,NXR
              DO 201 M=1,Nsol
                  IN=NLY*(N-1)+J
                  CCOLD(M,IN)=CC(M,IN)
201           CONTINUE
203       CONTINUE
          do 162 J=1,NLY
              do 156 N=1,NXR
                  IN=NLY*(N-1)+1
                  if(hydraulicFunctionType.eq.0)then
                      THETA(IN)=VSTHUBC(P(IN),JTEX(IN))
                  else if(hydraulicFunctionType.eq.1)then
                      THETA(IN)=VSTHUVG(P(IN),JTEX(IN))
                  else if(hydraulicFunctionType.eq.2)then
                      THETA(IN)=VSTHUHK(P(IN),JTEX(IN))
                  else if(hydraulicFunctionType.eq.4)then
                      THETA(IN)=VSTHUOT(P(IN),JTEX(IN))
                  end if
156           CONTINUE
162       CONTINUE 
          iprrestartflag = 0 
          istopmsg = 0

          !if (HEAT.AND.SOLUTE)THEN
              !CALL EQUILIBRATEWHEAT( cc,hx,tt,NNODES,heat,nprconc,xnode,znode,  &
              !tper,delt,npscrn,cnvtmi,nprchem,nprchxz,ipout,istopmsg,  &
              !theta,iprrestartflag)
          !ELSE IF ((.NOT.HEAT).AND.SOLUTE)THEN
              !call EQUILIBRATE( cc,hx,NNODES,nprconc,xnode,znode,  &
              !tper,delt,npscrn,cnvtmi,nprchem,nprchxz,ipout,istopmsg,  &
              !theta,iprrestartflag)   
          !ENDIF
          IF (SOLUTE) THEN
              call SetConcentrationsRM(cc)
              IF (HEAT) THEN
                  status = RM_SetTemperature(rm_id, tt)
              endif
              
              status = RM_SetTime(rm_id, 0.0d0)
              status = RM_SetTimeStep(rm_id, delt)
              status = RM_SetTimeConversion(rm_id, cnvtmi)
              status = RM_SetPrintChemistryMask(rm_id, nprchem)
              status = RM_SetPrintChemistryOn(rm_id, ipout, ipout, ipout)
              status = RM_SetSaturation(rm_id, theta)
              status = RM_RunCells(rm_id)
              call GetConcentrationsRM(cc)
              !call FH_WriteFiles(rm_id, ihdf, imedia, ixyz, nprchxz, iprrestartflag) 
              call FH_SetPointers(xnode(1), xnode(1), znode(1), ic1_reordered(1,1), theta(1), forward1(1))
              call FH_WriteFiles(rm_id, 0, 0, 1, nprchxz(1), iprrestartflag)
          END IF
      END IF
!
!   COMPUTE INTERCELL CONDUCTANCES
!   
  
      CALL VSHCMP
!
!  modifications Aug 2008 to allow output of
!   fluxes along boundary segment.  Read in
!   cells on selected boundary faces here.
!
      if (f7p) then
         READ (5,'(A)') myline
         read(myline,*,IOSTAT=myerr) numBF, maxnumcells
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  numBF, maxnumcells'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  numBF, maxnumcells'
         endif
       !!@@include 'd_BFAlloc.inc'
!      if (allocated(idBF)) deallocate(idBF)
!      if (allocated(numcellsBF)) deallocate(numcellsBF)
!      if (allocated(nodenum)) deallocate(nodenum)
!      if (allocated(totalBF)) deallocate(totalBF)
!      if (allocated(currentBF)) deallocate(currentBF)
      allocate(idBF(numBF))
      allocate(numcellsBF(numBF))
      allocate(nodenum(numBF,maxnumcells))
      allocate(totalBF(numBF,2))
      allocate(currentBF(numBF,4))       
       do 250 i = 1,numBF
          READ (5,'(A)') myline
          read(myline,*,IOSTAT=myerr) idBF(i), numcellsBF(i)
          if (myerr .ne. 0) then
             write(6,'(A)') 'Error reading:  idBF(i), numcellsBF(i)'
             write(6,'(A,A)') 'Last line: ', myline
             flush(6)
             stop 'Error reading:  idBF(i), numcellsBF(i)'
          endif
        do 250 j = 1,numcellsBF(i)
           READ (5,'(A)') myline
           read (myline,*,IOSTAT=myerr) jj,nn
           if (myerr .ne. 0) then
              write(6,'(A)') 'Error reading:  jj,nn'
              write(6,'(A,A)') 'Last line: ', myline
              flush(6)
              stop 'Error reading:  jj,nn'
           endif
         nodenum(i,j) = nly*(nn-1) + jj
 250   continue
      end if
       !!@@include 'd_itembloDealloc.inc'
      if(allocated(itembl)) deallocate(ITBDUM)
	  if(allocated(itbdum)) deallocate(itbdum)
       !!@@include 'd_itemtxbDealloc.inc'
       deallocate(ITEMTX,ITDUM)
!     write(*,*)"Finshed reading initial data................................"    
      RETURN
 4000 FORMAT(10X,27HINITIAL MOISTURE PARAMETERS/10X,27(1H_)// &
     5X,'CONVERGENCE CRITERION FOR SIP FOR FLOW (EPS) =',1PE12.3,1X,A4/ &
     5X,'CONVERGENCE CRITERION FOR SIP FOR HEAT TRANSPORT (EPS1) =' ,  &
     1PE12.3,1X,/5X,'CONVERGENCE CRITERION FOR OUTER'& 
     'ITERATION (EPS2)  = ',1PE12.3,1X,/5X,'CONVERGENCE CRITERION'&  
     'FOR SIP FOR SOLUTE TRANSPORT(EPS3) =',1PE12.3,1X,/5X,  &
      23HDAMPING FACTOR,HMAX = ,1PE12.3)
! 4001 FORMAT(I1,A80)   
 4010 FORMAT(5X,46HGEOMETRIC MEAN USED FOR INTERCELL CONDUCTIVITY)
 4012 FORMAT(4X,A10,F10.6)
 4020 FORMAT(5X,50HUPSTREAM WEIGHTING USED FOR INTERCELL CONDUCTIVITY)
 4030 FORMAT(//15X,'NUMBER OF EVAPORATION AND/OR EVAPOTRASPIRATION PERIODS= ',  &
      I6,/,15X,'LENGTH OF EACH PERIOD = ',F10.4,2X,A4)
 4040 FORMAT(5X,'TEXTURAL CLASSES READ IN BY BLOCK')
 4050 FORMAT(//5X,'EVAPORATION   POTENTIAL      SURFACE   ATMOSHERIC', &
      /'       PERIOD        RATE       RESISTANCE    PRESSURE', &
      /19X,A4,'/',A4,3X,A4,'**(-1)',5X,A4,/,1X,90('-'),  &
      25(/,5X,I6,4X,3E14.5))
 4060 FORMAT(//,3X,'TRANSPIRATION   POTENTIAL         ROOT       ACTIVITY &
           ACTIVITY        ROOT', &
      /'       PERIOD        RATE            DEPTH     AT BOTTOM       A&
      T TOP       PRESSURE',/,19X,A4,'/',A4,9X,A4,5X,A4,'**(-2)',4X,A4,&
      '**(-2)',8X,A4,/,1X,90('-'),25(/,5X,I6,4X,5E14.5))
 4070 FORMAT(5X,47HARITHEMTIC MEAN USED FOR INTERCELL CONDUCTIVITY)
 4080 FORMAT(5X,34HNUMBER OF SOIL TEXTURAL CLASSES = ,I10/  &
      5X,43HNUMBER OF SOIL PARAMETERS FOR EACH CLASS = ,I10/  &
      5X,'NUMBER OF HEAT TRANSPORT PARAMETERS FOR EACH CLASS = ',I10/  &
      5X,'NUMBER OF SOLUTE TRANSPORT PARAMETERS FOR EACH CLASS = ' &
      ,I10/5X,47HMINIMUM PERMITTED NO. OF ITERATIONS/TIME STEP =,I10/  &
      5X,47HMAXIMUM PERMITTED NO. OF ITERATIONS/TIME STEP =,I10)
 4090 FORMAT(5X,41HTEXTURAL CLASS TO BE READ IN FOR EACH ROW)
 4100 FORMAT(41X,35HCONSTANTS FOR SOIL TEXTURAL CLASSES// &
      10X,10HANISOTROPY,7X,4HKSAT,5X,8HSPECIFIC,4X,8HPOROSITY,/,&
      36X,7HSTORAGE)
 4110 FORMAT(12X,'ALPHAL',8X,'ALPHAT',6X,'Cs',9X,'KT MIN',  &
      4X,' KT MAX ',4X,'   Cw   ')
 4111 FORMAT(12X,'ALPHAL',8X,'ALPHAT',6X,'DM')
 4120 FORMAT(1X,7HCLASS #,I2,/9X,3(1PD12.3),14(7(1PD12.3),/))
 4130 FORMAT(9X,10(1PD12.3))
 4140 FORMAT(6X,24HTEXTURAL CLASS INDEX MAP//   )
 4150 FORMAT(1H ,5X,I5,2X,100(99999I1))
 4151 FORMAT(1H ,5X,I5,2X,100(99999I2))
 4160 FORMAT(5X,24H ****** VALUE OF ITMAX =,I5,8HEXCEEDS , &
      44HDIMENSION OF DHMX, PROGRAM TERMINATED ******)
 4170 FORMAT(5X,48HINITIAL PRESSURE HEAD OR MOISTURE CONTENT WAS SE, &
      24HT TO A CONSTANT VALUE OF,1PE12.3)
 4180 FORMAT(5X,48HINITIAL PRESSURE HEAD OR MOISTURE CONTENT WAS RE, &
      12HAD FROM UNIT,I5, &
      20H A SCALING FACTOR OF,1PE12.3,9H WAS USED)
 4181 FORMAT(5X,'Simulation restarted at time ', E15.7,1x, a4, & 
       '.  Initial conditions imported from previous run.')
 4182 FORMAT('Error reading unformatted initial conditions.', &
       '  Simulation stopped.')
 4183 FORMAT(5x,'WARNING ---- Requested start time ', E15.7,1x, a4,  & 
      ' differs from actual start time ', E15.7,1x, a4,'.')
 4190 FORMAT(5X,'EQUILLIBRIUM PROFILE USED TO INITIALIZE PRESSURE',  &
       27H HEADS ABOVE WATER TABLE AT,F10.2,1X,A4,1X, &
       12HBELOW ORIGIN/5X, &
       57HEQUILLIBRIUM PROFILE ONLY USED UNTIL PRESSURE HEADS EQUAL, &
       F10.2,1X,A4/5X, &
       20HPRESSURE HEADS BELOW,F10.2,1X,A4,16H ARE HYDROSTATIC)
 4200 FORMAT(1H ,50X,18HDEPTH FROM SURFACE)
 4210 FORMAT('     INITIAL TEMPERATURE SET TO A CONSTANT VALUE OF ',  &
      1PE12.3)
 4215 FORMAT('    INITIAL CONCENTRATION SET TO A CONSTANT VALUE OF ',  &
      1PE12.3,' GRAM')     
 4220 FORMAT('     INITIAL TEMPERATURE WAS READ FROM UNIT',I5,  &
      ' A SCALING FACTOR OF, ',1PE12.3,' WAS USED')
 4225 FORMAT('     INITIAL CONCENTRATION WAS READ FROM UNIT',I5,  &
      ' A SCALING FACTOR OF, ',1PE12.3,' WAS USED')    
 4230 FORMAT('  INITIAL MOISTURE CONTENT AT ROW ',I3,' COLUMN ',  &
      I3,' IS LESS THAN OR EQUAL TO 0.',/'  PROGRAM TERMINATED')
      END
      SUBROUTINE VSTMER
!******
!VSTMER
!******
!
!     PURPOSE: TO CONTROL THE TIME SEQUENCE OF SIMULATION
!     AND TO READ NEW BOUNDARY CONDITION DATA
!
! ----------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use rspac
      use kcon
      use mprop
      use press
      use disch
      use trxx
      use plott
      use idumm
      use spfc
      use scon
      use isdumm
      use ihdumm
      use trxxh
      use solindex
      use PhreeqcRM
      use vs2dt_rm
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      COMMON/PND/POND
      COMMON/SCN1/TMPX,TMLT,DLTMX,DLTMIN,TRED
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      COMMON/JCON/JSTOP,JFLAG,jflag1
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
      F14P,F15P,F16P,F17P,F18P,F19P
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
      F14P,F15P,F16P,F17P,F18P,F19P
      CHARACTER*80 TITL
      CHARACTER*6 ZUNIT,CUNX,HUNX
      CHARACTER*7 TUNIT
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX
      LOGICAL HEAT,SOLUTE,FLOW
      COMMON /TRANSTYPE/HEAT,SOLUTE
      COMMON/TCON1/NIS,NIS1,NIS3
      COMMON/FLO/FLOW
      common/thick/dely
      COMMON/JCONF/JFLAG2
      double precision, allocatable, dimension(:,:) :: bcsol1
      double precision, allocatable, dimension(:) :: f1
      integer, allocatable, dimension(:) :: ibsol1, ibsol2
      character*256 :: myline
      integer :: myerr
      SAVE STERR
      !!@@include 'd_ihdummAlloc.inc'
      allocate(IHDUM(NXR))
      !!@@include 'd_isdummAlloc.inc'
      allocate(ISDUM(NXR))
!-------------------------------------------------------------------
!
!   ADVANCE TO NEXT TIME STEP
!
      KTIM=KTIM+1
      IF (KTIM.NE.1.AND.JSTOP.NE.0) RETURN
      JSTOP=0
      JPLT=0
      NIT=0
      NIT1=0
      NIS1=0
      IF(KTIM.EQ.1) then
       kplt = 1
       do
        if(pltim(kplt).gt.stim) EXIT
        kplt = kplt + 1
       end do
      end if
      IF(JFLAG.EQ.1) THEN
!
!................................................................
!
!    READ DATA FOR NEW RECHARGE PERIOD
! ................................................................
!
         READ (5,'(A)') myline
         READ (myline,*,IOSTAT=myerr) TPER,DELT
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  TPER,DELT'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  TPER,DELT'
         endif
!
!   CHECK FOR END OF SIMULATION
!
      jflag1 = 1
      jflag2 = 1
      IF(TPER.LT.0) THEN
      WRITE (06,4070) TMAX,STIM
      jstop=5
      return
      END IF
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) TMLT,DLTMX,DLTMIN,TRED
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  TMLT,DLTMX,DLTMIN,TRED'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  TMLT,DLTMX,DLTMIN,TRED'
      endif
      KP=KP+1
      SSTATE=.FALSE.
      if(delt.lt.dltmin) then
       delt = dltmin
      else
       if(delt.gt.dltmx) delt = dltmx
      end if
      WRITE (06,4000) KP,TPER,TUNIT,DELT,TUNIT,TMLT,DLTMX,TUNIT,DLTMIN, &
      TUNIT,TRED
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) DSMAX,STERR
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  DSMAX,STERR'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  DSMAX,STERR'
      endif
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) POND
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  POND'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  POND'
      endif
      WRITE (06,4020) DSMAX,STERR,POND
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) PRNT
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  PRNT'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  PRNT'
      endif
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) BCIT,ETSIM,SEEP
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  BCIT,ETSIM,SEEP'
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  BCIT,ETSIM,SEEP'
      endif
      WRITE (06,4010) PRNT,BCIT,ETSIM,SEEP
      DSMAX=DABS(DSMAX)
      ETOUT=0.0D0
      ETOUT1=0.0D0
!
!    READ SEEPAGE FACE DATA
!
      IF(SEEP) THEN
         READ (5,'(A)') myline
         READ (myline,*,IOSTAT=myerr) NFCS
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  NFCS'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  NFCS'
         endif
      !!@@include 'd_spfcAlloc.inc'
      if (allocated(JSPX)) deallocate(JSPX)
      if (allocated(NFC)) deallocate(NFC)
      if (allocated(JLAST)) deallocate(JLAST)
      allocate(JSPX(3,NXR+NLY,NFCS))
      allocate(NFC(NFCS))
      allocate(JLAST(NFCS))
      DO 50 K=1,NFCS 
         READ (5,'(A)') myline
         READ (myline,*,IOSTAT=myerr) JJ,JLAST(K) 
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  JJ,JLAST(K) '
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  JJ,JLAST(K) '
         endif
      NFC(K)=JJ 
      READ (5,*,IOSTAT=myerr) ((JSPX(L,J,K),L=2,3),J=1,JJ)
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  ((JSPX(L,J,K),L=2,3),J=1,JJ)'
         flush(6)
         stop 'Error reading:  ((JSPX(L,J,K),L=2,3),J=1,JJ)'
      endif
!      DO 40 M=1,Nsol
      DO 40 J=1,JJ 
      J1=JSPX(2,J,K) 
      N1=JSPX(3,J,K) 
      N2=NLY*(N1-1)+J1 
      JSPX(1,J,K)=N2 
      Q(N2)=0.0D0 
      QQ(N2)=0.0D0
      IF(HEAT)THEN
         NHTYP(N2)=0
         TS(N2)=0.0D0
      END IF   
      IF(SOLUTE)THEN
        NCTYP(N2)=0
        Do 41 M = 1, Nsol
  41    CSS(M,N2)=0.0D0
      END IF 
       IF(J.GT.JLAST(K)) THEN 
       NTYP(N2)=3 
       ELSE 
       NTYP(N2)=1  
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J1)
      ELSE
      Z1=DZZ(J1)*CS1+RX(N1)*CS2
      END IF
       P(N2)=-Z1 
       END IF
   40 CONTINUE 
   50 CONTINUE 
      END IF
!
!   READ IN NEW BOUNDARY CONDITIONS FOR RECHARGE PERIOD
!    IF IBC=0, POINT BOUNDARY CONDITIONS ARE READ IN.
!    IF IBC=1, LINE BOUNDARY CONDITIONS ARE READ IN, AND IT IS NECESSARY
!     TO SPECIFY FOUR POINTS ON THE LINE--THIS ALLOWS VERTICAL OR HORI-
!     ZONTAL LINES TO BE READ IN INDISCRIMINATELY.  THE SEQUENCE IS:
!     TOP ROW, BOTTOM ROW, LEFT COLUMN, RIGHT COLUMN, CODE, AND FLUX OR
!     PRESSURE HEAD FOR BOUNDARY CONDITION.
!
      READ (5,'(A)') myline
      READ (myline,*,IOSTAT=myerr) IBC 
      if (myerr .ne. 0) then
         write(6,'(A)') 'Error reading:  IBC '
         write(6,'(A,A)') 'Last line: ', myline
         flush(6)
         stop 'Error reading:  IBC '
      endif
      IF(IBC.GT.0) GO TO 80 
   70 IF (TRANS)THEN
         READ (5,'(A)') myline
         READ (myline,*,IOSTAT=myerr) JJ,NN,NTX,PFDUM
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  JJ,NN,NTX,PFDUM'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  JJ,NN,NTX,PFDUM'
         endif
      IF(JJ.LT.0) GO TO 130 
      IF(HEAT) THEN
         READ (5,'(A)') myline
         READ (myline,*,IOSTAT=myerr)NTT,TF
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading: NTT,TF'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading: NTT,TF'
         endif
      ELSE
      NTT=0
      TF=0
      END IF
      IF(solute)  then
         READ (5,'(A)') myline
         READ (myline,*,IOSTAT=myerr)NTC,INSBC1,INSBC2,SBFRAC
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading: NTC,INSBC1,INSBC2,SBFRAC'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading: NTC,INSBC1,INSBC2,SBFRAC'
         endif
      
      !#CALL SETUP_BOUNDARY_CONDITIONS(INSBC1,INSBC2,SBFRAC,BCSOL)
      allocate(bcsol1(1,nSol), ibsol1(1), ibsol2(1), f1(1))
      ibsol1(1) = insbc1
      ibsol2(1) = insbc2
      f1(1) = sbfrac
      status = RM_InitialPhreeqc2Concentrations(rm_id, bcsol1, 1, ibsol1, ibsol2, f1)
      do i = 1, nsol
          bcsol(i) = bcsol1(1,i)
      enddo
      deallocate(bcsol1, ibsol1, ibsol2, f1)
      
      ELSE
      NTC=0
      END IF
      ELSE
         READ (5,'(A)') myline
         READ (myline,*,IOSTAT=myerr) JJ,NN,NTX,PFDUM
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  JJ,NN,NTX,PFDUM'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  JJ,NN,NTX,PFDUM'
         endif
      END IF
      IF(JJ.LT.0) GO TO 130 
      JJT=JJ 
      JJB=JJ 
      NNL=NN 
      NNR=NN 
      GO TO 90 
  80  IF(TRANS)THEN
         READ (5,'(A)') myline
         READ(myline,*,IOSTAT=myerr) JJT,JJB,NNL,NNR,NTX,PFDUM
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  JJT,JJB,NNL,NNR,NTX,PFDUM'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  JJT,JJB,NNL,NNR,NTX,PFDUM'
         endif
      IF(JJT.LT.0) GO TO 130
      IF(HEAT) THEN
         READ (5,'(A)') myline
         READ (myline,*,IOSTAT=myerr)NTT,TF
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading: NTT,TF'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading: NTT,TF'
         endif
      ELSE
      NTT=0
      TF=0.0d0
      END IF
      IF (SOLUTE)THEN
         READ (5,'(A)') myline
         READ (myline,*,IOSTAT=myerr)NTC,INSBC1,INSBC2,SBFRAC 
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading: NTC,INSBC1,INSBC2,SBFRAC '
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading: NTC,INSBC1,INSBC2,SBFRAC '
         endif

      !#CALL SETUP_BOUNDARY_CONDITIONS(INSBC1,INSBC2,SBFRAC,BCSOL)
      allocate(bcsol1(1,nSol), ibsol1(1), ibsol2(1), f1(1))
      ibsol1(1) = insbc1
      ibsol2(1) = insbc2
      f1(1) = sbfrac
      status = RM_InitialPhreeqc2Concentrations(rm_id, bcsol1, 1, ibsol1, ibsol2, f1)
      do i = 1, nsol
          bcsol(i) = bcsol1(1,i)
      enddo
      deallocate(bcsol1, ibsol1, ibsol2, f1)
      
      ELSE
      NTC=0
      END IF
      ELSE
         READ (5,'(A)') myline
         READ(myline,*,IOSTAT=myerr) JJT,JJB,NNL,NNR,NTX,PFDUM
         if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading:  JJT,JJB,NNL,NNR,NTX,PFDUM'
            write(6,'(A,A)') 'Last line: ', myline
            flush(6)
            stop 'Error reading:  JJT,JJB,NNL,NNR,NTX,PFDUM'
         endif
      IF(JJT.LT.0) GO TO 130
      END IF 
!
  90  CONTINUE 
      IF (SOLUTE)THEN
      DO 92 JJ=JJT,JJB 
      DO 92 NN=NNL,NNR 
      DO 91 M=1,Nsol
      IN=NLY*(NN-1)+JJ
      CSS(M,IN)=BCSOL(M)
!
!  change made 99-12-16 so that ntc = 2 conductive heat flux is
!   in terms of energy per time per length of boundary (i.e.,
!   a line source) , as 
!   opposed to energy per time (which is for point source)
!     
!      DO 450 I=1, Nsol
!      BCSOL(I)=I
! 450  CONTINUE   
      if (ntc.eq.2) then
      area = dxr(nn)
      if(rad) area = pi2*rx(nn)*dxr(nn)
      CSS(M,IN) = BCSOL(M)*area
      end if
      IF(NTC.EQ.1) CC(M,IN)=BCSOL(M)
      NCTYP(IN)=NTC
  91  CONTINUE
  92  CONTINUE
      END IF
      DO 120 JJ=JJT,JJB 
      DO 120 NN=NNL,NNR 
      IN=NLY*(NN-1)+JJ 
      IF(HEAT) then
      TS(IN)=TF
      if (NTT.eq.2) then
      area = dxr(nn)
      if(rad) area = pi2*rx(nn)*dxr(nn)
      TS(IN) = Tf*area
      end if
      IF(NTT.EQ.1) TT(IN)=TF
      NHTYP(IN)=NTT
      END IF
!      if(ntx.eq.5.and.hx(in-1).gt.0.0d0) go to 80
      IF(NTX.NE.6) GO TO 100 
      NTYP(IN)=2 
      QQ(IN)=PFDUM 
      GO TO 120 
  100 NTYP(IN)= NTX 
      IF(NTX.EQ.4)NTYP(IN)=1 
      IF(NTX.EQ.0) WRITE (06,4030) JJ,NN 
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(JJ)
      ELSE
      Z1=DZZ(JJ)*CS1+RX(NN)*CS2
      END IF
      IF(NTX.EQ.1) P(IN)=PFDUM-Z1 
      IF(NTX.EQ.4) P(IN)=PFDUM 
      IF(NTX.EQ.2) GO TO 110 
      QQ(IN)=0.0d0 
!
!  modifications for gravity drainage BC
!
      if (ntx.eq.7) then
       if(hx(in+1).gt.0.d0.or.hx(in-1).le.0.d0) then
        WRITE(6,4012)  JJ,NN
        ntyp(in)=0
       else
!        nctyp(in) = 7
        ntyp(in) = 7
       end if
      end if
!
!  end modifications
! 
       GO TO 120 
  110 CONTINUE 
!  SET QQ TO RAINFALL RATE 
      AREA=DXR(NN) 
      IF(RAD)AREA=PI2*RX(NN)*DXR(NN) 
      QQ(IN)=PFDUM*AREA 
  120 CONTINUE 
      IF(IBC.EQ.0) GO TO 70 
      GO TO 80 
  130 CONTINUE
!      if (SOLUTE)then
!      do  I=1, Nsol
!      WRITE (6,*)'BCSOL(',I,')=',BCSOL(I)
!      END DO
!      END IF
      write(6,*)"temerature setting at the boundary"
!      CALL VSOUT(1,TT)
!      CALL VSOUTS(1,CC)
!
!     WRITE INITIAL BOUNDARY CONDITIONS FOR THIS PERIOD
!
      GRAV = .FALSE.
      WRITE (06,4040) KP
      DO 111 J=1,NLY
      DO 109 N=1,NXR
      IN=NLY*(N-1)+J
      Q(IN)=0.0D0
      if(ntyp(in).eq.7) GRAV = .TRUE.
 109  IDUM(N)=NTYP(IN)
  111 WRITE (06,4050) J,(IDUM(I),I=1,NXR)
      IF(HEAT) THEN
      DO 151 J=1,NLY 
      DO 141 N=1,NXR 
      IN=NLY*(N-1)+J 
      Q(IN)=0.0D0 
  141 IHDUM(N)= NHTYP(IN)
!      WRITE (06,4081) J,(IHDUM(I),I=1,NXR)
 151  continue
      END IF
      IF(SOLUTE)THEN
       DO 152 J=1,NLY 
       DO 142 N=1,NXR 
       IN=NLY*(N-1)+J 
       Q(IN)=0.0D0 
  142 ISDUM(N)= NCTYP(IN)
!   WRITE (06,4081) J,(ISDUM(I),I=1,NXR)
  152 continue
      END IF
      TMPX=STIM+TPER
      IF(TMPX+0.5D0*DLTMIN.GT.TMAX) TMPX=TMAX
!
!   CALCULATE NEW COEFFICIENTS
!
      IF(KTIM.NE.1)CALL VSCOEF
      END IF
!
!   INITIALIZE REQUIRED ARRAYS FOR NEW BOUNDARY CONDITION, UPDATE
!   PXXX,THLST.  COMPUTE MAXIMUM HEAD CHANGE DURING LAST TIME STEP
!
      PDIF=0.0D0
      IF(.NOT.SSTATE) THEN
      DO 121 J=2,NLYY
      DO 121 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).EQ.0.0D0) GO TO 121
      P12=P(IN)-PXXX(IN)
      PTMP=DABS(P12)
      IF(PTMP.GT.PDIF)PDIF=PTMP
      PXXX(IN)=P(IN)
      THLST(IN)=THETA(IN)
      IF(HEAT)TTOLD(IN)=TT(IN)
      IF(SOLUTE)THEN
      DO 119 M=1,Nsol   
      CCOLD(M,IN)=CC(M,IN) 
  119 CONTINUE
      END IF
  121 CONTINUE
!
!    CHECK FOR STEADY STATE
!
      IF(jflag.ne.1.and.PDIF.LE.STERR) THEN
      SSTATE=.TRUE.
      WRITE(6,4060) STIM,KTIM
      END IF
      END IF
      JFLAG=0
!
!   INITIALIZE DHMX
!
      DO 131 K=1,itmax
  131 DHMX(K)=0.0D0
!
!    ADVANCE DELT AND RESET TO PROPER LENGTH IF NECESSARY
!
      if (delt.lt.dltmin) delt = dltmin
      DLTOLD=DELT
      DELT= TMLT*DELT
!
!    MAXIMUM PERMISSABLE HEAD CHANGE CHECK
!
      IF(KTIM.GE.2) THEN
      IF((PDIF*DELT/DLTOLD).GT.DSMAX)DELT=DLTOLD*DSMAX*0.98D0/PDIF
      END IF
      T1=DMIN1(TMPX,PLTIM(KPLT))
      T2=T1-STIM
!
!  changes made 6-12-02 for calculating delt.  This new
!  version will allow delt<dltmin only to match obs times
!  or end of recharge period.
!  THESE NEED TO BE CHECKED CAREFULLY
!
!      IF(DELT.GT.(T2-DLTMIN)) DELT=T2
!      IF(DELT.LT.DLTMIN)DELT=DLTMIN
      if(delt.gt.t2) then
       delt = t2
      else
       if(delt.lt.dltmin) delt = dltmin
      end if
!      IF(DELT.GT.DLTMX)DELT=DLTMX
       if(delt-dltmx.ge.0.000001D0*dltmin) delt = dltmx
!      IF(T1.NE.PLTIM(KPLT).OR.T2-DELT.GT.0.5D0*DLTMIN) GO TO 140
      IF(T1.NE.PLTIM(KPLT).or.t2-delt.gt.0.d0) GO TO 140
      KPLT=KPLT+1
      JPLT=1
!  140 IF(DELT.LT.DLTMIN)DELT=DLTMIN
 140  continue
      STIM=STIM+DELT
!      IF (TMPX-STIM.LT.0.5D0*DLTMIN) JFLAG=1
!      IF(TMAX-STIM.LT.0.5D0*DLTMIN) THEN
!      IF (TMPX-STIM.LT.0.000001D0*DLTMIN) JFLAG=1
      IF (TMPX-STIM.LT.0.000001D0*DLTMIN) then
       JFLAG=1
       JPLT=1
       delt = delt + (tmpx - stim)
       stim = tmpx
       do
        if (stim.lt.pltim(kplt)) exit
        kplt = kplt + 1
       end do
      end if
      IF(TMAX-STIM.LT.0.000001*DLTMIN) THEN
!
!  end changes of 6-12-02
!
      JSTOP=1
      JPLT=1
      ELSE
      IF(KTIM.GT.NUMT) THEN
      JSTOP=8
      JPLT=1
      PRINT*,'Maximum number of time steps exceeded' &
            , ' Simulation terminated'
      WRITE(6,4080)
      END IF
      END IF
      !!@@include 'd_ihdummDealloc.inc'
      deallocate(IHDUM)
      !!@@include 'd_isdummDealloc.inc'
      deallocate(ISDUM)
      RETURN
 4000 FORMAT(6X,'DATA FOR RECHARGE PERIOD ',I9//10X, &
      23HLENGTH OF THIS PERIOD =,1PE14.5,1X,A4,/10X, &
      45HLENGTH OF INITIAL TIME STEP FOR THIS PERIOD =,1PE14.5,1X,A4/ &
      10X,27HMULTIPLIER FOR TIME STEP = ,1PE10.3,/10X, &
      25HMAXIMUM TIME STEP SIZE = ,1PE14.5,1X,A4/10X, &
      25HMINIMUM TIME STEP SIZE = ,1PE14.5,1X,A4, &
      /10X,'TIME STEP REDUCTION FACTOR = ',1PE10.3)
 4010 FORMAT(15X,37HPRINT SOLUTION AFTER EVERY TIME STEP?,1X,L1/ &
      15X,'SIMULATE EVAPORATION? ',L1/ &
      15X,29HSIMULATE EVAPOTRANSPIRATION? ,L1/ &
      15X,24HSIMULATE SEEPAGE FACES? ,L1/)
 4012 format(16x,'WARNING -- GRAVITY BOUNDARY NODE MUST LIE ABOVE ',  &
      'AN INACTIVE NODE.'/16X,'AND BELOW AN ACTIVE NODE.'/16X, &
      'GRAVITY BOUNDARY NOT APPLIED FOR CELL: ' &
      ,2I6/)
 4020 FORMAT( &
      15X,55HMAXIMUM PRESSURE HEAD CHANGE ALLOWED IN ONE TIME STEP =, &
      F8.3/15X,'STEADY-STATE CLOSURE CRITERION = ',1PE10.3/ &
      15X,'MAXIMUM DEPTH OF PONDING = ',1PE10.3)
 4030 FORMAT(1X,'******** WARNING --- NODE TYPE OF 0 ASSIGNED TO BO',  &
      'UNDARY NODE ',2I5)
 4040 FORMAT(6X,41HNODE TYPE AND INITIAL BOUNDARY CONDITIONS, &
      12H FOR PERIOD ,I9/6X,8HLEGEND: /15X,17H0 = INTERIOR CELL/ &
      15X,32H1 = SPECIFIED PRESSURE HEAD CELL/15X, &
      23H2 = SPECIFIED FLUX CELL/ &
       15X,31H3 = POTENTIAL SEEPAGE FACE NODE/ &
       15X,43H5 = NODE FOR WHICH EVAPORATION IS PERMITTED/ &
       15x,'7 = GRAVITY DRAIN CELL'/) 
 4050 FORMAT(1H ,I5,5X,100(99999I1))
 4060 FORMAT(6X,100(1H*)/5X, &
      'STEADY STATE REACHED AT TIME = ',E14.6,'   TIME STEP NUMBER = ' &
      ,I9//)
 4070 FORMAT(6X,100(1H*),/,5X,17HEND OF SIMULATION/,  &
      5X,33HMAXIMUM SIMULATION TIME (TMAX) = ,E15.6/, &
      5X,33HELAPSED SIMULATION TIME (STIM) = ,E15.6/, &
      6X,100(1H*))
 4080 FORMAT(' Maximum number of time steps exceeded'/ &
      ' Simulation terminated')
 4081 FORMAT(1H ,I5,5X,80I1)      
      END
     SUBROUTINE VSMGEN
!******
!VSMGEN
!******
!
!    PURPOSE:  TO SET UP COEFFICIENT MATRICES AND CALL
!          SOLUTION ALGORITHM
!
!-----------------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use rspac
      use kcon
      use mprop
      use press
      use disch
      use hcon
      use equat
      use jtxx
      use ptet
      use pit
      use plott
      use rpropsh
      use scon
      use equats
      use temp
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      COMMON/WGT/WUS,WDS
      COMMON/SCN1/TMPX,TMLT,DLTMX,DLTMIN,TRED
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      COMMON/JCON/JSTOP,JFLAG,jflag1
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      CHARACTER*80 TITL
      CHARACTER*6 ZUNIT,CUNX,HUNX
      CHARACTER*7 TUNIT
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX
      LOGICAL HEAT,SOLUTE,FLOW
      COMMON/TRANSTYPE/HEAT,SOLUTE
      integer hydraulicFunctionType
      common/functiontype/ hydraulicFunctionType
      COMMON/TCON1/NIS,NIS1,NIS3
      COMMON/FLO/FLOW
      COMMON/SCON1/ITESTS
!
! ......................................................................
!  START OF LINEARIZATION ITERATION LOOP
! .....................................................................
!
!    UPDATE COEFFICIENTS
!
      I13=0
!
!     ESTABLISH TIME-DEPENDENT PARAMETERS GOVERNING EVAPORATION AND
!     TRANSPIRATION.  DETERMINE ROOT ACTIVITY.
!
   10 IF ( BCIT.OR. ETSIM) THEN
      CALL VSPET
      DO 20 J=2,NLYY
      DO 20 I=2,NXRR
      N=NLY*(I-1)+J
      IF(HX(N).GT.0.0D0) THEN
      IF(ETSIM) RT(N)=VSRDF(DPTH(N),DELZ(J))
      Q(N)=0.0D0
      END IF
   20 CONTINUE
      END IF
   30 IF (NIT.NE.0) CALL VSCOEF
!
! --------------------  UPDATE BOUNDARY AND FLUX CONDITIONS ------------
!
      IF(BCIT)CALL VSEVAP
      IF (ETSIM)CALL VSPLNT
      IF(SEEP) CALL VSSFAC
      if(GRAV.and.nit.eq.0) CALL vsgrav_dr
!
! .....................................................................
!
!         LOOP TO CALCULATE COEFFICIENT MATRIX
! .....................................................................
!
      DO 40 J=2,NLYY
      DO 40 I=2,NXRR
      N=NLY*(I-1)+J
      IF(HX(N).GT.0.0D0) THEN
      JM1=N-1
      JP1=N+1
      IM1=N-NLY
      IP1=N+NLY
      VOL=DXR(I)*DELZ(J)
      IF(RAD)VOL=PI2*RX(I)*DXR(I)*DELZ(J)
      JJ=JTEX(N)
!
!   CALCULATE STORAGE TERMS
!
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(I)*CS2
      END IF
      PTMP=P(N)+Z1
      if(hydraulicFunctionType.eq.1) then
       SCAP=VSDTHUVG(PTMP,JJ)
      else
       if(hydraulicFunctionType.eq.2) then
        SCAP=VSDTHUHK(PTMP,JJ)
       else
        if(hydraulicFunctionType.eq.0) then
         SCAP=VSDTHUBC(PTMP,JJ)
        else
         if(hydraulicFunctionType.eq.3) then
          SCAP=VSDTHUTAB(PTMP,JJ)
         else
          SCAP=VSDTHUOT(PTMP,JJ)
         end if
        end if
       end if
      end if
      if(HEAT)THEN
      GSF=VOL*SCAP*RHO(N)
      else
      GSF=VOL*SCAP
      END IF 
      if (HK(JJ,3).ne. 0.0D0) then
       SS=HK(JJ,2)/HK(JJ,3)
      else
       SS=0.0D0
      end if
      IF (HEAT) THEN
      GSS=VOL*THETA(N)*SS*RHO(N)
      ELSE
      GSS=VOL*THETA(N)*SS
      END IF
      G1=0.0D0
!
!   APPLY NEWTON-RAPHSON LINEARIZATION TO STORAGE TERM.
!   PITT HOLDS STORAGE TERMS FROM PREVIOUS ITERATION.
!
      IF(NIT.GT.0.AND.XI(N).NE.0.0D0) G1=(P(N)-PXXX(N))*&
                                        (GSF+GSS-PITT(N))/XI(N)
      PITT(N)=GSF+GSS
      G1=-G1/DELT
      GSF=-GSF/DELT
      GSS=-GSS/DELT
      IF(WUS.EQ.0.0D0) THEN
!
!   USE GEOMETRIC MEAN OR WEIGHTS FOR INTERCELL K
!     
      IF(HEAT)THEN
      A(N)=HKLL(N)*DSQRT(HCND(IM1)*RHO(IM1)*HCND(N)*RHO(N))
      B(N)=HKTT(N)*DSQRT(HCND(JM1)*RHO(JM1)*HCND(N)*RHO(N))
      C(N)=HKLL(IP1)*DSQRT(HCND(IP1)*RHO(IP1)*HCND(N)*RHO(N))
      D(N)=HKTT(JP1)*DSQRT(HCND(JP1)*RHO(JP1)*HCND(N)*RHO(N))
      ELSE
      A(N)=HKLL(N)*DSQRT(HCND(IM1)*HCND(N))
      B(N)=HKTT(N)*DSQRT(HCND(JM1)*HCND(N))
      C(N)=HKLL(IP1)*DSQRT(HCND(IP1)*HCND(N))
      D(N)=HKTT(JP1)*DSQRT(HCND(JP1)*HCND(N))
      END IF
      ELSE
!
!  CHOOSE UPSTREAM WEIGHTING COEFFICIENTS
!
      IF(P(IM1).LE.P(N).OR.HX(IM1).EQ.0.0D0) THEN
      ALA=WDS
      BTA=WUS
      ELSE
      ALA=WUS
      BTA=WDS
      END IF
      IF(P(JM1).LE.P(N).OR.HX(JM1).EQ.0.0D0) THEN
      ALB=WDS
      BTB=WUS
      ELSE
      ALB=WUS
      BTB=WDS
      END IF
      IF(P(IP1).LE.P(N).OR.HX(IP1).EQ.0.0D0) THEN
      ALC=WDS
      BTC=WUS
      ELSE
      ALC=WUS
      BTC=WDS
      END IF
      IF(P(JP1).LE.P(N).OR.HX(JP1).EQ.0.0D0) THEN
      ALD=WDS
      BTD=WUS
      ELSE
      ALD=WUS
      BTD=WDS
      END IF
!
!   SET THE PENTA-DIAGNOL COEFFICIENT MATRIX (E IS MAIN DIAGNOL)
!   AND RIGHT HAND SIDE
!
      IF(HEAT)THEN
      A(N)=(ALA*HCND(IM1)*RHO(IM1)+BTA*HCND(N)*RHO(N))*HKLL(N)
      B(N)=(ALB*HCND(JM1)*RHO(JM1)+BTB*HCND(N)*RHO(N))*HKTT(N)
      C(N)=(ALC*HCND(IP1)*RHO(IP1)+BTC*HCND(N)*RHO(N))*HKLL(IP1)
      D(N)=(ALD*HCND(JP1)*RHO(JP1)+BTD*HCND(N)*RHO(N))*HKTT(JP1)
      ELSE
      A(N)=(ALA*HCND(IM1)+BTA*HCND(N))*HKLL(N)
      B(N)=(ALB*HCND(JM1)+BTB*HCND(N))*HKTT(N)
      C(N)=(ALC*HCND(IP1)+BTC*HCND(N))*HKLL(IP1)
      D(N)=(ALD*HCND(JP1)+BTD*HCND(N))*HKTT(JP1)
      END IF
      END IF
      if(ntyp(n).eq.1) then
       if(ntyp(im1).eq.1) a(n) = 0.0d0
       if(ntyp(jm1).eq.1) b(n) = 0.0d0
       if(ntyp(ip1).eq.1) c(n) = 0.0d0
       if(ntyp(jp1).eq.1) d(n) = 0.0d0
      end if
      E(N)=-A(N)-B(N)-C(N)-D(N)
      IF(HEAT)THEN
      RHS(N)=VOL*(THETA(N)*RHO(N)-THLST(N)*RHOOLD(N))/DELT-&
      (Q(N)+QQ(N))*RHO(N)-(A(N)*P(IM1)+B(N)*P(JM1)+ &
      C(N)*P(IP1)+D(N)*P(JP1)+(E(N)+GSS)*P(N))+GSS*PXXX(N) 
      ELSE    
      RHS(N)=VOL*(THETA(N)-THLST(N))/DELT-(Q(N)+QQ(N))-(A(N)*P(IM1)+B(N)&
      *P(JM1)+C(N)*P(IP1)+D(N)*P(JP1)+(E(N)+GSS)*P(N))+GSS*PXXX(N)
      END IF
      E(N)=E(N)+GSF+GSS+G1
      END IF
   40 CONTINUE
!
!    CALL SOLUTION ALGORITHM
!
      NIT=NIT+1
      CALL SLVSIP
      IF(NIT.LT.MINIT) GO TO 30
!
!   IF SOLUTION HAS BEEN FOUND THEN RETURN
!
      IF(ITEST.EQ.0) RETURN
      IF(NIT.LE.ITMAX) GO TO 30
!
!   MAXIMUM NUMBER OF ITERATIONS EXCEEDED
!   
      PRINT*,'ERROR: EXCEEDED PERMITTED NUMBER OF ITERATIONS'
      WRITE (6,4000) NIT,KTIM,STIM,TUNIT
!
!   AUTOMATICALLY REDUCE TIME STEP SIZE, BUT NOT MORE
!   THAN TWICE.
!
      IF(DELT.LE.DLTMIN.OR.I13.GT.2.OR.TRED.LE.0.0D0) THEN
      IF(.NOT.ITSTOP)RETURN
!
!   TERMINATE SIMULATION.
!
      JSTOP=9
      JFLAG=1
      WRITE(6,4020)
      RETURN
      ELSE
      I13=I13+1
      DELTT=DELT*TRED
      IF(DELTT.LT.DLTMIN) DELTT=DLTMIN
      if(delt-deltt.ge.dltmin) then
       jflag = 0
       if(jstop.eq.1) then
        jstop = 0
        jplt = 0
       else
        if(jplt.eq.1) then
         jplt = 0
         if(stim.eq.pltim(kplt)) kplt = kplt - 1
        end if
       end if
      end if
      WRITE(6,4010) DELTT
      STIM=STIM-DELT+DELTT
      DELT=DELTT
!
!   RESET HEADS TO VALUES AT END OF PREVIOUS TIME STEP.
!
      DO 50 II=1,NNODES
      IF(NTYP(II).NE.1.AND.HX(II).GT.0.0D0) P(II)=PXXX(II)
   50 CONTINUE
      NIT=1
      GO TO 10
      END IF
 4000 FORMAT(5X,100(1H*)/5X,'EXCEEDED PERMITTED NUMBER OF ITERATIONS', &
      '  ( =',I9,')' &
       /5X,'TIME STEP NUMBER',I9/5X,'ELAPSED TIME = ', &
       1PE14.5,1X,A4  /5X,100(1H*))
 4010 FORMAT(5X,'TIME STEP SIZE REDUCED TO ',E14.6)
 4020 FORMAT('Simulation terminated')
      END
      SUBROUTINE VSSIP
!
!*****
!VSSIP
!*****
!
!     PURPOSE: TO SOLVE THE  MATRIX EQUATIONS USING THE
!     STRONGLY IMPLICIT METHOD
!
! ----------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use rspac
      use kcon
      use press
      use equat
      use jtxx
      use trxxh
      use sip
      use rpropsh
      use scon
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      LOGICAL HEAT,SOLUTE,FLOW
      COMMON/TRANSTYPE/HEAT,SOLUTE
      DIMENSION IORDER(21)
      DIMENSION TEMP(100),HM(30)
      SAVE HM,W1,W9,L2,NTH
      DATA W1/0.0D0/
!
!-------------------------------------------------------------------
!
      DATA IORDER/1,2,3,4,5,1,2,3,4,5,11*1/
!
!     COMPUTE ITERATION PARAMETERS
!
      J2=NXR-2
      I2=NLY-2
      L2=5
      PL2=L2-1
      W=0.0D0
      PIE=0.0D0
      W9=100.0D0
!
! COMPUTE MAXIMUM PARAMETER
!
      DO 10 I=2,NLYY
      DO 10 J=2,NXRR
      N=NLY*(J-1)+I
      IF(HX(N).GT.0.0D0) THEN
      IM1=JTEX(N)
      PIE=PIE+1.0D0
      DX=DXR(J)/RX(NXR)
      DY=DELZ(I)/DZZ(NLY)
      DX3=DX*DX
      DY2=DY*DY
      W=W+1.0D0-DMIN1((DX3+DX3)/(1.0D0+ANIZ(IM1)*DX3/DY2),(DY2+DY2)/&
      (1.0D0+DY2/(ANIZ(IM1)*DX3)))
      END IF
   10 CONTINUE
      W=W/PIE
!
! COMPUTE PARAMETERS IN GEOMETRIC SEQUENCE
!
      PJ=-1.0D0
      DO 20 I=1,L2
      PJ=PJ+1.0D0
   20 TEMP(I)=1.0D0 -(1.0D0 -W)**(PJ/PL2)
!
! ORDER SEQUENCE OF PARAMETERS
!
      DO 30 J=1,L2
   30 HM(J)=TEMP(IORDER(J))
!      WRITE (06,4000) L2,(HM(J),J=1,L2)
      RETURN
!
! STRONGLY IMPLICIT ALGORITHM
!
      ENTRY SLVSIP
      I2=NLY-2
      J2=NXR-2
!      SELECT ITERATION PARAMETER.  INITIALIZE ARRAYS
!
      IF(TRANS1) THEN
!
!  IF TRANS1=T  TRANSPORT EQUATION IS SOLVED
!           =F  FLOW EQUATION IS SOLVED
!
      NT=NIT1
      ELSE
      NT=NIT
      END IF
      IF(MOD(NT,L2).EQ.0.OR.NT.EQ.1)NTH=0
      NTH=NTH+1
      W=HM(NTH)
      ITEST=0
      DO 40 I=1,NNODES
      DEL(I)=0.0D0
      ETA(I)=0.0D0
      V(I)=0.0D0
   40 XI(I)=0.0D0
      BIGI=0.0D0
      BIGI1=0.0D0
!
! CHOOSE SIP NORMAL OR REVERSE ALGORITHM
!
      IF(MOD(NT,2)) 50,80,50
! ......................................................................
! ORDER EQUATIONS WITH ROW 1 FIRST  -  3X3 EXAMPLE:
!    1 2 3
!    4 5 6
!    7 8 9
! ......................................................................
   50 DO 60 I=2,NLYY
      DO 60 J=2,NXRR
      N=I+NLY*(J-1)
!
!   ---- SKIP COMPUTATIONS OF NODE IS OUTSIDE OF SOLUTION DOMAIN
!
      IF(HX(N).EQ.0.0D0) GO TO 60
      IF((NTYP(N).EQ.1.AND.(.NOT.TRANS1)).OR.(TRANS1.AND.(NHTYP(N).EQ.1)))GO TO 60
      NL=N-NLY
      NA=N-1
      NB=N+1
!
!     --- SIP "NORMAL" ALGORITHM-----
!     --- FORWARD SUBSTITUTE, COMPUTING INTERMEDIATE VECTOR V --
!
      CH=DEL(NA)*B(N)/(1.0D0 +W*DEL(NA))
      GH=ETA(NL)*A(N)/(1.0D0 +W*ETA(NL))
      BH=B(N)-W*CH
      DH=A(N)-W*GH
      EH=E(N)+W*CH+W*GH
      FH=C(N)-W*CH
      HH=D(N)-W*GH
      ALFA=BH
      BETA=DH
      GAMA=EH-ALFA*ETA(NA)-BETA*DEL(NL)
      DEL(N)=FH/GAMA
      ETA(N)=HH/GAMA
      RES=RHS(N)
      V(N)=(HMAX*RES-ALFA*V(NA)-BETA*V(NL))/GAMA
   60 CONTINUE
!
!  ---BACK SUBSTITUTE FOR VECTOR XI
!
      DO 70 I=1,I2
      I3=NLY-I
      DO 70 J=1,J2
      J3=NXR-J
      N=I3+NLY*(J3-1)
      IF(HX(N).EQ.0.0D0) GO TO 70
      IF((NTYP(N).EQ.1.AND.(.NOT.TRANS1)).OR.(TRANS1.AND.(NHTYP(N).EQ.1)))GO TO 70
      XI(N)=V(N)-DEL(N)*XI(N+NLY)-ETA(N)*XI(N+1)
!
!      FIND MAXIMUM HEAD CHANGE
!
      TCHK=DABS(XI(N))
      IF(TCHK.GE.BIGI) THEN
      BIGI=TCHK
      BIGI1=XI(N)
      END IF
   70 CONTINUE
      GO TO 110
!
!.......................................................................
!  ---ORDER EQUATIONS WITH THE LAST ROW FIRST  -  3X3 EXAMPLE
!           7 8 9
!           4 5 6
!           1 2 3
!......................................................................
!
   80 DO 90 II=1,I2
      I=NLY-II
      DO 90 J=2,NXRR
      N=I+NLY*(J-1)
      NL=N-NLY
      NA=N-1
      NB=N+1
!
!  -- SKIP COMPUTATIONS IF NODE IS OUTSIDE OF SOLUTION DOMAIN
!
      IF(HX(N).EQ.0.0D0) GO TO 90
      IF((NTYP(N).EQ.1.AND.(.NOT.TRANS1)).OR.(TRANS1.AND.(NHTYP(N).EQ.1)))GO TO 90
!
!------ SIP "REVERSE" ALGORITHM
! --- FORWARD SUBSTITUTE, COMPUTING INTERMEDIATE VECTOR V
!
      CH=DEL(NB)*D(N)/(1.0D0 +W*DEL(NB))
      GH=ETA(NL)*A(N)/(1.0D0 +W*ETA(NL))
      BH=D(N)-W*CH
      DH=A(N)-W*GH
      EH=E(N)+W*CH+W*GH
      FH=C(N)-W*CH
      HH=B(N)-W*GH
      ALFA=BH
      BETA=DH
      GAMA=EH-ALFA*ETA(NB)-BETA*DEL(NL)
      DEL(N)=FH/GAMA
      ETA(N)=HH/GAMA
      RES=RHS(N)
      V(N)=(HMAX*RES-ALFA*V(NB)-BETA*V(NL))/GAMA
   90 CONTINUE
!
! --- BACK SUBSTITUTE FOR VECTOR XI
!
      DO 100 I3=2,NLYY
      DO 100 J=1,J2
      J3=NXR-J
      N=I3+NLY*(J3-1)
      IF(HX(N).EQ.0.0D0) GO TO 100
      IF((NTYP(N).EQ.1.AND.(.NOT.TRANS1)).OR.(TRANS1.AND.(NHTYP(N).EQ.1)))GO TO 100
      XI(N)=V(N)-DEL(N)*XI(N+NLY)-ETA(N)*XI(N-1)
!
!      FIND MAXIMUM HEAD CHANGE
!
      TCHK=DABS(XI(N))
      IF(TCHK.GE.BIGI) THEN
      BIGI=TCHK
      BIGI1=XI(N)
      END IF
  100 CONTINUE
!
!      COMPUTE RELAXATION PARAMETER W FOR HEAD CHANGES.  ALGORITHM
!      IS FROM COOLEY (1983)
!
  110 S=1.0D0
      IF(NT.GT.1.AND.W1.NE.0.0D0) S=BIGI1/W1
      S1=DABS(S)
      IF(S.LT.-1.0D0) THEN
      W=1.0D0/(S1+S1)
      ELSE
      W=(3.0D0+S)/(3.0D0+S1)
      END IF
      IF(W.EQ.W9) W=0.9D0*W
      W1=W*BIGI
      IF(W1.GT.DSMAX) W=DSMAX/BIGI
      IF(BIGI1.LT.0.0D0) W1=-W1
!
!     ADD CHANGES TO MATRIX.
!
      W9=W
      IF(TRANS1) THEN
      DO 120 N=NLY+1,NNODES
      IF(NHTYP(N).NE.1.AND.HX(N).GT.0.0D0) TT(N)=TT(N)+W*XI(N)
  120 CONTINUE
      IF(BIGI.GT.EPS1) ITEST=1
      ELSE
      DO 130 N=NLY+1,NNODES
      IF(HX(N).GT.0.0D0.AND.NTYP(N).NE.1) P(N)=P(N)+W*XI(N)
  130 CONTINUE
!
!      COMPARE MAXIMUM HEAD CHANGE TO CLOSURE CRITERION.
!
      IF(BIGI.GT.EPS) ITEST=1
      DHMX(NIT)=BIGI
      END IF
      RETURN
! 4000 FORMAT(1X,I5,25HSIP ITERATION PARAMETERS:,6D15.7/(28X,6D15.7/))
      END
                  SUBROUTINE VSSIPSOL
!*****
!VSSIPSOL
!*****
!
!     PURPOSE: TO SOLVE THE  MATRIX EQUATIONS USING THE
!     STRONGLY IMPLICIT METHOD
!
! ----------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use rspac
      use kcon
      use press
      use equats
      use jtxx
      use trxx
      use sip
      use rpropsh
      use scon
      use tempcc
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      LOGICAL HEAT,SOLUTE,FLOW
      COMMON/TRANSTYPE/HEAT,SOLUTE
      COMMON/TCON1/NIS,NIS1,NIS3
      COMMON/SCON1/ITESTS
      DIMENSION IORDERS(21)
      DIMENSION TEMPS(100),HMS(30)
      SAVE HMS,W1S,WS9,LS2,NTHS
      DATA W1S/0.0D0/
!
!-------------------------------------------------------------------
!
      DATA IORDERS/1,2,3,4,5,1,2,3,4,5,11*1/
!
!     COMPUTE ITERATION PARAMETERS
!
      J2=NXR-2
      I2=NLY-2
      LS2=5
      PL2=LS2-1
      WS=0.0D0
      PIE=0.0D0
      WS9=100.0D0
!
!  COMPUTE MAXIMUM PARAMETER
!
      DO 10 I=2,NLYY
      DO 10 J=2,NXRR
      N=NLY*(J-1)+I
      IF(HX(N).GT.0.0D0) THEN
      IM1=JTEX(N)
      PIE=PIE+1.0D0
      DX=DXR(J)/RX(NXR)
      DY=DELZ(I)/DZZ(NLY)
      DX3=DX*DX
      DY2=DY*DY
      WS=WS+1.0D0-DMIN1((DX3+DX3)/(1.0D0+ANIZ(IM1)*DX3/DY2),(DY2+DY2)/&
      (1.0D0+DY2/(ANIZ(IM1)*DX3)))
      END IF
  10  CONTINUE
      WS=WS/PIE
!
! COMPUTE PARAMETERS IN GEOMETRIC SEQUENCE
!
      PJ=-1.0D0
      DO 20 I=1,LS2
      PJ=PJ+1.0D0
  20  TEMPS(I)=1.0D0 -(1.0D0 - WS)**(PJ/PL2)
!
! ORDER SEQUENCE OF PARAMETERS
!
      DO 30 J=1,LS2
      HMS(J)=TEMPS(IORDERS(J))
  30  CONTINUE 
!      WRITE (06,4000) LS2,(HMS(J),J=1,LS2)
      RETURN
!
! STRONGLY IMPLICIT ALGORITHM
!
      ENTRY SLVSIPSOL
      I2=NLY-2
      J2=NXR-2
!
!      SELECT ITERATION PARAMETER.  INITIALIZE ARRAYS
!      
      IF(TRANS2) THEN
!
!  IF TRANS =T  SOLUTE TRANSPORT EQUATION IS SOLVED
!           =F  FLOW EQUATION IS SOLVED
!
      NT=NIS1
      ELSE
      NT=NIT
      END IF
      IF(MOD(NT,LS2).EQ.0.OR.NT.EQ.1)NTHS=0
      NTHS=NTHS+1
      WS=HMS(NTHS)
      ITESTS=0
      DO 40 I=1,NNODES
      DEL(I)=0.0D0
      ETA(I)=0.0D0
      V(I)=0.0D0
  40  XIS(I)=0.0D0
      BIGIS=0.0D0
      BIGIS1=0.0D0
!
! CHOOSE SIP NORMAL OR REVERSE ALGORITHM
!
      IF(MOD(NT,2)) 50,80,50
! ......................................................................
! ORDER EQUATIONS WITH ROW 1 FIRST  -  3X3 EXAMPLE:
!    1 2 3
!    4 5 6
!    7 8 9
! ......................................................................
  50  DO 60 I=2,NLYY
      DO 60 J=2,NXRR
      N=I+NLY*(J-1)
!
!   ---- SKIP COMPUTATIONS OF NODE IS OUTSIDE OF SOLUTION DOMAIN
!
!1      IF(HX(N).EQ.0.0D0 .OR. NTYP(N).EQ.1.0) GO TO 60
      IF(HX(N).EQ.0.0D0) GO TO 60
      IF((NTYP(N).EQ.1.AND.(.NOT.TRANS2)).OR.(TRANS2.AND.(NCTYP(N).EQ.1)))GO TO 60   
      NL=N-NLY
!      NR=N+NLY 
      NA=N-1
      NB=N+1
!
!     --- SIP "NORMAL" ALGORITHM-----
!     --- FORWARD SUBSTITUTE, COMPUTING INTERMEDIATE VECTOR V --
!
      CH=DEL(NA)*BS(N)/(1.0D0 +WS*DEL(NA))
      GH=ETA(NL)*AS(N)/(1.0D0 +WS*ETA(NL))
      BH=BS(N)-WS*CH
      DH=AS(N)-WS*GH
      EH=ES(N)+WS*CH+WS*GH
      FH=CS(N)-WS*CH
      HH=DS(N)-WS*GH
      ALFAS=BH
      BETAS=DH
      GAMAS=EH-ALFAS*ETA(NA)-BETAS*DEL(NL)	
      DEL(N)=FH/GAMAS
      ETA(N)=HH/GAMAS
      RES=RHSS(N)
      V(N)=(HMAX*RES-ALFAS*V(NA)-BETAS*V(NL))/GAMAS
 
  60  CONTINUE
     
!
!  ---BACK SUBSTITUTE FOR VECTOR XI
!
      
      DO 70 I=1,I2
      I3=NLY-I
      DO 70 J=1,J2
      J3=NXR-J
      N=I3+NLY*(J3-1)
      IF(HX(N).EQ.0.0D0) GO TO 70
      IF((NTYP(N).EQ.1.AND.(.NOT.TRANS2)).OR.(TRANS2.AND.(NCTYP(N).EQ.1)))GO TO 70
      XIS(N)=V(N)-DEL(N)*XIS(N+NLY)-ETA(N)*XIS(N+1)
!
!      FIND MAXIMUM HEAD CHANGE
!
      TCHKS=DABS(XIS(N))
      IF(TCHKS.GE.BIGIS) THEN
      BIGIS=TCHKS
      BIGIS1=XIS(N)
      END IF
  70  CONTINUE
      GO TO 110
!
!.......................................................................
!  ---ORDER EQUATIONS WITH THE LAST ROW FIRST  -  3X3 EXAMPLE
!           7 8 9
!           4 5 6
!           1 2 3
!.......................................................................
!
   80 DO 90 II=1,I2
      I=NLY-II
      DO 90 J=2,NXRR
      N=I+NLY*(J-1)
      NL=N-NLY
!      NR=N+NLY  
      NA=N-1
      NB=N+1
!
!  -- SKIP COMPUTATIONS IF NODE IS OUTSIDE OF SOLUTION DOMAIN
!
      IF(HX(N).EQ.0.0D0) GO TO 90
      IF((NTYP(N).EQ.1.AND.(.NOT.TRANS2)).OR.(TRANS2.AND.(NCTYP(N).EQ.1)))GO TO 90
!
! ------ SIP "REVERSE" ALGORITHM
! --- FORWARD SUBSTITUTE, COMPUTING INTERMEDIATE VECTOR V
!
      CH=DEL(NB)*DS(N)/(1.0D0 +WS*DEL(NB))
      GH=ETA(NL)*AS(N)/(1.0D0 +WS*ETA(NL))
      BH=DS(N)-WS*CH
      DH=AS(N)-WS*GH
      EH=ES(N)+WS*CH+WS*GH
      FH=CS(N)-WS*CH
      HH=BS(N)-WS*GH
      ALFAS=BH
      BETAS=DH
      GAMAS=EH-ALFAS*ETA(NB)-BETAS*DEL(NL)
      DEL(N)=FH/GAMAS
      ETA(N)=HH/GAMAS
      RES=RHSS(N)
      V(N)=(HMAX*RES-ALFAS*V(NB)-BETAS*V(NL))/GAMAS

  90  CONTINUE
!
! --- BACK SUBSTITUTE FOR VECTOR XI
!
      DO 100 I3=2,NLY
      DO 100 J=1,J2
      J3=NXR-J
      N=I3+NLY*(J3-1)
      IF(HX(N).EQ.0.0D0) GO TO 100
      IF((NTYP(N).EQ.1.AND.(.NOT.TRANS2)).OR.(TRANS2.AND.(NCTYP(N).EQ.1)))GO TO 100  
      XIS(N)=V(N)-DEL(N)*XIS(N+NLY)-ETA(N)*XIS(N-1)
!
!      FIND MAXIMUM HEAD CHANGE
!
      TCHKS=DABS(XIS(N))
      IF(TCHKS.GE.BIGIS) THEN
      BIGIS=TCHKS
      BIGIS1=XIS(N)
      END IF
  100 CONTINUE
!
!      COMPUTE RELAXATION PARAMETER W FOR HEAD CHANGES.  ALGORITHM
!      IS FROM COOLEY (1983)
!
  110 S=1.0D0
      IF(NT.GT.1.AND.W1S.NE.0.0D0) S=BIGIS1/W1S
      S1=DABS(S)
      IF(S.LT.-1.0D0) THEN
      WS=1.0D0/(S1+S1)
      ELSE
      WS=(3.0D0+S)/(3.0D0+S1)
      END IF
      IF(WS.EQ.WS9) WS=0.9D0*WS
      W1S=WS*BIGIS
      IF(.NOT.TRANS2.AND.W1S.GT.DSMAX) WS=DSMAX/BIGIS
      IF(BIGIS1.LT.0.0D0)W1S=-W1S
!
!      ADD CHANGES TO MATRIX.
!
      WS9=WS
      IF(TRANS2) THEN
      
      DO 120 N=NLY+1,NNODES
      IF(NCTYP(N).NE.1.AND.HX(N).GT.0.0D0)TempC(N)= TempC(N)+WS*XIS(N)
  
  120 CONTINUE
!
!      COMPARE MAXIMUM HEAD CHANGE TO CLOSURE CRITERION.
!
      IF(BIGIS.GT.EPS3) ITESTS=1
        ELSE
          DO 130 N=NLY+1,NNODES
            IF(HX(N).GT.0.0D0 .AND.NTYP(N).NE.1)P(N)=P(N)+WS*XIS(N)
  130  CONTINUE
      IF(BIGIS.GT.EPS)ITESTS=1
      DHMX(NIT)=BIGIS
      end if    
      RETURN
! 4000 FORMAT(1X,I5,25HSIPS ITERATION PARAMETER:,6D15.7/(28X,6D15.7/))
      END
      SUBROUTINE VSCOEF
!******
!VSCOEF
!******
!     PURPOSE: TO COMPUTE ALL VALUES OF NONLINEAR COEFFICIENTS
!              USING THE MOST RECENT VALUES OF PRESSURE HEAD
! ----------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use rspac
      use kcon
      use mprop
      use press
      use hcon
      use jtxx
      use rpropsh
      use trxxh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      LOGICAL HEAT,SOLUTE,FLOW
      COMMON/TRANSTYPE/HEAT,SOLUTE
      integer hydraulicFunctionType
      common/functiontype/ hydraulicFunctionType
!
!-------------------------------------------------------------------
      if(hydraulicFunctionType.eq.1) then
!
!       Van Genuchten functions are used
!
      DO 10 J=2,NLYY
      DO 10 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).GT.0.0D0) THEN
      J1=JTEX(IN)
      HCND(IN)=0.0D0
!
!       COMPUTE PRESSURE HEADS TO USE IN FUNCTIONS
!
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      PTMP=P(IN)+Z1
      IF(HEAT)THEN
      HCND(IN)=VSHKUVGH(PTMP,TT(IN),J1)
      ELSE
      HCND(IN)=VSHKUVG(PTMP,J1)
      END IF
      THETA(IN)=VSTHUVG(PTMP,J1)
      END IF
   10 CONTINUE
      RETURN
      else
      if(hydraulicFunctionType.eq.2) then
!
!       Haverkamp functions
!
      DO 11 J=2,NLYY
      DO 11 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).GT.0.0D0) THEN
      J1=JTEX(IN)
      HCND(IN)=0.0D0
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      PTMP=P(IN)+Z1
      IF(HEAT)THEN
      HCND(IN)=VSHKUHKH(PTMP,TT(IN),J1)  
      ELSE   
      HCND(IN)=VSHKUHK(PTMP,J1)
      END IF
      THETA(IN)=VSTHUHK(PTMP,J1)
      END IF
 11   CONTINUE
      RETURN
      else
!
!       Brooks-Corey functions
!
      if(hydraulicFunctionType.eq.0) then
      DO 12 J=2,NLYY
      DO 12 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).GT.0.0D0) THEN
      J1=JTEX(IN)
      HCND(IN)=0.0D0
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      PTMP=P(IN)+Z1
      IF(HEAT)THEN
      HCND(IN)=VSHKUBCH(PTMP,TT(IN),J1)
      ELSE  
      HCND(IN)=VSHKUBC(PTMP,J1)
      END IF
      THETA(IN)=VSTHUBC(PTMP,J1)
      END IF
 12   CONTINUE
      RETURN
!
!       Tabular functions
!
      else
      if(hydraulicFunctionType.eq.3) then
      DO 13 J=2,NLYY
      DO 13 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).GT.0.0D0) THEN
      J1=JTEX(IN)
      HCND(IN)=0.0D0
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      PTMP=P(IN)+Z1
      IF(HEAT)THEN
      HCND(IN)=VSHKUTABH(PTMP,TT(IN),J1)
      ELSE  
      HCND(IN)=VSHKUTAB(PTMP,J1)
      END IF
      THETA(IN)=VSTHUTAB(PTMP,J1)
      END IF
 13   CONTINUE
      RETURN
      else
!
!  user supplied other function type
!
      DO 14 J=2,NLYY
      DO 14 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).GT.0.0D0) THEN
      J1=JTEX(IN)
      HCND(IN)=0.0D0
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      PTMP=P(IN)+Z1
!
!  revisions for Rossi-Nimmo
!
!      HCND(IN)=VSHKUOT(PTMP,J1)
      THETA(IN)=VSTHUOT(PTMP,J1)
      IF(HEAT)THEN
      HCND(IN)=VSHKUOTH(THETA(IN),TT(IN),J1)
      ELSE
      HCND(IN) = VSHKUOT(THETA(IN),J1)
      END IF      
!
!  end revsions
!
      END IF
 14   CONTINUE
      RETURN
      end if
      end if
      end if
      end if
      END
      
      SUBROUTINE VSHCMP
!******
!VSHCMP
!******
!
!   PURPOSE: TO COMPUTE INTERCELL CONDUCTANCES
!
! ----------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use rspac
      use kcon
      use hcon
      use jtxx
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
!
!----------------------------------------------------------------------
!
!    COMPUTE HARMONIC MEANS OF KSAT AND GRID SPACING
!
      DO 10 J=2,NLY
      DO 10 N=2,NXR
      IN=NLY*(N-1)+J
      JM1=IN-1
      NM1=IN-NLY
      A1=ANIZ(JTEX(IN))
      A2=ANIZ(JTEX(JM1))
      IF(HX(IN).EQ.0.0D0) GO TO 10
      AREA=DXR(N)
      IF(RAD)AREA=PI2*RX(N)*DXR(N)
!
!   VERTICAL CONDUCTANCE
!   THROUGH TOP
!
      HKTT(IN)=2.0D0*A1*A2*AREA*HX(IN)*HX(JM1)/(A2*HX(JM1)*DELZ(J)+&
      A1*HX(IN)*DELZ(J-1))
      AREA=DELZ(J)
      IF(RAD)AREA=PI2*DELZ(J)*(RX(N)-0.5D0 *DXR(N))
!
!   HORIZONTAL OR RADIAL CONDUCTANCE
!   THROUGH LEFT-HAND SIDE
!
      HKLL(IN)=2.0D0*AREA*HX(IN)*HX(NM1)/(HX(NM1)*DXR(N)+HX(IN)*DXR(N-1))
   10 CONTINUE
      RETURN
      END
      SUBROUTINE VSFLUX
!******
!VSFLUX
!******
!
!      PURPOSE: TO COMPUTE FLUXES AND MASS BALANCE
!
! ----------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use rspac
      use kcon
      use mprop
      use press
      use disch
      use dumm
      use jtxx
      use equat
      use equats
      use trxx
      use trxy1
      use plott
      use rpropsh
      use scon
      use BF
      use ptet
      use temp
      use pit
      use trxy2
      use trxxh
      use solmass
      use compnam
      use react
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      COMMON/JCON/JSTOP,JFLAG,jflag1
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
      F14P,F15P,F16P,F17P,F18P,F19P
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
      F14P,F15P,F16P,F17P,F18P,F19P
      integer hydraulicFunctionType
      common/functiontype/ hydraulicFunctionType
      character*20 label9(99,3)
      CHARACTER*80 TITL
      CHARACTER*6 ZUNIT,CUNX,HUNX
      CHARACTER*7 TUNIT
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX
      common/elimit/elimit1,elimit2
      LOGICAL HEAT,SOLUTE,FLOW
      COMMON/TRANSTYPE/HEAT,SOLUTE
      COMMON/JCONF/JFLAG2
      CHARACTER*10 SCOMPNAME(50)
      COMMON/MASSB/BL(99),bcmft,bcmht,bl29I,bl29IT,bl29O,bl29OT, &
      bl95I,bl95IT,bl95O,bl95OT
      common/massb1/bcmf,bcmh, &
      bltemp69,bltemp72,bltemp75,bltemp78,bltemp91
      common/massb2/label9
     
!-------------------------------------------------------------------
!
!   INITIALIZE MASS BALANCE VARIABLES USED FOR
!   ENTIRE SIMULATION.
!
!
!  05/02 new variables created:
!   bcmf is water mass added to system by change in flow BC
!   bcmt is solute mass added to system by change in flow BC
!

      IF(KTIM.EQ.1) THEN
      DO 10 I=1,99
      BL(I)=0.0D0
   10 CONTINUE
      if(solute)then
        do 100 N = 1,Nsol
        dO 108 I = 1,36
        BLSOL(N,I)=0.0D0
   108  continue
        bl62I(N)=0.0d0
        bl62IT(N)=0.0d0
        bl62O(N)=0.0d0
        bl62OT(N)=0.0d0
        bcmtt(N)=0.0d0
        bcmt(N)=0.0d0
        bcmtr(N)=0.0d0
        bltemp36(N) = 0.0d0
        bltemp39(N) = 0.0d0
        bltemp42(N) = 0.0d0
        bltemp45(N) = 0.0d0
        bltemp60(N) = 0.0d0   
 100  CONTINUE     
      end if 
      if (f7p) then
       do 11 i = 1,numBF
        totalBF(i,1) = 0.0d0
        totalBF(i,2) = 0.0d0
        currentBF(i,4) = 0.0d0
 11     continue
      end if

      bltemp69 = 0.0d0
      bltemp72 = 0.0d0
      bltemp75 = 0.0d0
      bltemp78 = 0.0d0
      bltemp91 = 0.0d0
      bcmft = 0.0d0
      bcmht= 0.0d0    
      bl95I= 0.0d0
      bl95IT= 0.0d0
      bl95O= 0.0d0
      bl95OT= 0.0d0
!
!   label9 is array of headings for file 9 
!
      label9(1,1) = ' FLOW IN '
      LABEL9(2,1) = LABEL9(1,1)
      LABEL9(3,1) = LABEL9(1,1)
      LABEL9(4,1) = ' FLOW OUT '
      LABEL9(5,1) = LABEL9(4,1)
      LABEL9(6,1) = LABEL9(4,1)
      LABEL9(7,1) = LABEL9(1,1)
      LABEL9(8,1) = LABEL9(1,1)
      LABEL9(9,1) = LABEL9(1,1)
      LABEL9(10,1) = LABEL9(4,1)
      LABEL9(11,1) = LABEL9(4,1)
      LABEL9(12,1) = LABEL9(4,1)
      LABEL9(13,1) = ' TOTAL '
      LABEL9(14,1) = LABEL9(13,1)
      LABEL9(15,1) = LABEL9(13,1)
      LABEL9(16,1) = LABEL9(13,1)
      LABEL9(17,1) = LABEL9(13,1)
      LABEL9(18,1) = LABEL9(13,1)
      LABEL9(19,1) = ' EVAP- '
      LABEL9(20,1) = LABEL9(19,1)
      LABEL9(21,1) = LABEL9(19,1)
      LABEL9(22,1) = ' TRANS- '
      LABEL9(23,1) = LABEL9(22,1)
      LABEL9(24,1) = LABEL9(22,1)
      LABEL9(25,1) = ' EVAP + '
      LABEL9(26,1) = LABEL9(25,1)
      LABEL9(27,1) = LABEL9(25,1)
      LABEL9(28,1) = ' FLUID '
      LABEL9(29,1) = LABEL9(28,1)
      LABEL9(30,1) = LABEL9(28,1)
      LABEL9(31,1) = LABEL9(28,1)
      LABEL9(32,1) = LABEL9(28,1)
      LABEL9(33,1) = LABEL9(28,1)
      LABEL9(34,1) = ' SOLUTE IN '
      LABEL9(35,1) = LABEL9(34,1)
      LABEL9(36,1) = LABEL9(34,1)
      LABEL9(37,1) = ' SOLUTE OUT'
      LABEL9(38,1) = LABEL9(37,1)
      LABEL9(39,1) = LABEL9(37,1)
      LABEL9(40,1) = LABEL9(34,1)
      LABEL9(41,1) = LABEL9(34,1)
      LABEL9(42,1) = LABEL9(34,1)
      LABEL9(43,1) = LABEL9(37,1)
      LABEL9(44,1) = LABEL9(37,1)
      LABEL9(45,1) = LABEL9(37,1)
      LABEL9(46,1) = ' DISPERSION'
      LABEL9(47,1) = LABEL9(46,1)
      LABEL9(48,1) = LABEL9(46,1)
      LABEL9(49,1) = LABEL9(46,1)
      LABEL9(50,1) = LABEL9(46,1)
      LABEL9(51,1) = LABEL9(46,1)
      LABEL9(52,1) = ' TOTAL '
      LABEL9(53,1) = LABEL9(52,1)
      LABEL9(54,1) = LABEL9(52,1)
      LABEL9(55,1) = LABEL9(52,1)
      LABEL9(56,1) = LABEL9(52,1)
      LABEL9(57,1) = LABEL9(52,1)
      LABEL9(58,1) = ' SOLUTE OUT'
      LABEL9(59,1) = LABEL9(58,1)
      LABEL9(60,1) = LABEL9(58,1)
      LABEL9(61,1) = ' SOLUTE '
      LABEL9(62,1) = LABEL9(61,1)
      LABEL9(63,1) = LABEL9(61,1)
      LABEL9(64,1) = LABEL9(61,1)
      LABEL9(65,1) = LABEL9(61,1)
      LABEL9(66,1) = LABEL9(61,1)
      LABEL9(67,1) = ' ENERGY IN '
      LABEL9(68,1) = LABEL9(61,1)
      LABEL9(69,1) = LABEL9(61,1)
      LABEL9(70,1) = ' ENERGY OUT '
      LABEL9(71,1) = LABEL9(61,1)
      LABEL9(72,1) = LABEL9(61,1)
      LABEL9(73,1) = LABEL9(61,1)
      LABEL9(74,1) = LABEL9(61,1)
      LABEL9(75,1) = LABEL9(61,1)
      LABEL9(76,1) = LABEL9(61,1)
      LABEL9(77,1) = LABEL9(61,1)
      LABEL9(78,1) = LABEL9(61,1)
      LABEL9(79,1) = ' DISPERSION '
      LABEL9(80,1) = LABEL9(61,1)
      LABEL9(81,1) = LABEL9(61,1)
      LABEL9(82,1) = LABEL9(61,1)
      LABEL9(83,1) = LABEL9(61,1)
      LABEL9(84,1) = LABEL9(61,1)
      LABEL9(85,1) = ' TOTAL '
      LABEL9(86,1) = LABEL9(61,1)
      LABEL9(87,1) = LABEL9(61,1)
      LABEL9(88,1) = LABEL9(61,1)
      LABEL9(89,1) = LABEL9(61,1)
      LABEL9(90,1) = LABEL9(61,1)
      LABEL9(91,1) = ' ENERGY '
      LABEL9(92,1) = LABEL9(61,1)
      LABEL9(93,1) = LABEL9(61,1)
      LABEL9(94,1) = LABEL9(61,1)
      LABEL9(95,1) = LABEL9(61,1)
      LABEL9(96,1) = LABEL9(61,1)
      LABEL9(97,1) = ' ENERGY OUT '
      LABEL9(98,1) = LABEL9(61,1)
      LABEL9(99,1) = LABEL9(61,1)
!
      LABEL9(1,2) = ' SP HEAD '
      LABEL9(2,2) = LABEL9(1,2)
      LABEL9(3,2) = LABEL9(1,2)
      LABEL9(4,2) = LABEL9(1,2)
      LABEL9(5,2) = LABEL9(1,2)
      LABEL9(6,2) = LABEL9(1,2)
      LABEL9(7,2) = ' SP FLUX '
      LABEL9(8,2) = LABEL9(7,2)
      LABEL9(9,2) = LABEL9(7,2)
      LABEL9(10,2) = LABEL9(7,2)
      LABEL9(11,2) = LABEL9(7,2)
      LABEL9(12,2) = LABEL9(7,2)
      LABEL9(13,2) = ' FLOW IN '
      LABEL9(14,2) = LABEL9(13,2)
      LABEL9(15,2) = LABEL9(13,2)
      LABEL9(16,2) = ' FLOW OUT '
      LABEL9(17,2) = LABEL9(16,2)
      LABEL9(18,2) = LABEL9(16,2)
      LABEL9(19,2) = ' ORATION '
      LABEL9(20,2) = LABEL9(19,2)
      LABEL9(21,2) = LABEL9(19,2)
      LABEL9(22,2) = ' PIRATION '
      LABEL9(23,2) = LABEL9(22,2)
      LABEL9(24,2) = LABEL9(22,2)
      LABEL9(25,2) = ' TRANS '
      LABEL9(26,2) = LABEL9(25,2)
      LABEL9(27,2) = LABEL9(25,2)
      LABEL9(28,2) = ' STORAGE '
      LABEL9(29,2) = LABEL9(28,2)
      LABEL9(30,2) = LABEL9(28,2)
      LABEL9(31,2) = ' VOL BAL '
      LABEL9(32,2) = LABEL9(31,2)
      LABEL9(33,2) = LABEL9(31,2)
      LABEL9(34,2) = LABEL9(1,2)
      LABEL9(35,2) = LABEL9(1,2)
      LABEL9(36,2) = LABEL9(1,2)
      LABEL9(37,2) = LABEL9(1,2)
      LABEL9(38,2) = LABEL9(1,2)
      LABEL9(39,2) = LABEL9(1,2)
      LABEL9(40,2) = LABEL9(7,2)
      LABEL9(41,2) = LABEL9(7,2)
      LABEL9(42,2) = LABEL9(7,2)
      LABEL9(43,2) = LABEL9(7,2)
      LABEL9(44,2) = LABEL9(7,2)
      LABEL9(45,2) = LABEL9(7,2)
      LABEL9(46,2) = ' IN '
      LABEL9(47,2) = LABEL9(46,2)
      LABEL9(48,2) = LABEL9(46,2)
      LABEL9(49,2) = ' OUT '
      LABEL9(50,2) = LABEL9(49,2)
      LABEL9(51,2) = LABEL9(49,2)
      LABEL9(52,2) = LABEL9(34,1)
      LABEL9(53,2) = LABEL9(34,1)
      LABEL9(54,2) = LABEL9(34,1)

      LABEL9(55,2) = LABEL9(37,1)
      LABEL9(56,2) = LABEL9(37,1)
      LABEL9(57,2) = LABEL9(37,1)
      LABEL9(58,2) = ' ET '
      LABEL9(59,2) = LABEL9(58,2)
      LABEL9(60,2) = LABEL9(58,2)
      LABEL9(61,2) = LABEL9(28,2)
      LABEL9(62,2) = LABEL9(28,2)
      LABEL9(63,2) = LABEL9(28,2)
      LABEL9(64,2) = ' MASS BAL  '
      LABEL9(65,2) = LABEL9(64,2)
      LABEL9(66,2) = LABEL9(64,2)

      LABEL9(67,2) = LABEL9(1,2)
      LABEL9(68,2) = LABEL9(1,2)
      LABEL9(69,2) = LABEL9(1,2)
      LABEL9(70,2) = LABEL9(1,2)
      LABEL9(71,2) = LABEL9(1,2)
      LABEL9(72,2) = LABEL9(1,2)
      LABEL9(73,2) = LABEL9(7,2)
      LABEL9(74,2) = LABEL9(7,2)
      LABEL9(75,2) = LABEL9(7,2)
      LABEL9(76,2) = LABEL9(7,2)
      LABEL9(77,2) = LABEL9(7,2)
      LABEL9(78,2) = LABEL9(7,2)
      LABEL9(79,2) = ' IN '
      LABEL9(80,2) = LABEL9(79,2)
      LABEL9(81,2) = LABEL9(79,2)
      LABEL9(82,2) = ' OUT '
      LABEL9(83,2) = LABEL9(49,2)
      LABEL9(84,2) = LABEL9(49,2)
      LABEL9(85,2) = LABEL9(67,1)
      LABEL9(86,2) = LABEL9(67,1)
      LABEL9(87,2) = LABEL9(67,1)
      LABEL9(88,2) = LABEL9(70,1)
      LABEL9(89,2) = LABEL9(70,1)
      LABEL9(90,2) = LABEL9(70,1)
      LABEL9(91,2) = LABEL9(28,2)
      LABEL9(92,2) = LABEL9(28,2)
      LABEL9(93,2) = LABEL9(28,2)
      LABEL9(94,2) = ' MASS BAL '
      LABEL9(95,2) = LABEL9(61,1)
      LABEL9(96,2) = LABEL9(61,1)
      LABEL9(97,2) = ' ET '
      LABEL9(98,2) = LABEL9(61,1)
      LABEL9(99,2) = LABEL9(61,1)
      LABEL9(1,3) = ' TOTAL '
      LABEL9(2,3) = ' TIME STEP '
      LABEL9(3,3) = ' RATE '
      DO 771 K3 = 3,69,3
      LABEL9(K3+1,3) = LABEL9(1,3)
      LABEL9(K3+2,3) = LABEL9(2,3)
      LABEL9(K3+3,3) = LABEL9(3,3)
 771  CONTINUE
      END IF
!
!   INITIALIZE MASS BALANCE VARIABLES USED FOR CURRENT
!   TIME STEP
!
      BLTEMP=0.0D0
      BL(3)=0.0D0
      BL(6)=0.0D0
      BL(9)=0.0D0
      BL(12)=0.0D0
      BL(27)=0.0D0
      BL(29)=0.0D0
      BL(36)=0.0D0
      BL(39)=0.0D0
      BL(42)=0.0D0
      BL(45)=0.0D0
      BL(60)=0.0D0
      BL(62)=0.0D0
      BL(51)=0.0D0
      BL(48)=0.0D0
      BL(69)=0.0D0
      BL(72)=0.0D0
      BL(75)=0.0D0
      BL(78)=0.0D0
      BL(81)=0.0D0
      BL(84)=0.0D0
      BL(92)=0.0D0
      BL(95)=0.0D0
      bcmf = 0.0D0
      bcmh = 0.0D0
      bltemp2 = 0.0D0
      bl95I = 0.0D0
      bl95O = 0.0D0
      Do 111 M=1,nsol
      BLSOL(M,3) = 0.0D0
      BLSOL(M,6) = 0.0D0
      BLSOL(M,9) = 0.0D0
      BLSOL(M,12) = 0.0D0
      BLSOL(M,15) = 0.0D0
      BLSOL(M,18) = 0.0D0
      BLSOL(M,27) = 0.0D0
      BLSOL(M,29) = 0.0D0
      BLSOL(M,35) = 0.0D0
      BCMT(M) = 0.0D0
   
 111  continue
      if (f7p) then
       do 12 i=1,numBF
        currentBF(i,1) = 0.0d0
        currentBF(i,2) = 0.0d0
        currentBF(i,3) = 0.0d0
 12     continue
      end if
      DO 21 J=2,NLYY
      DO 21 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(HX(IN).EQ.0.0D0) GO TO 21
      JM1=IN-1
      JP1=IN+1
      NM1=IN-NLY
      NP1=IN+NLY
      VOL=DXR(N)*DELZ(J)
      IF(RAD)VOL=PI2*RX(N)*DXR(N)*DELZ(J)
!
!     SUM CHANGE IN STORAGE
!
      IF(HEAT)THEN
      GSF=VOL*(THETA(IN)*RHO(IN)-THLST(IN)*RHOOLD(IN))
      ELSE  
      GSF=VOL*(THETA(IN)-THLST(IN))
      END IF
      JJ=JTEX(IN)
      SS=HK(JJ,2)/HK(JJ,3)
      IF(HEAT)THEN
      GSS=VOL*THETA(IN)*SS*RHO(IN) 
      ELSE  
      GSS=VOL*THETA(IN)*SS
      END IF
      bltemp2 = (GSF+GSS*(P(IN)-PXXX(IN)))
      bl(29) = bl(29) + bltemp2
      if(bltemp2.ge.0.0d0) then
       if (.not.(ntyp(in).eq.1.and.jflag1.eq.1))&
        bl29I = bl29I + bltemp2
       else
       if (.not.(ntyp(in).eq.1.and.jflag1.eq.1))&
        bl29O = bl29O + bltemp2
      end if
      if(ntyp(in).eq.1.and.jflag1.eq.1)& 
       bcmf = bcmf + bltemp2
     
      IF(HEAT) THEN
!
!   FOR TRANSPORT SUM CHANGE IN STORAGE AND DIFFUSIVE/DISPERSIVE
!   FLUXES
!
!     IF(NCTYP(IN).NE.1) BL(68)=BL(68)+VOL*(
!
!  CHANGE 8-12-91 FOR STORAGE
!
!    *CC(IN)*THETA(IN)*(1+SS*P(IN))-COLD(IN)*THLST(IN)*(1+SS*PXXX(IN)))
!      bltemp2=VOL*(
!      IF(NCTYP(IN).NE.1) BL(68)=BL(68)+VOL*(
!     *CC(IN)*(HT(JJ,5)+THETA(IN)*RHO(IN)*HT(JJ,11)*(2.0d0+
!     *SS*(P(IN)-PXXX(IN))))-cc(in)*thlst(in)*rho(in)*ht(jj,11)
!     *-COLD(IN)*(theta(IN)*RHOOLD(IN)*HT(JJ,11)+ht(jj,5)))

!*****************************
! following changes made 7-3-04 to correct way that dctheta/dt is
! calculated
!*****************************
      bltemp2=VOL*( &
      TT(IN)*(HT(JJ,3)+THETA(IN)*RHO(IN)*HT(JJ,6)*(1.0d0+ &
      SS*(P(IN)-PXXX(IN))))-ttold(in)*(thlst(in)*RHO(IN)*ht(jj,6)&
      +ht(jj,3)))
      bl(95) = bl(95) + bltemp2
      if (jflag1.eq.1) then
       if(ntyp(in).eq.1) bcmh = bcmh + TT(IN)*(theta(in) - thlst(in)) &
         *RHOOLD(IN)*HT(JJ,6)*vol
       if(nhtyp(in).eq.1) bcmh = bcmh + (theta(in)*RHOOLD(IN)*HT(JJ,6) &
         +ht(jj,3))*(TT(IN) - TTOLD(IN))*vol
      end if
      if(bltemp2.ge.0.0D0) then
       if (.not.((jflag1.eq.1).and.(ntyp(in).eq.1.or.nhtyp(in).eq.1))) &
         bl95I = bl95I + bltemp2
      else
       if (.not.((jflag1.eq.1).and.(ntyp(in).eq.1.or.nhtyp(in).eq.1))) &
         bl95O = bl95O + bltemp2
      end if
      END IF
!
!
!   
      IF(SOLUTE) THEN
        DO 20 M=1,Nsol
        bltemp2=VOL*(&
      CC(M,IN)*THETA(IN)*(1.0d0+SS*(P(IN)-PXXX(IN)))-ccold(m,in)&
      *thlst(in))
      BLSOL(M,29)=BLSOL(M,29)+ bltemp2
      BLSOL(M,35)= BLSOL(M,35)+ vol*theta(in)*(CC(M,IN)-CCBR(M,IN)) 
      if (jflag2.eq.1) then
       if(ntyp(in).eq.1.or.nctyp(in).eq.1) bcmt(M) =bcmt(M) + bltemp2
!      if(nctyp(in).eq.1)bcmt(N)=bcmt(N)+(theta(in)*(cc(m,in)- &
!       ccold(m,in)))*vol
      end if
      if(bltemp2.ge.0.0D0) then
      if (.not.((jflag2.eq.1).and.(ntyp(in).eq.1.or.nctyp(in)&
       .eq.1)))  bl62I(M) = bl62I(M) + bltemp2
      else
       if (.not.((jflag2.eq.1).and.(ntyp(in).eq.1.or.nctyp(in)&
      .eq.1)))bl62O(M) = bl62O(M) + bltemp2
      end if 
  20  continue
      end if    
      IF(NHTYP(IN).EQ.2) THEN
      IF(TS(IN).LT.0.0D0) THEN
      BL(84)=BL(84)+TS(IN)
      ELSE
      BL(81)=BL(81)+TS(IN)
      END IF
      END IF
      IF(NCTYP(IN).EQ.2) THEN
        do 22 M1=1,Nsol
      IF(CSS(M1,IN).LT.0.0D0) THEN
!      BL(51)=BL(51)+CSS(M1,IN)
      BLSOL(M1,18)=BLSOL(M1,18)+ CSS(M1,IN)
      ELSE
!      BL(48)=BL(48)+CSS(M1,IN)
      BLSOL(M1,15)=BLSOL(M1,15)+CSS(M1,IN)
      END IF
  22  CONTINUE
      END IF
      IF(NHTYP(IN).EQ.1) THEN

      IF (CIT) THEN
       T5=A(IN)*(TT(IN)-TT(NM1))+ao(in)*(TTOLD(IN)-TTOLD(NM1))+&
      B(IN)*(TT(IN)-TT(JM1))+bo(in)*(TTOLD(IN)-TTOLD(JM1))+&
      C(IN)*(TT(IN)-TT(NP1))+co(in)*(TTOLD(IN)-TTOLD(NP1))+&
      D(IN)*(TT(IN)-TT(JP1))+do(in)*(TTOLD(IN)-TTOLD(JP1))

       ao(in) = a(in)
       bo(in) = b(in)
       co(in) = c(in)
       do(in) = d(in)
         
        IF(JFLAG1.EQ.1) THEN
        AO(IN)=0.5D0*AO(IN)
        BO(IN)=0.5D0*BO(IN)
        CO(IN)=0.5D0*CO(IN)
        DO(IN)=0.5D0*DO(IN)
        END IF
      ELSE
       T5=A(IN)*(TT(IN)-TT(NM1))+B(IN)*(TT(IN)-TT(JM1))+&
      C(IN)*(TT(IN)-TT(NP1))+D(IN)*(TT(IN)-TT(JP1))
      END IF

      if (f7p) then
       do 14 ib1 = 1,numBF
       do 14 ib2 = 1,numcellsBF(ib1)
        if (in.eq.nodenum(ib1,ib2)) then
           currentBF(ib1,3) = currentBF(ib1,3) + T5
           go to 13
        end if
 14     continue
      end if
 13   continue
      IF(T5.LT.0.0D0) THEN
      BL(84)=BL(84)+T5
      ELSE
      BL(81)=BL(81)+T5
      END IF
      END IF
      IF(NCTYP(IN).EQ.1) THEN
        DO 23 M=1,Nsol
        IF (CIT) THEN
      T6=AS(IN)*(CC(M,IN)-CC(M,NM1))+aoc(in)*(CCOLD(M,IN)-&
      CCOLD(M,NM1))+BS(IN)*(CC(M,IN)-CC(M,JM1))+boc(in)*(CCOLD(M,IN)-&
      CCOLD(M,JM1))+CS(IN)*(CC(M,IN)-CC(M,NP1))+coc(in)*(CCOLD(M,IN)&
      -CCOLD(M,NP1))+DS(IN)*(CC(M,IN)-CC(M,JP1))+doc(in)*(CCOLD(M,IN)&
      -CCOLD(M,JP1))
      if(M.EQ.Nsol) then
       aoc(in) = as(in)
       boc(in) = bs(in)
       coc(in) = cs(in)
       doc(in) = ds(in)
       IF(JFLAG2.EQ.1) THEN
        AOC(IN)=0.5D0*AOC(IN)
        BOC(IN)=0.5D0*BOC(IN)
        COC(IN)=0.5D0*COC(IN)
        DOC(IN)=0.5D0*DOC(IN)          
       END IF
       END IF
      ELSE
      T6=AS(IN)*(CC(M,IN)-CC(M,NM1))+BS(IN)*(CC(M,IN)-CC(M,JM1))+&
      CS(IN)*(CC(M,IN)-CC(M,NP1))+DS(IN)*(CC(M,IN)-CC(M,JP1))
      END IF
      if (f7p) then
       do 16 ib1 = 1,numBF
       do 16 ib2 = 1,numcellsBF(ib1)
        if (in.eq.nodenum(ib1,ib2)) then
           currentBF(ib1,3) = currentBF(ib1,3) + T6
           go to 15
        end if
 16     continue
      end if
 15   continue 
      IF(T6.LT.0.0D0) THEN
!      BL(51)=BL(51)+T6
      BLSOL(M,18)=BLSOL(M,18)+ T6
      ELSE
!      BL(48)=BL(48)+T6
      BLSOL(M,15)=BLSOL(M,15)+T6 
      END IF
  23  continue    
      END IF
       
!
!  FLUX FOR NEUMANN CELLS
!
      IF(NTYP(IN).EQ.2.or.ntyp(in).eq.7) THEN
      IF(QQ(IN).LE.0.0D0) THEN
      IF((HEAT.AND.SOLUTE).OR.HEAT) THEN
      BL(12)=BL(12)+QQ(IN)*RHO(IN)
      ELSE  
      BL(12)=BL(12)+QQ(IN)
      END IF
      IF(HEAT) BL(78)=BL(78)+QQ(IN)*TT(IN)*RHO(IN)*HT(JJ,6)
      IF(SOLUTE)then
      do 24 M2=1,Nsol  
!      BL(45)=BL(45)+QQ(IN)*CC(M2,IN)
      BLSOL(M2,12)=BLSOL(M2,12)+QQ(IN)*CC(M2,IN)
  24  continue  
      end if
      ELSE
      IF((HEAT.AND.SOLUTE).OR.HEAT) THEN  
      BL(9)=BL(9)+QQ(IN)*RHO(IN)
      ELSE
      BL(9)=BL(9)+QQ(IN)
      END IF
      IF(HEAT)BL(75)=BL(75)+QQ(IN)*TS(IN)*RHO(IN)*HT(JJ,6)
      IF(SOLUTE)THEN
      do 25 M3=1,Nsol  
!      BL(42)=BL(42)+QQ(IN)*CSS(M3,IN)
      BLSOL(M3,9)=BLSOL(M3,9)+ QQ(IN)*CSS(M3,IN)
  25  continue
      END IF
      END IF
      ELSE
!
!  FLUX FOR DIRICHLET CELLS
!
      IF(NTYP(IN).EQ.1) THEN
!      IF(TRANS) THEN
!      QX=QT(IN)
!      ELSE
!      QX=VSFLX1(IN)
!      END IF
      if (.not. trans) qt(in) = vsflx1(in)
!      qx = qt(in)
      if(SOLUTE) then
         qx = qs(in)
        else
         qx = qt(in)
      end if
      IF(QX.LT.0.0D0) THEN  
      BL(3)=BL(3)-QX
      IF(HEAT) BL(69)=BL(69)-QX*TS(IN)*HT(JJ,6)
      IF(SOLUTE)then
        do 26 M4=1,Nsol  
!      BL(36)=BL(36)-QX*CSS(M4,IN)
      BLSOL(M4,3)=BLSOL(M4,3)-QX*CSS(M4,IN)
  26  continue  
      end if
      ELSE
      BL(6)=BL(6)-QX
      IF(HEAT) BL(72)=BL(72)-QX*TT(IN)*HT(JJ,6)
      IF(SOLUTE)then
        do 27 M5=1,Nsol
!      BL(39)=BL(39)-QX*CSS(M5,IN)
      BLSOL(M5,6)=BLSOL(M5,6)-QX*CC(M5,IN)
  27  continue  
      end if
      END IF
      ELSE
!
!    SUM SOURCES AND SINKS
!     
      IF((HEAT.AND.SOLUTE).OR.HEAT) THEN
      BL(27)=BL(27)+Q(IN)*RHO(IN)
      ELSE
      BL(27)=BL(27)+Q(IN)
      END IF  
      if(NPV.ge.0) then
      IF(HEAT.AND.NTYP(IN).NE.5) BL(93)=BL(93)+Q(IN)*TT(IN)*RHO(IN)&
      *HT(JJ,6)  
      IF(SOLUTE.AND.NTYP(IN).NE.5)then
        do 28 M6=1, Nsol
!      BL(60)=BL(60)+Q(IN)*CC(M6,IN)
      BLSOL(M6,27)=BLSOL(M6,27)+Q(IN)*CC(M6,IN)
  28  continue    
      end if
      end if
      END IF
      end if
!      if(cit.and.nctyp(in).ne.1) then
!      SS=theta(IN)*(P(IN)-PXXX(IN))*HK(JJ,2)/HK(JJ,3)
!      EO(IN)=E(IN)+VOL*(((THETA(IN)+SS)*RHO(IN)*HT(JJ,6)+&
!      HT(JJ,3))/DELT)
!      IF(JFLAG1.EQ.1) EO(IN)=0.5D0*EO(IN)
!      end if
!
!  the following was moved from vtsetup, so that AO, etc
!   would not be updated until a final solution had been
!   reached
!
      if(cit.and.nhtyp(in).ne.1) then
      AO(IN)=A(IN)
      BO(IN)=B(IN)
      CO(IN)=C(IN)
      DO(IN)=D(IN)
      SS=theta(IN)*(P(IN)-PXXX(IN))*HK(JJ,2)/HK(JJ,3)
!      SS1=HT(JJ,4)*THETA(IN)
      SS1 = 0.0D0
!
!******************
!  following change made 7-3-04 to correct dctheta/dt 
!   calculation - see written notes
!
!******************
!      if(jflag1.ne.1.or.ntyp(IN).ne.1) then
!      SS=THETA(IN)+SS-THLST(IN)
!      end if
!*****************
      EO(IN)=E(IN)+VOL*(SS1+((THETA(IN)+SS)*RHO(IN)*HT(JJ,6)&
      +HT(JJ,3))/DELT)
      IF(JFLAG1.EQ.1) THEN
        AO(IN)=0.5D0*AO(IN)
        BO(IN)=0.5D0*BO(IN)
        CO(IN)=0.5D0*CO(IN)
        DO(IN)=0.5D0*DO(IN)
       EO(IN)=0.5D0*EO(IN)
      end if
      end if
   21 CONTINUE
!
!   ACCUMULATE VALUES FOR TOTAL ELAPSED SIMULATION TIME
!
      if (cit) then
       if(jflag1.eq.1) then
        bltemp69 = bl(69)
        bltemp72 = bl(72)
        bltemp75 = bl(75)
        bltemp78 = bl(78)
        bltemp91 = bl(91)
       else
        bltemp1 = 0.5d0*(bl(69)+bltemp69)
        bltemp69 = bl(69)
        bl(69) = bltemp1
        bltemp1 = 0.5d0*(bl(72)+bltemp72)
        bltemp72 = bl(72)
        bl(72) = bltemp1
        bltemp1 = 0.5d0*(bl(75)+bltemp75)
        bltemp75 = bl(75)
        bl(75) = bltemp1
        bltemp1 = 0.5d0*(bl(78)+bltemp78)
        bltemp78 = bl(78)
        bl(78) = bltemp1
        bltemp1 = 0.5d0*(bl(91)+bltemp91)
        bltemp91 = bl(91)
        bl(91) = bltemp1
       end if
       IF (SOLUTE) THEN
         do 30 N=1,Nsol
       if(JFLAG2.eq.1) then
        bltemp36(N) = BLSOL(N,3)
        bltemp39(N) = BLSOL(N,6)
        bltemp42(N) = BLSOL(N,9)
        bltemp45(N) = BLSOL(N,12)
        bltemp60(N) = BLSOL(N,27)
      else
        bltemp1 = 0.5d0*(BLSOL(N,3)+bltemp36(N))
        bltemp36(N) = BLSOL(N,3)
        BLSOL(N,3) = bltemp1
        bltemp1 = 0.5d0*(BLSOL(N,6)+bltemp39(N))
        bltemp39(N) = BLSOL(N,6)
        BLSOL(N,6) = bltemp1
        bltemp1 = 0.5d0*(BLSOL(N,9)+bltemp42(N))
        bltemp42(N) = BLSOL(N,9)
        BLSOL(N,9) = bltemp1
        bltemp1 = 0.5d0*(BLSOL(N,12)+bltemp45(N))
        bltemp45(N) = BLSOL(N,12)
        BLSOL(N,12) = bltemp1
        bltemp1 = 0.5d0*(BLSOL(N,27)+bltemp60(N))
        bltemp60(N) = BLSOL(N,27)
        BLSOL(N,27) = bltemp1
       end if
  30   continue
       END IF
      end if
      BL(24)=ETOUT
       BL(21)=ETOUT1
      BL(30)=BL(29)/DELT
      BL(15)=BL(3)+BL(9)
      BL(18)=BL(6)+BL(12)
      DO 31 I=2,26,3
      BL(I)=DELT*BL(I+1)
   31 CONTINUE
      BL(19)=BL(19)+BL(20)
      BL(22)=BL(22)+BL(23)
      BL(1)=BL(1)+BL(2)
      BL(4)=BL(4)+BL(5)
      BL(10)=BL(10)+BL(11)
      BL(13)=BL(13)+BL(14)
      BL(7)=BL(7)+BL(8)
      BL(16)=BL(16)+BL(17)
      BL(25)=BL(25)+BL(26)
      BL(28)=BL(28)+BL(29)
      BL(32)=BL(14)+BL(17)+BL(26)-BL(29) + bcmf
      BL(33)=BL(32)/DELT
      BL(31)=BL(31)+BL(32)
      bcmft = bcmft + bcmf
      bcmfr = bcmf/delt
      bl29IT = bl29IT + bl29I
      bl29OT = bl29OT + bl29O
      IF(HEAT) THEN
!
!   TRANSPORT MASS BALANCE COMPONENTS
!
!     BL(94)=BL(94)+BL(95)
      BL(96)=BL(95)/DELT
      BL(87)=BL(69)+BL(75)+BL(81)
      BL(90)=BL(72)+BL(78)+BL(84)
      DO 40 I=68,92,3
      BL(I)=DELT*BL(I+1)
   40 CONTINUE
      BL(82)=BL(82)+BL(83)
      BL(79)=BL(79)+BL(80)
      BL(91)=BL(91)+BL(92)
      BL(94)=BL(94)+BL(95)
      BL(70)=BL(70)+BL(71)
      BL(67)=BL(67)+BL(68)
      BL(76)=BL(76)+BL(77)
      BL(85)=BL(85)+BL(86)
      BL(73)=BL(73)+BL(74)
      BL(88)=BL(88)+BL(89)
      BL(98)=BL(86)+BL(89)+BL(92)-BL(95)+ bcmh
      BL(99)=BL(98)/DELT
      BL(97)=BL(97)+BL(98)
      bcmht = bcmht + bcmh
      bcmhr = bcmh/delt
      bl95IT = bl95IT + bl95I
      bl95OT = bl95OT + bl95O
      bl95T = bl95T
      END IF
      IF(SOLUTE) THEN
!
!   TRANSPORT MASS BALANCE COMPONENTS
!
      do 50 N=1,Nsol
      BLSOL(N,28)=BLSOL(N,28)+BLSOL(N,29)
      BLSOL(N,30)=BLSOL(N,29)/DELT
      BLSOL(N,21)=BLSOL(N,3)+BLSOL(N,9)+BLSOL(N,15)
      BLSOL(N,24)=BLSOL(N,6)+BLSOL(N,12)+BLSOL(N,18)
      DO 41 I=2,26,3
      BLSOL(N,I)=DELT*BLSOL(N,I+1)
   41 CONTINUE
      BLSOL(N,16)=BLSOL(N,16)+BLSOL(N,17)
      BLSOL(N,13)=BLSOL(N,13)+BLSOL(N,14)
      BLSOL(N,25)=BLSOL(N,25)+BLSOL(N,26)
      BLSOL(N,1)=BLSOL(N,1)+BLSOL(N,2)
      BLSOL(N,4)=BLSOL(N,4)+BLSOL(N,5)
      BLSOL(N,10)=BLSOL(N,10)+BLSOL(N,11)
      BLSOL(N,19)=BLSOL(N,19)+BLSOL(N,20)
      BLSOL(N,7)=BLSOL(N,7)+BLSOL(N,8)
      BLSOL(N,22)=BLSOL(N,22)+BLSOL(N,23)
      BLSOL(N,32)=BLSOL(N,20)+BLSOL(N,23)+BLSOL(N,26) &
      -BLSOL(N,29)+ BLSOL(N,35) + bcmt(N)
      BLSOL(N,33)=BLSOL(N,32)/DELT
      BLSOL(N,31)=BLSOL(N,31)+BLSOL(N,32)
      BLSOL(N,36)=BLSOL(N,35)/DELT
      BLSOL(N,34)=BLSOL(N,34)+BLSOL(N,35)
      bcmtt(N) = bcmtt(N) + bcmt(N)
      bcmtr(N) = bcmt(N)/delt
      bl62IT (N)= bl62IT(N) + bl62I(N)
      bl62OT (N)= bl62OT (N)+ bl62O(N)
 50   continue     
      END IF
!
!   WRITE RESULTS TO FILE 9
!
      IF(F9P) then
       if(ktim.eq.1) then
        if(o13p) then
         write(09,4002) ' TIME ',(label9(mb9(im),1), im=1,nmb9)
         write(09,4002) '      ',(label9(mb9(im),2), im=1,nmb9)
         write(09,4002) '      ',(label9(mb9(im),3), im=1,nmb9)
        else
         write(09,4001) ' TIME ',(label9(mb9(im),1), im=1,nmb9)
         write(09,4001) '      ',(label9(mb9(im),2), im=1,nmb9)
         write(09,4001) '      ',(label9(mb9(im),3), im=1,nmb9)
        end if
       end if
       if(.not.o9p.or.jplt.eq.1) then
        do 42 IM = 1,NMB9
         if(dabs(BL(MB9(IM))).lt.elimit1) then
          dum(IM) = elimit2
         else
          dum(IM) = BL(MB9(IM))
         end if
 42      continue
        if(o13p) then
!         WRITE(09,4003) STIM,(BL(MB9(IM)),IM=1,NMB9)
         WRITE(09,4003) STIM,(dum(IM),IM=1,NMB9)
        else
         WRITE(09,4000) STIM,(dum(IM),IM=1,NMB9)
!         WRITE(09,4000) STIM,(BL(MB9(IM)),IM=1,NMB9)
        end if
       end if
      end if
!
!  revision Aug 2008 to print boundary segment fluxes
!
      if(f7p) then
       if (ktim.eq.1) then
	  if (o13p) then
         write (7,4014)
	  else
         write (7,4011)
	  end if
       end if
       do 46 ib1 = 1,numBF
        iflag7 = 0
        do 45 ib2 = 1,numcellsBF(ib1)
         in1 = nodenum(ib1,ib2)
         if(ntyp(in1).eq.1) then
          iflag7 = 1
!          qx = qt(in1)
          if(SOLUTE) then
	       qx = qs(in1)
	      else
	       qx = qt(in1)
          end if
          currentBF(ib1,1) = currentBF(ib1,1) - qx
          if (HEAT) then
           if (qt(in1).lt.0.0) then
            currentBF(ib1,2) = currentBF(ib1,2) - qx*TS(in1)
           else
            currentBF(ib1,2) = currentBF(ib1,2) - qx*TT(in1)
           end if
          end if
         else
          if (ntyp(in1).eq.2.or.ntyp(in1).eq.7) then
           iflag7 = 1
           currentBF(ib1,1) = currentBF(ib1,1) + qq(in1)
           if (HEAT) then
            if (qq(in1).lt.0.0) then
             currentBF(ib1,2) = currentBF(ib1,2) + qq(in1)*TT(in1)
            else
             currentBF(ib1,2) = currentBF(ib1,2) + qq(in1)*TS(in1)
            end if
           end if
          end if
         end if
 45     continue
        bl_flux = currentBF(ib1,1)*delt
        totalBF(ib1,1) = totalBF(ib1,1) + bl_flux
        if(nctyp(in1).eq.1.or.nctyp(in1).eq.2) iflag7 = 1
!
!  revision 10-15-10 for centered in time
!
        if (CIT) then
         if (jflag1.eq.1) then
          bl_mass = currentBF(ib1,2)
          currentBF(ib1,4) = bl_mass
          bl_mass = bl_mass + currentBF(ib1,3)
         else
          bltemp1 = currentBF(ib1,2)
          bl_mass = 0.5*(bltemp1 + currentBF(ib1,4)) + currentBF(ib1,3)
          currentBF(ib1,4) = bltemp1
         end if
        else
         bl_mass = currentBF(ib1,2) + currentBF(ib1,3)
        end if
        bltemp1 = bl_mass*delt
        totalBF(ib1,2) = totalBF(ib1,2) + bltemp1
!
!  end revision 10-15-10
!
!       bl_mass = currentBF(ib1,2)*delt
!        totalBF(ib1,2) = totalBF(ib1,2) + bl_mass
        if((iflag7.eq.1).and.(.not.o9p.or.jplt.eq.1)) then
         if(dabs(totalBF(ib1,1)).lt.elimit1)totalBF(ib1,1)=elimit2
         if(dabs(bl_flux).lt.elimit1) bl_flux = elimit2
         if(dabs(currentBF(ib1,1)).lt.elimit1)currentBF(ib1,1)=elimit2
         if(dabs(bltemp1).lt.elimit1)bltemp1 = elimit2
         if(dabs(bl_mass).lt.elimit1) bl_mass = elimit2
         if(dabs(totalBF(ib1,2)).lt.elimit1)totalBF(ib1,2)=elimit2
        if (o13p) then
         write(7,4013) stim,idBF(ib1),totalBF(ib1,1),bl_flux, &
          currentBF(ib1,1),totalBF(ib1,2),bltemp1,bl_mass
        else
         write(7,4012) stim,idBF(ib1),totalBF(ib1,1),bl_flux, &
          currentBF(ib1,1),totalBF(ib1,2),bltemp1,bl_mass
        end if   
        end if
 46     continue
      end if
!
!  end Aug 2008 revision
!
      IF(.NOT.F6P.AND.JPLT.NE.1.AND.JSTOP.NE.1.AND.JFLAG.NE.1) GO TO 51
!
!    WRITE RESULTS OF MASS BALANCE TO FILE 6
!
      do 47 m = 13,72
       if(dabs(bl(m)).lt.elimit1) bl(m) = elimit2
 47    continue
      WRITE (06,4010) KTIM,KP,STIM,TUNIT,ZUNIT,ZUNIT,ZUNIT,TUNIT,(BL(M),&
      M=1,12)
      WRITE(06,4020) (BL(M),M=13,27),bcmft,bcmf,bcmfr,(bl(m),m=28,33)
      IF(HEAT) WRITE(06,4030) HUNX,HUNX,HUNX,TUNIT,(BL(M),M=67,93),&
      bcmht,bcmh,bcmhr,(BL(M), M=94,99)
      IF(SOLUTE)THEN
      DO 230 N=1,Nsol
      SCOMPNAME(N)=COMPNAME(N)
      WRITE(06,4031)SCOMPNAME(N)
      WRITE(06,4032) CUNX,CUNX,CUNX,TUNIT,(BLSOL(N,I),I=1,27),&
      (BLSOL(N,I),I=34,36),bcmtt(N),bcmt(N),bcmtr(N), &
      (BLSOL(N,I),I=28,33)  
 230  CONTINUE       
      END IF  
      WRITE(06,4040)
   51 CONTINUE
      jflag1 = jflag
      jflag2 = jflag
      RETURN
 4000 FORMAT(1pe14.6,73(1PE11.3))
 4003 FORMAT(1pe18.10,73(1PE21.13))
 4001 format(a14,1X,73a11)
 4002 format(a18,1X,73a21)
 4010 FORMAT(21X,10(1H-),1X,'MASS BALANCE SUMMARY FOR TIME STEP', &
       I9,1X,10(1H-)/25X,'RECHARGE PERIOD NUMBER ',I9/25X, &
      'TOTAL ELAPSED SIMULATION TIME = ',1PE14.6,1X,A4 &
      //2X,128('+')/2X,'+',126X,'+'/ &
      2X,'+',90X,' TOTAL THIS',10X,'RATE THIS',6X,'+'/2X,'+', &
      33X,'VOLUMETRIC FLOW BALANCE', &
      18X,'TOTAL   ',9X,'TIME STEP',11X,' TIME STEP',5X,'+'/ &
      2X,'+',72X,A4,'**3',13X,A4,'**3',11X,A4,'**3/',A4,4X,'+'/ &
      2X,'+',4X,'FLUX INTO DOMAIN ACROSS SPECIFIED PRESSURE HEAD', &
      1X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
      2X,'+',2X,'FLUX OUT OF DOMAIN ACROSS SPECIFIED PRESSURE HEAD', &
      1X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
      2X,'+',13X,'FLUX INTO DOMAIN ACROSS SPECIFIED FLUX BOUNDARIES', &
      1X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
      2X,'+',11X,'FLUX OUT OF DOMAIN ACROSS SPECIFIED FLUX', &
      1X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+')
 4011 FORMAT('     TIME      BNDY    WATER      WATER      WATER', &
      '      SOLUTE     SOLUTE     SOLUTE'/,15X,'FACE     FLUX', &
      '       FLUX       FLUX       FLUX       FLUX       FLUX',/ &
      23X,'TOTAL      TIME STEP   RATE      TOTAL      TIME STEP', &
      '   RATE')
 4012 FORMAT(1pe14.6,i6,73(1PE11.3))
 4013 FORMAT(1pe18.10,i6,73(1PE21.13))
 4014 FORMAT(5x,'TIME',11x,'BNDY',4x,3('WATER',16x),1x,3('HEAT',17x),/ &
      20x,'FACE',5x,6('FLUX',17x),/,28x,2('TOTAL',16x,'TIME STEP',13x,'RATE',16x))
 4020 FORMAT(1H ,1X,'+',40X,'TOTAL FLUX INTO DOMAIN --  ',2(1PE15.5,5X), &
       1PE15.5,4X,'+'/2X,'+',38X,'TOTAL FLUX OUT OF DOMAIN --  ', &
      2(1PE15.5,5X),1PE15.5,4X,'+'/ &
      2X,'+',51X,'EVAPORATION --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &  
      2X,'+',49X,'TRANSPIRATION --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/  &
      2X,'+',38X,'TOTAL EVAPOTRANSPIRATION', &
      1X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
      2X,'+',30X,'      FLUID FROM BOUNDARY CHANGE --  ', &
      2(1PE15.5,5X),1PE15.5,4X,'+'/ &
     2X,'+',30X,'CHANGE IN FLUID STORED IN DOMAIN --  ', &
      2(1PE15.5,5X),1PE15.5,4X,'+'/2X,'+',42X,'FLUID VOLUME BALANCE' &
      ,1X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/2X,'+',126X,'+')
 4030 FORMAT(2X,'+',126X,'+',/,2X,'+',35X,'ENERGY MASS BALANCE', &
      72X,'+',/,2X,'+',74X,A4,16X,A4,14X,A4,'/',A4,5X,'+',/, &
      2X,'+',4X,'FLUX INTO DOMAIN ACROSS SPECIFIED PRESSURE HEAD', & 
      1X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
      2X,'+',2X,'FLUX OUT OF DOMAIN ACROSS SPECIFIED PRESSURE HEAD', &
      1X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
      2X,'+',13X,'FLUX INTO DOMAIN ACROSS SPECIFIED FLUX BOUNDARIES', &
      1X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
      2X,'+',11X,'FLUX OUT OF DOMAIN ACROSS SPECIFIED FLUX', &
      1X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ , &
      2X,'+',25X,'          CONDUCTIVE FLUX INTO DOMAIN --  ', &
      2(1PE15.5,5X),1PE15.5,4X,'+'/2X, &
      '+',23X,'          CONDUCTIVE FLUX OUT OF DOMAIN --  ', &
      2(1PE15.5,5X),1PE15.5,4X,'+'/, &
      1H ,1X,'+',40X,'TOTAL FLUX INTO DOMAIN --  ',2(1PE15.5,5X), &
       1PE15.5,4X,'+'/2X,'+',38X,'TOTAL FLUX OUT OF DOMAIN --  ', &
      2(1PE15.5,5X),1PE15.5,4X,'+'/ &
      2X,'+',38X,'TOTAL EVAPOTRANSPIRATION', &
      1X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
      '  +',35X,'ENERGY FROM BOUNDARY CHANGE', &
      ' --',1PE17.5,2(1PE20.5),4X,'+'/ &
      2X,'+',29X,'CHANGE IN ENERGY STORED IN DOMAIN --  ', &
      2(1PE15.5,5X),1PE15.5,4X,'+'/2X,'+',43X,'ENERGY MASS BALANCE' &
      ,1X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/2X,'+',126X,'+') 
 4031 FORMAT(A10)       
 4032 FORMAT(2X,'+',126X,'+',/,2X,'+',35X,'SOLUTE MASS BALANCE', & 
      72X,'+',/,2X,'+',74X,A4,16X,A4,14X,A4,'/',A4,5X,'+',/, &
      2X,'+',4X,'FLUX INTO DOMAIN ACROSS SPECIFIED PRESSURE HEAD', &
      1X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
      2X,'+',2X,'FLUX OUT OF DOMAIN ACROSS SPECIFIED PRESSURE HEAD' &
      1X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
      2x,'+',13X,'FLUX INTO DOMAIN ACROSS SPECIFIED FLUX BOUNDARIES --' &
      ,'  ', &
      2(1PE15.5,5X),1PE15.5,4x,'+',/,2X,'+',11X, &
      'FLUX OUT OF DOMAIN ACROSS SPECIFIED FLUX BOUNDARIES --  ', &
      2(1PE15.5,5X),1PE15.5,4X,'+'/,2X,'+',25X, &
      'DIFFUSIVE/DISPERSIVE FLUX INTO DOMAIN --  ',2(1PE15.5,5X),1PE15.5 &
      ,4X,'+'/2X,'+',23X,'DIFFUSIVE/DISPERSIVE FLUX OUT OF DOMAIN --', &
      1PE17.5,2(1PE20.5),4X,'+'/'  +',40X,'TOTAL FLUX INTO DOMAIN --', & 
      1PE17.5,2(1PE20.5),4X,'+'/'  +',38X,'TOTAL FLUX OUT OF DOMAIN --', &
      1PE17.5,2(1PE20.5),4X,'+'/'  +',38X,'TOTAL EVAPOTRANSPIRATION --', &
      1PE17.5,2(1PE20.5),4X,'+'/'  +',21X,'CHANGE IN SOLUTE DUE TO', &
      1x,'CHEMICAL REACTION --', &
      1PE17.5,2(1PE20.5),4X,'+'/'  +',35X,'SOLUTE FROM BOUNDARY CHANGE', &
      ' --',1PE17.5,2(1PE20.5),4X,'+'/ &
      '  +',29X,'CHANGE IN SOLUTE STORED IN', &
      ' DOMAIN --',1PE17.5,2(1PE20.5),4X,'+'/'  +',43X, &
      'SOLUTE MASS BALANCE --',1PE17.5,2(1PE20.5),4X,'+'/'  +',126X,'+')
 4040 FORMAT( 2X,128('+'))
      END
      DOUBLE PRECISION FUNCTION VSFLX1(IN)
!******
!VSFLX1
!******
!   PURPOSE: TO COMPUTE INTERCELL MASS FLUX RATES FOR DIRICHLET
!   BOUNDARY NODES
! ----------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use kcon
      use press
      use hcon
      use equat
      use temp
      use pit
      use isdumm
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      COMMON/WGT/WUS,WDS
      LOGICAL HEAT,SOLUTE,FLOW
      COMMON/TRANSTYPE/HEAT,SOLUTE
!----------------------------------------------------------------------
!
!
!   COMPUTE FLUXES ON ALL FOUR SIDES OF EACH CONSTANT HEAD NODE
!
      JM1=IN-1
      JP1=IN+1
      NP1=IN+NLY
      NM1=IN-NLY
!
!   COMPUTE A,B,C,D
!
      IF(WUS.EQ.0.0D0) THEN
      IF(HEAT)THEN
      A1=HKLL(IN)*DSQRT(HCND(NM1)*RHO(NM1)*HCND(IN)*RHO(IN))
      B1=HKTT(IN)*DSQRT(HCND(JM1)*RHO(JM1)*HCND(IN)*RHO(IN))
      C1=HKLL(NP1)*DSQRT(HCND(NP1)*RHO(NP1)*HCND(IN)*RHO(IN))
      D1=HKTT(JP1)*DSQRT(HCND(JP1)*RHO(JP1)*HCND(IN)*RHO(IN))
      ELSE  
      A1=HKLL(IN)*DSQRT(HCND(NM1)*HCND(IN))
      B1=HKTT(IN)*DSQRT(HCND(JM1)*HCND(IN))
      C1=HKLL(NP1)*DSQRT(HCND(NP1)*HCND(IN))
      D1=HKTT(JP1)*DSQRT(HCND(JP1)*HCND(IN))
      END IF
      ELSE
      IF(P(NM1).GT.P(IN).AND.HX(NM1).NE.0.0D0) THEN
      ALA=WUS
      BTA=WDS
      ELSE
      ALA=WDS
      BTA=WUS
      END IF
      IF(P(JM1).GT.P(IN).AND.HX(JM1).NE.0.0D0) THEN
      ALB=WUS
      BTB=WDS
      ELSE
      ALB=WDS
      BTB=WUS
      END IF
      IF(P(NP1).GT.P(IN).AND.HX(NP1).NE.0.0D0) THEN
      ALC=WUS
      BTC=WDS
      ELSE
      ALC=WDS
      BTC=WUS
      END IF
      IF(P(JP1).GT.P(IN).AND.HX(JP1).NE.0.0D0) THEN
      ALD=WUS
      BTD=WDS
      ELSE
      ALD=WDS
      BTD=WUS
      END IF
     
!
!   DETERMINE FLUXES
!     
      IF(HEAT)THEN
      A1=(ALA*HCND(NM1)*RHO(NM1)+BTA*HCND(IN)*RHO(IN))*HKLL(IN)
      B1=(ALB*HCND(JM1)*RHO(JM1)+BTB*HCND(IN)*RHO(IN))*HKTT(IN)
      C1=(ALC*HCND(NP1)*RHO(NP1)+BTC*HCND(IN)*RHO(IN))*HKLL(NP1)
      D1=(ALD*HCND(JP1)*RHO(JP1)+BTD*HCND(IN)*RHO(IN))*HKTT(JP1)
      ELSE  
      A1=(ALA*HCND(NM1)+BTA*HCND(IN))*HKLL(IN)
      B1=(ALB*HCND(JM1)+BTB*HCND(IN))*HKTT(IN)
      C1=(ALC*HCND(NP1)+BTC*HCND(IN))*HKLL(NP1)
      D1=(ALD*HCND(JP1)+BTD*HCND(IN))*HKTT(JP1)
      END IF
      END IF
      
      if(ntyp(in).eq.1) then
       if(ntyp(nm1).eq.1) a1 = 0.0d0
       if(ntyp(jm1).eq.1) b1 = 0.0d0
       if(ntyp(np1).eq.1) c1 = 0.0d0
       if(ntyp(jp1).eq.1) d1 = 0.0d0
      end if
      QL=-A1*(P(IN)-P(NM1))
      QA=-B1*(P(IN)-P(JM1))
      QR=-C1*(P(IN)-P(NP1))
      QB=-D1*(P(IN)-P(JP1))
!
!    COMPUTE NET FLUX IN (+) OR OUT (-)
!
      VSFLX1=QL+QR+QA+QB
      RETURN
      END FUNCTION VSFLX1
      SUBROUTINE VSOUTP
!*****
!VSOUTP
!******
!
!   PURPOSE: TO OUTPUT RESULTS AFTER EACH TIME STEP.
!
!-----------------------------------------------------------------------
!
!        SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use rspac
      use kcon
      use mprop
      use press
      use jtxx
      use dumm
      use dumm3
      use trxx
      use trxxh
      use trxv
      use plott
      use rpropsh
      use scon
      use disch
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      COMMON/JCON/JSTOP,JFLAG,jflag1
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
      F14P,F15P,F16P,F17P,F18P,F19P
      LOGICAL THPT,SPNT,PPNT,HPNT,VPNT
      COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
      F14P,F15P,F16P,F17P,F18P,F19P
      COMMON/LOG4/THPT,SPNT,PPNT,HPNT,VPNT
      CHARACTER*80 TITL
      CHARACTER*6 ZUNIT,CUNX,HUNX
      CHARACTER*7 TUNIT
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX
      common/elimit/elimit1,elimit2
      LOGICAL HEAT,SOLUTE
      COMMON/TRANSTYPE/HEAT,SOLUTE
      COMMON/TCON1/NIS,NIS1,NIS3
     
!-------------------------------------------------------------------
!
!   OUTPUT RESULTS TO FILE 11 AT EACH TIME STEP
!
      IF(JSTOP.GT.1) RETURN
      if(.not.o11p.or.jplt.eq.1) then
      IF(F11P) THEN
      IF(.not.(TRANS.OR.VPNT).AND..NOT.SSTATE) CALL VTVELO
        
      DO 10 J=1,NOBS
      N=IJOBS(J)
      I=N/NLY+1
      J1=MOD(N,NLY)
      IF(HX(N).NE.0.0D0) THEN
       if(dabs(p(n)).lt.elimit1) p(n) = elimit2
         IF(HEAT)THEN
            if(dabs(TT(n)).lt.elimit1) TT(n) = elimit2
         END IF
         IF(SOLUTE)THEN
          DO 11 M=1,Nsol
           if(dabs(cc(M,n)).lt.elimit1) cc(M,n) = elimit2  
  11      continue          
         END IF  
       if(dabs(vx(n)).lt.elimit1) vx(n) = elimit2
       if(dabs(vz(n)).lt.elimit1) vz(n) = elimit2
       if(dabs(q(n)).lt.elimit1) q(n) = elimit2
      PPR=HK(JTEX(N),3)
      IF(PPR.EQ.0.0D0)PPR=1.0D0
      SAT=THETA(N)/PPR
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J1)
      ELSE
      Z1=DZZ(J1)*CS1+RX(I)*CS2
      END IF
      PHD=P(N)+Z1
      if (o13p) then
      IF(HEAT.AND.SOLUTE) THEN
      WRITE(11,4021) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT,TT(N), &
      vx(n),vz(n),q(n),(CC(M,N),M=1,Nsol)
      else if(HEAT.AND.(.NOT.SOLUTE))then 
      WRITE(11,4021) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT,TT(N), &
      vx(n),vz(n),q(n)
      else if((.NOT.HEAT).AND.SOLUTE)then  
      WRITE(11,4021) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT, &
      vx(n),vz(n),q(n),(CC(M,N),M=1,Nsol)
      ELSE
      WRITE (11,4021) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT, &
       vx(n),vz(n),q(n)
      END IF
      else
      IF(HEAT.AND.SOLUTE) THEN
      WRITE(11,4020) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT,TT(N), &
      vx(n),vz(n),q(n),(CC(M,N),M=1,Nsol)
      else if(HEAT.AND.(.NOT.SOLUTE))then 
      WRITE(11,4020) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT,TT(N), &
      vx(n),vz(n),q(n)
      else if((.NOT.HEAT).AND.SOLUTE)then 
      WRITE(11,4020) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT, &
      vx(n),vz(n),q(n),(CC(M,N),M=1,Nsol)
      ELSE
      WRITE (11,4020) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT, &
       vx(n),vz(n),q(n)
      END IF
      end if
      END IF
   10 CONTINUE
      end if
      END IF
      IF(KTIM.EQ.0)  GO TO 20
!
!    WRITE TIME STEP HEADER TO FILE 6
!
!    WRITE MAXIMUM HEAD CHANGE EACH TIME STEP TO FILE 7
!
!      IF(F7P) THEN
!      WRITE(07,4040) KTIM,STIM,NIT,NIT1,NIS1
!     WRITE(07,4030) (DHMX(M2),M2=1,NIT)
!      END IF
      WRITE(06,4040) KTIM,STIM,NIT,NIT1,NIT3,NIS1
      IF(JSTOP.EQ.1.OR.JPLT.EQ.1) GO TO 20
      IF(.NOT.PRNT.AND.JFLAG.EQ.0) RETURN
   20 WRITE (6,4050) TITL,STIM,TUNIT,KTIM
!
!    PRINT SOLUTION FOR CURRENT TIME STEP
!
      IF(JPLT.EQ.1) THEN
!     if (f8p) then
!
!   WRITE PRESSURE HEADS TO FILE 8 AT OBSERVATION TIMES.
!
      WRITE (8,4000) STIM,TUNIT
!       if (o12p) then
!      if (heat.and.solute) then
!       write (12) stim, p, tt,cc
 !      else if(heat.and.(.not.solute))then
 !      write (12) stim, p, tt
 !      else if((.not.heat).and.solute)then
 !        write (12) stim, p,cc
 !     else
 !      write (12) stim, p
 !     end if
 !     end if 
      DO 40 J=1,NLY
      DO 30 N=1,NXR
      IN=NLY*(N-1)+J
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      DUM(IN)=P(IN)+Z1
      if(dabs(dum(in)).lt.elimit1) dum(in) = elimit2
 30   continue
      if(o13p) then
       WRITE(8,4011) (DUM(N),N=J,NNODES-NLY+J,NLY)
      else
       WRITE(8,4010) (DUM(N),N=J,NNODES-NLY+J,NLY)
      end if
 40   continue
!
!  WRITE TEMPERATURE TO FILE 8
!
      IF(HEAT) THEN
      DO 50 J=1,NLY
      do 45 N=1,NXR
      IN = NLY*(N-1)+J
      DUM(IN) = TT(IN)
      if(dabs(dum(in)).lt.elimit1) dum(in) = elimit2
 45   continue
      if (o13p) then
       WRITE(08,4011) (DUM(N),N=J,NNODES-NLY+J,NLY)
      else
       WRITE(08,4010) (DUM(N),N=J,NNODES-NLY+J,NLY)
      end if
  50  CONTINUE
      END IF
!      end if
      
!
!  WRITE CONCENTRATION TO FILE 8
!
!      IF(SOLUTE) THEN
!      use dumm3Alloc
!     DO 51 J=1,NLY   
!      do 46 N=1,NXR
!      IN = NLY*(N-1)+J
!      DO 43 M=1,Nsol  
!      DUM3(M,IN)= CC(M,IN)
!      if(dabs(DUM3(M,IN)).lt.elimit1) DUM3(M,IN) = elimit2
! 43   continue       
! 46   continue
! 51   continue
!      do 52, K=1,NLY 
!      do 52, M=1,Nsol  
!      if (o13p) then  
!       WRITE(08,4011) (DUM3(M,N),N=K,NNODES-NLY+K,NLY)
!      else
!       WRITE(08,4010) (DUM3(M,N),N=K,NNODES-NLY+K,NLY)
!     end if
!52  CONTINUE 
!     use dumm3Dealloc    
!      END IF
      END IF
!      end if     
!
!    PRINT TOTAL HEADS
!
      IF(HPNT) THEN
      WRITE (6,4060)
      CALL VSOUT(1,P)
      END IF
!
!  PRINT PRESSURE HEADS
!
      IF(PPNT) THEN
!      IF(JPLT.NE.1.or..not.f8p) THEN
      DO 60 J=2,NLYY
      DO 60 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      DUM(IN)=P(IN)+Z1
      IF(HX(IN).EQ.0.0D0)DUM(IN)=0.0D0
      THEAD(IN)=DUM(IN)
   60 CONTINUE
!      END IF
      WRITE (6,4070)
      CALL VSOUT(1,DUM)
      END IF
!
!  PRINT SATURATIONS
!
      IF(SPNT) THEN
      DO 70 J=2,NLYY
      DO 70 N=2,NXRR
      IN=NLY*(N-1)+J
      TTX=HK(JTEX(IN),3)
      IF(TTX.EQ.0.0D0) THEN
      DUM(IN)=0.0D0
      ELSE
      DUM(IN)=THETA(IN)/TTX
      END IF
      SATUR(IN)=DUM(IN)
   70 CONTINUE
      WRITE (6,4080)
      CALL VSOUT(2,SATUR)
      END IF
!
!  PRINT MOISTURE CONTENTS
!
      IF(THPT) THEN
      WRITE (6,4090)
      CALL VSOUT(2,THETA)
      END IF
!
!  PRINT VELOCITIES
!
      IF(VPNT.AND.KTIM.GT.0) THEN
      if(nxr.gt.3) then
       WRITE(06,4100)
       CALL VSOUT(1,VX)
      end if
      if(nly.gt.3) then
       WRITE(06,4110)
       CALL VSOUT(1,VZ)
      end if
      END IF
!
!  PRINT temperature
!
      IF(HEAT) THEN
      WRITE(6,4120)
      CALL VSOUT(2,TT)
      END IF
!
!  PRINT CONCENTRATIONS
!
      IF(SOLUTE) THEN
      WRITE(6,4121)
      CALL VSOUTS(1,CC)
      END IF      
      CONTINUE
      RETURN
 4000 FORMAT(/,8H TIME = ,E15.6,1X,A4/)
 4010 FORMAT(99999(1PE15.7))
 4011 FORMAT(99999(1PE21.13))
 4020 FORMAT(1pe14.6,1x,i8,2x,100(1x,1PE12.5))
 4021 FORMAT(1pe18.10,1x,i8,2x,100(1PE21.13))
!
!following change made 6/29/09 for Marie S to print
!  3 digits in exponent
!
! 4020 FORMAT(1pe14.6,1x,i8,2x,12(1x,1PE12.4E3))
! 4021 FORMAT(1pe18.10,1x,i8,2x,12(1PE21.12E3))
 4030 FORMAT(7E11.4)
 4040 FORMAT(' TIME STEP ',I9,'  TIME = ',E14.6,'  NIT = ',I5, &
     '  NIT1 = ',I5,'  NIT3 = ',I5,'  NIS1 = ',I5)
 4050 FORMAT(6X,A80/5X,20HTOTAL ELAPSED TIME =,1PE14.6,1X,A4/5X, &
      10HTIME STEP ,I9,//)
 4060 FORMAT(1H ,50X,10HTOTAL HEAD)
 4070 FORMAT(1H ,50X,13HPRESSURE HEAD)
 4080 FORMAT(1H ,50X,10HSATURATION)
 4090 FORMAT(1H ,50X,16HMOISTURE CONTENT)
 4100 FORMAT(51X,'X-VELOCITY')
 4110 FORMAT(51X,'Z-VELOCITY')
 4120 FORMAT(51X,'TEMPERATURE')
 4121 FORMAT(51X,'CONCENTRATION')
      END
      SUBROUTINE VSOUT(IV,VPRNT)
!*****
!VSOUT
!*****
!
!    PURPOSE: TO PRINT TWO DIMENSIONAL ARRAYS
!
!-----------------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
!
      use press
      use rspac
      use kcon
      use dumm1
      use trxxh
      use trxv
      use mprop
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      CHARACTER*80 TITL
      CHARACTER*6 ZUNIT,CUNX,HUNX
      CHARACTER*7 TUNIT 
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX 
      common/elimit/elimit1,elimit2
      LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
      F14P,F15P,F16P,F17P,F18P,F19P
      COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,  &
      o13p,F14P,F15P,F16P,F17P,F18P,F19P
      LOGICAL THPT,SPNT,PPNT,HPNT,VPNT
      COMMON/LOG4/THPT,SPNT,PPNT,HPNT,VPNT
      DIMENSION VPRNT(1)
!
!-------------------------------------------------------------------
!
      !!@@include 'd_dumm1Alloc.inc'
      allocate(DUM1(NNODES))
      WRITE (06,4000) ZUNIT,ZUNIT
      WRITE (06,4010)(RX(K),K=2,NXRR)
      DO 30 J=2,NLYY
      DO 10 N=2,NXRR
!      IN=NLY*(N)-(J-1)
      IN=NLY*(N-1)+J
      DUM1(N)=VPRNT(IN)
      IF(HX(IN).EQ.0.0D0) DUM1(N)=0.0D0
      if(dabs(dum1(n)).lt.elimit1) dum1(n) = elimit2
   10 CONTINUE
      IF(IV.GT.1) GO TO 20
      WRITE (06,4020) DZZ(J),(DUM1(N),N=2,NXRR)
!      IF((VPRNT(IN).EQ.VX(IN)).OR.(VPRNT(IN).EQ.VZ(IN)))THEN
!      IF(J.EQ.2)WRITE (17,*) 
!      WRITE (17,4021) (DUM1(N),N=2,NXRR)
!      END IF
!      IF(VPRNT(IN).EQ.TT(IN))THEN
!      IF(J.EQ.2)WRITE (16,*)  
!      WRITE (16,4021) (DUM1(N),N=2,NXRR)
!      END IF 
!      IF(VPRNT(IN).EQ.THETA(IN))THEN
!      IF(J.EQ.2)WRITE (18,*)  
!      WRITE (18,4021) (DUM1(N),N=2,NXRR)
!      END IF
!      IF((VPRNT(IN).EQ.P(IN)).OR.(VPRNT(IN).EQ.THEAD(IN)))THEN
!      IF(J.EQ.2)WRITE (14,*)  
!      WRITE (14,4021) (DUM1(N),N=2,NXRR) 
!      END IF
!      IF(VPRNT(IN).EQ.SATUR(IN)) THEN
!      IF(J.EQ.2)WRITE (19,*)  
!      WRITE (19,4021) (DUM1(N),N=2,NXRR) 
!      END IF  
      GO TO 30
   20 WRITE (06,4030) DZZ(J),(DUM1(N),N=2,NXRR)
!      IF((VPRNT(IN).EQ.VX(IN)).OR.(VPRNT(IN).EQ.VZ(IN)))THEN
!      IF(J.EQ.2)WRITE (17,*)  
!      WRITE (17,4031) (DUM1(N),N=2,NXRR)
!      END IF
!      IF(VPRNT(IN).EQ.TT(IN))THEN
!      IF(J.EQ.2)WRITE (16,*) 
!      WRITE (16,4031) (DUM1(N),N=2,NXRR) 
!      END IF
!      IF(VPRNT(IN).EQ.THETA(IN))THEN
!      IF(J.EQ.2)WRITE (18,*)  
!      WRITE (18,4021) (DUM1(N),N=2,NXRR)
!      END IF
!      IF((VPRNT(IN).EQ.P(IN)).OR.(VPRNT(IN).EQ.THEAD(IN)))THEN
!      IF(J.EQ.2)WRITE (14,*)  
!      WRITE (14,4031) (DUM1(N),N=2,NXRR) 
!      END IF
!      IF(VPRNT(IN).EQ.SATUR(IN))THEN
!      IF(J.EQ.2)WRITE (19,*)  
!      WRITE (19,4031) (DUM1(N),N=2,NXRR)   
!      END IF  
   30 CONTINUE
      !!@@include 'd_dumm1Dealloc.inc'
      deallocate(DUM1)
      RETURN
 4000 FORMAT(1H ,1X,5HZ, IN/2X,A4,20X,20HX OR R DISTANCE, IN ,A4)
 4010 FORMAT(1H ,9X,99999(F11.3)/(9X,13(F9.2)))
 4020 FORMAT(1X,F9.3,99999(1X,1PE10.3)/(9X,13(1PE9.2)))
 4021 FORMAT(1X,99999(1X,1PE10.3)/(9X,13(1PE9.2)))
 4030 FORMAT(1X,F9.3,99999(1X,F10.4)/(9X,13F9.3))
 4031 FORMAT(1X,99999(1X,F10.4)/(9X,13F9.3))
      END
      SUBROUTINE VSOUTS(IV,VPRNTS)
!XXXXXXXXXXXXXXXXXXXXXXXXX
!
!VSOUTS
!******
!      PURPOSE: TO PRINT TWO DIMENSIONAL ARRAY
!-------------------------------------------------------
!
      use rspac
      use kcon
      use dumm2
      use compnam
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      CHARACTER*80 TITL
      CHARACTER*6 ZUNIT,CUNX,HUNX
      CHARACTER*7 TUNIT 
      CHARACTER*10 SCOMPNAME(50)
      COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX 
      common/elimit/elimit1,elimit2
      LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
      F14P,F15P,F16P,F17P,F18P,F19P
      COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,  &
      o13p,F14P,F15P,F16P,F17P,F18P,F19P
      DIMENSION VPRNTS(Nsol,NNODES)
      !!@@include 'd_dumm2Alloc.inc'
      allocate(DUM2(Nsol,NNODES))
!-----------------------------------------------------------------      
      WRITE (06,4000) ZUNIT,ZUNIT 
      WRITE (06,4010) (RX(K),K=2,NXRR) 
      DO 30 M=1,Nsol
      SCOMPNAME(M)=COMPNAME(M)  
      DO 30 J=2,NLYY
      DO 10 N=2,NXRR 
!      IN=NLY*(N)-(J-1)
      IN=NLY*(N-1)+J
      DUM2(M,N)=VPRNTS(M,IN) 
      IF(HX(IN).EQ.0.0D0) DUM2(M,N)=0.d0 
   10 CONTINUE 
      IF(IV.GT.1) GO TO 20 
      IF(J.EQ.2) then
        WRITE (06,4001)SCOMPNAME(M)
!        WRITE (15,*)
      end if
      WRITE (06,4020) DZZ(J),(DUM2(M,N),N=2,NXRR)
!      WRITE (15,4021)(DUM2(M,K),K=2,NXRR) 
      GO TO 30 
   20 CONTINUE
      IF(J.EQ.2) then
      WRITE (06,4001) COMPNAME(M)
!      WRITE (15,*)
      end if
      WRITE (06,4030) DZZ(J),(DUM2(M,N),N=2,NXRR)
!      WRITE (15,4031)(DUM2(M,K),K=2,NXRR) 
   30 CONTINUE 
      !!@@include 'd_dumm2Dealloc.inc'
      deallocate(DUM2)
      return
 4000 FORMAT(1H ,1X,5HZ, IN/2X,A4,20X,20HX OR R DISTANCE, IN ,A4) 
 4001 FORMAT(A10)
 4010 FORMAT(1H ,8X,99999(F9.2)/(9X,13(F9.2))) 
 4020 FORMAT(1X,F8.2,99999(1PE9.2)/(9X,13(1PE9.2))) 
 4021 FORMAT(1X,99999(1PE9.2)/(9X,13(1PE9.2))) 
 4030 FORMAT(1X,F8.2,99999(F9.3)/(9X,13F9.3)) 
 4031 FORMAT(1X,99999(F9.3)/(9X,13F9.3))
      END      
      SUBROUTINE VSPOND(IFET,IFET1,IFET2)
!******
!CVSPOND
!******
!
!  UPDATED 10-88
!
!   PURPOSE:  TO DETERMINE IF PONDING OR UNPONDING HAS OCCURRED, AND
!             IF SO TO CHANGE BOUNDARY CONDITIONS AT THOSE NODES FROM
!              NEUMAN TO DIRICHLET OR VICE VERSA
!
! ----------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use rspac
      use kcon
      use press
      use disch
      use equat
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      COMMON/PND/POND
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      COMMON/TCON1/NIS,NIS1,NIS3
!
!--------------------------------------------------------------------
!
!   IFET1 INDICATES WHETHER THERE ARE ANY NEUMAN BOUNDARIES REMAINING
!   IFET2 INDICATES WHETHER ANY SPECIFIC FLUX NODES HAVE BEEN CONVERTED
!     TO SPECIFIED HEAD NODES.  BECAUSE OF THE CAPILLARY BARRIER
!     EFFECT, THESE NODES MAY NEED TO REVERT TO SPECIFIED FLUX NODES.
!   IFET INDICATES WHETHER PONDING OCCURRED OR DISAPPEARED
!
      IF(IFET1.EQ.0 .AND. IFET2 .EQ. 0) RETURN
      IFET=0
      IFET1=0
      IFET2=0
      IF(CS1.EQ.1.0D0) THEN
      DZ1=DZZ(2)
      ELSE
      IF(CS2.LT.0.0D0) THEN
      DZ1=DZZ(2)*CS1+RX(NXRR)*CS2
      ELSE
      DZ1=DZZ(2)*CS1+RX(2)*CS2
      END IF
      END IF
      DO 20 I=2,NXRR
      DO 10 J=2,NLYY
      IN=NLY*(I-1)+J
      IF(HX(IN).NE.0.0D0) THEN
      IF(NTYP(IN).EQ.2.AND.QQ(IN).GT.0.0D0) THEN
      IFET1=1
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(I)*CS2
      END IF
      IF(POND.GE.0.0D0) THEN
!
!    DZ2 IS MAXIMUM ALLOWABLE TOTAL HEAD
!
      DZ2=POND-Z1
      ELSE
      DZ2=-DMIN1(Z1,DZ1-POND)
      END IF
      IF(P(IN).GT.DZ2) THEN
!
!   IF COMPUTED HEAD EXCEEDS MAXIMUM THEN SET P=DZ2
!    AND CHANGE BOUNDARY TYPE TO CONSTANT HEAD
!
      P(IN)=DZ2
      NTYP(IN)=1
      IFET=1
      IFET2=1
      WRITE(6,4000) J,I,KTIM,NIT
      END IF
      ELSE
      IF(NTYP(IN).EQ.1.AND.QQ(IN).GT.0.0D0) THEN
      IFET2=1
!
!  change 6/09 to prevent reconverting if p is not less
!   than DZ2
!
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(I)*CS2
      END IF
      IF(POND.GE.0.0D0) THEN
!
!    DZ2 IS MAXIMUM ALLOWABLE TOTAL HEAD
!
      DZ2=POND-Z1
      ELSE
      DZ2=-DMIN1(Z1,DZ1-POND)
      END IF
      if (p(in).lt.DZ2) then
!
!  end 6/09 change
!
      JP1=IN+1
      IM1=IN+NLY
      IP1=IN-NLY
      TEST=(P(IN)-P(JP1))*D(IN)
      IF(HX(IM1).NE.0.0D0) TEST=TEST+(P(IN)-P(IM1))*C(IN)
      IF(HX(IP1).NE.0.0D0) TEST=TEST+(P(IN)-P(IP1))*A(IN)
      TEST=TEST/QQ(IN)
      IF (TEST .GE. 1.01D0)THEN
!
!  IF FLUX FROM THE CONVERTED NODE IS GREATER THAN THE SPECIFIED
!  FLUX RATE, THE NODE IS RECONVERTED TO A SPECIFIED FLUX NODE.
!
      NTYP(IN)=2
      IFET=1
      IFET1=1
      WRITE(06,4010)J,I,KTIM,NIT
      END IF
      end if
      END IF
      END IF
      GO TO 20
      END IF
   10 CONTINUE
   20 CONTINUE
      RETURN
 4000 FORMAT(//,6X,17H PONDING AT NODE ,2I5,17H DURING TIME STEP, &
      I9,'  ITERATION ',I5)
 4010 FORMAT(//,6X,' PONDING ENDED AT NODE ',2I5, &
     ' DURING TIME STEP ',I9,'  ITERATION ',I5)
      END
      SUBROUTINE VSSFAC
!******
!VSSFAC
!******
!
!  REVISED 10-88
!
!    PURPOSE:  TO COMPUTE POSITION OF SEEPAGE FACE BOUNDARIES
!
!     HEIGHT OF SEEPAGE FACE IS LOWERED IF THERE IS FLUX INTO SYSTEM
!     THRU FACE.
!    HEIGHT IS RAISED IF PRESSURE HEADS ARE POSITIVE ABOVE FACE.
!
! ----------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use rspac
      use kcon
      use press
      use spfc
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
!
!-------------------------------------------------------------------
!
      DO 90 K=1,NFCS
      NFX=NFC(K)
      JFST=0
      JLST=JLAST(K)
!
!   CHECK FOR POSITIVE PRESSURES ABOVE SEEPAGE FACE
!
      DO 10 J=NFX,1,-1
      IN=JSPX(1,J,K)
      JJ=JSPX(2,J,K)
      NN=JSPX(3,J,K)
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(JJ)
      ELSE
      Z1=DZZ(JJ)*CS1+RX(NN)*CS2
      END IF
      PTMP=P(IN)+Z1
      IF(PTMP.LT.0.0D0) GO TO 10
      JFST=J
      GO TO 20
   10 CONTINUE
   20 CONTINUE
!
!   CHECK FOR FLOW INTO DOMAIN THROUGH SEEPAGE FACE
!
      IF(JFST.GT.JLST) GO TO 60
      DO 40 I=JLST,1,-1
      IN=JSPX(1,I,K)
      IM1=IN-NLY
      JM1=IN-1
      IP1=IN+NLY
      JP1=IN+1
      IF(HX(IM1).EQ.0.0D0) THEN
      IF(HX(IP1).NE.0.0D0.AND.P(IP1).LT.P(IN)) GO TO 30
      END IF
      IF(HX(JM1).EQ.0.0D0) THEN
      IF(HX(JP1).NE.0.0D0.AND.P(JP1).LT.P(IN)) GO TO 30
      END IF
      IF(HX(IP1).EQ.0.0D0) THEN
      IF(HX(IM1).NE.0.0D0.AND.P(IM1).LT.P(IN)) GO TO 30
      END IF
      IF(HX(JP1).EQ.0.0D0) THEN
      IF(HX(JM1).NE.0.0D0.AND.P(JM1).LT.P(IN)) GO TO 30
      END IF
      GO TO 50
   30 NTYP(IN)=3
   40 CONTINUE
      I=0
   50 IF(I.EQ.JLST) GO TO 60
!
!   RESET SEEPAGE FACE HEIGHT AND BOUNDARIES
!
      JLAST(K)=I
      GO TO 80
   60 IF(JFST.EQ.JLST) GO TO 80
      DO 70 I=1,JFST
      IN=JSPX(1,I,K)
      JJ=JSPX(2,I,K)
      NN=JSPX(3,I,K)
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(JJ)
      ELSE
      Z1=DZZ(JJ)*CS1+RX(NN)*CS2
      END IF
      NTYP(IN)=1
      P(IN)=-Z1
   70 CONTINUE
      JLAST(K)=JFST
   80 CONTINUE
   90 CONTINUE
      END
      SUBROUTINE VSEVAP
!******
!VSEVAP
!******
!
!  PURPOSE: TO COMPUTE SURFACE EVAPORATION RATES
!
!
!------------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use rspac
      use kcon
      use hcon
      use press
      use disch
      use ptet
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
!
!-----------------------------------------------------------------
!
      ETOUT1=0.0D0
      do 6 i = nly,nnodes
      q(i) = 0.0d0
 6    continue
      IF(SRES.EQ.0.0D0) RETURN
      DO 10 N=2,NXRR
      ETR = 0.0D0
      dzEvapCells = 0.0D0
      nIndex = nly*(n - 1)
      AREA=DXR(N)
      IF(RAD)AREA=PI2*RX(N)*DXR(N)
      PETT=PEV*AREA
      DO 7 J=2,NLYY
      IN = nIndex + J
      IF(NTYP(IN).EQ.5) then
        dzEvapCells = dzEvapCells + delz(j)
      end if
 7    continue
      DO 8 J=2,NLYY
      IN = nIndex + J
      IF(NTYP(IN).EQ.5) THEN
!
!    COMPUTE TEMPORARY EVAP RATE, CHECK AGAINST MAX AND
!    CORRECT IF NECESSARY
!
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(N)*CS2
      END IF
      PTMP=P(IN)+Z1
      HKX=HCND(IN)*HX(IN)
      EV=HKX*SRES*(HA-PTMP)*AREA*delz(j)/dzEvapCells
      IF(EV.GT.0.0D0) EV=0.0D0
      Q(IN)=EV
      ETR = ETR + Q(IN)
      end if
 8    continue
      if (ETR.lt.pett) then
       r1 = pett/ETR
       ETR = PETT
       DO 9 J=2,NLYY
       IN = nIndex + J
       IF(NTYP(IN).EQ.5) q(in) = q(in)*r1
 9     continue
      end if
      ETOUT1=ETOUT1+ETR
   10 CONTINUE
      RETURN
      END
      SUBROUTINE VSPLNT
!******
!VSPLNT
!******
!
!   THIS SUBROUTINE COMPUTES ACTUAL ET AS A FUNCTION OF A ROOT
!        ACTIVITY FUNCTION, HYDRAULIC CONDUCTIVITY OF THE SOIL,
!        AND THE DIFFERENCE IN PRESSURE HEAD BETWEEN THE ROOTS AND
!        THE SOIL
!
! ----------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use rspac
      use kcon
      use press
      use disch
      use hcon
      use ptet
      use dumm
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
!
!   SUM TRANSPIRATION FOR EACH COLUMN
!
      ETOUT=0.0D0
      if(.not.bcit) then
      do 6 i = nly,nnodes
      q(i) = 0.0d0
 6    continue
      end if
      IF(PET.GE. 0.0D0)RETURN
      DO 50 I=2,NXRR
      ETR=0.0D0
      AREA=DXR(I)
      IF (RAD) AREA=PI2*RX(I)*DXR(I)
      PETT=AREA*PET
      iIndex = nly*(i-1)
      DO 10 J=2,NLYY
!
!   COMPUTE TRANSPIRATION FOR EACH NODE IN COLUMN
!
      IN=iIndex+J
      IF(NTYP(IN).EQ.0.AND.HX(IN).GT.0.0D0) THEN
      VOL=AREA*DELZ(J)
      IF(DPTH(IN).GT.RTDPTH) GO TO 20
!
!   TRANSPIRATION IS ZERO IF NTYP IS NOT 0, NODE IS DEEPER
!   THAN RTDPTH, OR PRESSURE IS LESS THAN HROOT
!
      IF(CS1.EQ.1.0D0) THEN
      Z1=DZZ(J)
      ELSE
      Z1=DZZ(J)*CS1+RX(I)*CS2
      END IF
      PTMP=P(IN)+Z1
      IF(PTMP.LE.HROOT) THEN
      dum(IN)=0.0D0
      ELSE
      HXX=HCND(IN)*HX(IN)*RT(IN)*VOL
!
!   Q IS TRANSPIRATION FOR EACH NODE.  ETR IS TOTAL FOR COLUMN
!
      dum(IN)=(HROOT-PTMP)*HXX
      ETR=ETR+dum(IN)
      END IF
      END IF
   10 CONTINUE
 20   continue
      ETR1 = ETR
      IF(ETR.LT.PETT) THEN
!
!   IF TOTAL TRANSPIRATION FOR COLUMN IS GREATER
!   THAN POTENTIAL THEN ADJUST TRANSPIRATION VALUES
!
      R1=PETT/ETR
      ETR1=PETT
      end if
      DO 30 K=2,J
      IN=iIndex+K
      IF(HX(IN).GT.0.0D0.AND.NTYP(IN).EQ.0) THEN
      IF(DPTH(IN).GT.RTDPTH) GO TO 40
      if(etr.lt.pett) then
       Q(IN)= Q(IN) + dum(IN)*R1
      else
       Q(IN) = Q(IN) + dum(in)
      end if
      END IF
   30 CONTINUE
   40 CONTINUE
      ETOUT=ETOUT+ETR1
   50 CONTINUE
      RETURN
      END
            SUBROUTINE VSPET
!*****
!VSPET
!*****
!
!   PURPOSE: TO COMPUTE VALUES OF PEV,SRES,HA,PET,RTDPTH,RTBOT,RTTOP,
!             AND HROOT FOR EVAPORATION AND TRANSPIRATION CALCULATIONS.
!             VALUES ARE DETERMINED BY LINEAR INTERPOLATION IN TIME
!            BETWEEN EVAPOTRANSPIRATION PERIODS.
!
!------------------------------------------------------------------
!
!    SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use ptet
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
!
!--------------------------------------------------------------
!
      npv1 = npv
      if(npv.lt.0) npv = -npv
      IF (NPV.EQ.1) THEN
!
!   IF ONLY 1 PERIOD THEN ALL VALUES ARE CONSTANT
!
      IF(BCIT) THEN
      PEV=-PEVAL(1)
      SRES=RDC(1,1)
      HA=RDC(2,1)
      END IF
      IF(ETSIM) THEN
      PET=-PTVAL(1)
      RTDPTH=RDC(3,1)
      RTBOT=RDC(4,1)
      RTTOP=RDC(5,1)
      HROOT=RDC(6,1)
      END IF
      ELSE
!
!   DETERMINE WHICH PERIOD TO USE
!
      ETCYC1=NPV*ETCYC
      SITY=DMOD(STIM,ETCYC1)
      I=(SITY/ETCYC)+2
      if (i.gt.npv) i = 1
      IF(I.EQ.1) THEN
      K=NPV
      ELSE
      K=I-1
      END IF
!
!   LINEARLY INTERPOLATE
!
      FRPER=(DMOD(SITY,ETCYC))/ETCYC
      IF (BCIT) THEN
      PEV=-PEVAL(K)-(PEVAL(I)-PEVAL(K))*FRPER
      SRES=RDC(1,K)+(RDC(1,I)-RDC(1,K))*FRPER
      HA=RDC(2,K)+(RDC(2,I)-RDC(2,K))*FRPER
      END IF
      IF (ETSIM) THEN
      PET=-PTVAL(K)-(PTVAL(I)-PTVAL(K))*FRPER
      RTDPTH=RDC(3,K)+(RDC(3,I)-RDC(3,K))*FRPER
      RTBOT=RDC(4,K)+(RDC(4,I)-RDC(4,K))*FRPER
      RTTOP=RDC(5,K)+(RDC(5,I)-RDC(5,K))*FRPER
      HROOT=RDC(6,K)+(RDC(6,I)-RDC(6,K))*FRPER
      END IF
      END IF
      npv = npv1
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSRDF(Z1,Z2)
!*****
!VSRDF
!*****
!
!     PURPOSE: TO DETERMINE THE ROOT ACTIVITY AT EACH NODE WITHIN
!              THE ROOT ZONE FOR EACH TIME STEP
!
!
!-------------------------------------------------------------------
!
      use ptet
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!     include 'c_ptet.inc'
!
!------------------------------------------------------------
!
!
!   LINEARLY INTERPOLATE USING DEPTH OF NODE AND MAXIMUM ROOT DEPTH
!
      IF(RTDPTH.GT.Z1.AND.RTDPTH.GT.0.0D0)THEN
      IF(RTDPTH.GE.Z1+Z2)THEN
      ZZ=Z1+0.5D0*Z2
      ZZ1=1.0D0
      ELSE
      ZZ=(Z1+RTDPTH)*0.5D0
      ZZ1=(RTDPTH-Z1)/Z2
      END IF
      VSRDF=ZZ1*(ZZ*RTBOT+(RTDPTH-ZZ)*RTTOP)/RTDPTH
      ELSE
      VSRDF=0.0D0
      END IF
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSDTHUVG(P,I)
! ******
!VSDTHUVG
!******
!
!    FIRST DERIVATIVE OF MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
!
!   VAN GENUCHTEN FUNCTION
!
!          HK(I,1)=SATURATED HYDRAULIC CONDUCTIVITY
!          HK(I,2)=SPECIFIC STORAGE
!          HK(I,3)=POROSITY
!          HK(I,4)=ALPHA PRIME
!          HK(I,5)=RESIDUAL MOISTURE CONTENT
!          HK(I,6)=BETA PRIME
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      VSDTHUVG=0.0D0
      IF(P.GE.0.0D0)RETURN
      SE=HK(I,3)-HK(I,5)
      EN=HK(I,6)
      EM=2.0D0-1.0D0/EN
!
!   NOTE -- following change made 12/1/98 to change definition of van
!           Genuchten alpha from original definition used in VS2DT.
!           New definition corresponds to that given by van Genuchten
!           (1980) in terms of inverse length.
!
!      ALPH=HK(I,4)
      ALPH=-1.0D0/HK(I,4)
      A=P/ALPH
      VSDTHUVG=-(EN-1.0D0)*SE*A**(EN-1.0D0)/(ALPH*(1.0D0+A**EN)**EM)
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHNVVG(V,I)
!******
!VSTHNVVG
!******
!
!    INITIAL UNSATURATED PRESSURE HEAD AS A FUNCTION OF VOLUMETRIC
!    MOISTURE CONTENT
!
!    VAN GENUCHTEN FUNCTION
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/JCON/JSTOP,JFLAG,jflag1
!      include 'c_rpropsh.inc'
      VSTHNVVG=0.0D0
      IF(V.GE.HK(I,3)) RETURN
      IF(V.GT.HK(I,5)) GO TO 10
      WRITE(6,4000) V,I
      jstop=6
      return
   10 SE=(V-HK(I,5))/(HK(I,3)-HK(I,5))
      EN=HK(I,6)
      EM=1.0D0-1.0D0/EN
!
!   NOTE -- following change made 12/1/98 to change definition of van
!           Genuchten alpha from original definition used in VS2DT.
!           New definition corresponds to that given by van Genuchten
!           (1980) in terms of inverse length.
!
!      ALPH=HK(I,4)
      ALPH=-1.0D0/HK(I,4)
      VSTHNVVG=ALPH*(1.0D0/SE**(1.0D0/EM)-1.0D0)**(1.0D0-EM)
      RETURN
 4000 FORMAT(/,'INITIAL MOISTURE CONTENT OF ',F7.3,'IS LESS THAN RES' &
      ,'IDUAL MOISTURE CONTENT FOR CLASS ',I4,/, &
      'PROGRAM HALTED')
      END
      DOUBLE PRECISION FUNCTION VSTHUVG(P,I)
!*****
!VSTHUVG
!*****
!
!    MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
!
! VAN GENUCHTEN FUNCTION
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      VSTHUVG=HK(I,3)
      IF(P .GE. 0.0D0)RETURN
      EN=HK(I,6)
!     EM=-(1.0D0-1.0D0/EN)
      EM=(1.0D0-1.0D0/EN)
      A=HK(I,3)-HK(I,5)
!
!   NOTE -- following change made 12/1/98 to change definition of van
!           Genuchten alpha from original definition used in VS2DT.
!           New definition corresponds to that given by van Genuchten
!           (1980) in terms of inverse length.
!
!      ALPH=HK(I,4)
      ALPH=-1.0D0/HK(I,4)
      VSTHUVG=HK(I,5)+A/(1.0D0+(P/ALPH)**EN)**EM
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSHKUVG(P,I)
!*****
!VSHKUVG
!*****
!
!    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
!
!   VAN GENUCHTEN FUNCTION
!
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rprop.inc'
      VSHKUVG=1.0D0
      IF(P.GE.0.0D0)RETURN
      EN=HK(I,6)
      EM=1.0D0-1.0D0/EN
!
!   NOTE -- following change made 12/1/98 to change definition of van
!           Genuchten alpha from original definition used in VS2DT.
!           New definition corresponds to that given by van Genuchten
!           (1980) in terms of inverse length.
!
!      A=P/HK(I,4)
      A=-P*HK(I,4)
      TOP=A**EN
      DEN=(1.0D0+TOP)**(EM/2.0D0)
!     TOP=1.0D0-TOP/A*(1.0D0+TOP)**(-EM)
      TOP=1.0D0-TOP/((1.0D0+TOP)**EM*A)
      VSHKUVG=TOP*TOP/DEN
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSHKUVGH(P,TT,I)
!*****
!VSHKUVG
!****
!
!    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
!
!  VAN GENUCHTEN FUNCTION
!
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      if (trans) then
      R2=10.0D0**(247.80D0*(1.0D0/(293.160D0-140.0D0)-1.0D0/&
      (TT+273.160D0-140.0D0)))     
      VSHKUVGH=R2
      else
       VSHKUVGH= 1.0D0
      end if
      IF(P.GE.0.0D0)RETURN
      EN=HK(I,6)
      EM=1.0D0-1.0D0/EN
!
!   NOTE -- following change made 12/1/98 to change definition of van
!           Genuchten alpha from original definition used in VS2DH.
!           New definition corresponds to that given by van Genuchten
!           (1980) in terms of inverse length.
!
!      A=P/HK(I,4)
      A=-P*HK(I,4)
      TOP=A**EN
      DEN=(1.0D0+TOP)**(EM/2.0D0)
!     TOP=1.0D0-TOP/A*(1.0D0+TOP)**(-EM)
      TOP=1.0D0-TOP/((1.0D0+TOP)**EM*A)
      VSHKUVGH=VSHKUVGH*TOP*TOP/DEN
      RETURN
      END

      DOUBLE PRECISION FUNCTION VSDTHUBC(P,I)
!******
!VSDTHUBC
!******
!
!    FIRST DERIVATIVE OF MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
!
!    BROOKS AND COREY, CSU HYDROLOGY PAPER NO. 17 PP.3-4
!
!          HK(I,1)=SATURATED HYDRAULIC CONDUCTIVITY
!          HK(I,2)=SPECIFIC STORAGE
!          HK(I,3)=POROSITY
!          HK(I,4)=BUBBLING PRESSURE
!          HK(I,5)=RESIDUAL MOISTURE CONTENT
!          HK(I,6)=LAMBDA
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      VSDTHUBC=0.0D0
      IF(P.GE.HK(I,4))RETURN
      VSDTHUBC=-((HK(I,3)-HK(I,5))*HK(I,6)*(HK(I,4)/P)**HK(I,6))/P
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHNVBC(V,I)
!******
!VSTHNVBC
!******
!
!    INITIAL UNSATURATED PRESSURE HEAD AS A FUNCTION OF VOLUMETRIC
!    MOISTURE CONTENT
!
!    BROOKS AND COREY, CSU HYDROLOGY PAPER NO. 17 , PP.3-4
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/JCON/JSTOP,JFLAG,jflag1
!      include 'c_rpropsh.inc'
      VSTHNVBC=HK(I,4)
      IF(V.GE.HK(I,3)) RETURN
      IF(V.GT.HK(I,5)) GO TO 1
      WRITE(6,100) V,I
  100 FORMAT(/,'INITIAL MOISTURE CONTENT OF ',F7.3,'IS LESS THAN RES' &
      ,'IDUAL MOISTURE CONTENT FOR CLASS ',I4,/, &
       'PROGRAM HALTED')
      jstop=6
      return
  1   SE=(V-HK(I,5))/(HK(I,3)-HK(I,5))
      VSTHNVBC=HK(I,4)/(SE**(1.0D0/HK(I,6)))
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHUBC(P,I)
!*****
!VSTHUBC
!*****
!
!    MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD BELOW BUBBLING
!   PRESSURE: = POROSITY ELSEWHERE
!
!    BROOKS AND COREY, CSU HYDROLOGY PAPER NO.17, PP.3-4
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      VSTHUBC=HK(I,3)
      IF(P.GE.HK(I,4))RETURN
      VSTHUBC=HK(I,5)+(HK(I,3)-HK(I,5))*(HK(I,4)/P)**HK(I,6)
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSHKUBC(P,I)
!*****
!VSHKUBC
!
!    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
!
!    BROOKS AND COREY, CSU HYDROLOGY PAPER NO. 3
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      VSHKUBC=1.0D0
      IF(P.GE.HK(I,4))RETURN
      VSHKUBC=(HK(I,4)/P)**(2.0D0+3.0D0*HK(I,6))
      IF(VSHKUBC.LT.1.D-38)VSHKUBC=0.0D0
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSHKUBCH(P,TT,I)
!*****
!CVSHKUBCH
!C*****
!
!   RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
!
!    BROOKS AND COREY, CSU HYDROLOGY PAPER NO. 3
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      if (trans) then
      R2=10.0D0**(247.80D0*(1.0D0/(293.160D0-140.0D0)-1.0D0/&
      (TT+273.160D0-140.0D0)))
      VSHKUBCH=R2
      else
       VSHKUBCH = 1.0D0
      end if
      IF(P.GE.HK(I,4))RETURN
      VSHKUBCH=VSHKUBCH*(HK(I,4)/P)**(2.0D0+3.0D0*HK(I,6))
      IF(VSHKUBCH.LT.1.D-38)VSHKUBCH=0.0D0
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSDTHUHK(P,I)
!******
!VSDTHUHK
!******
!
!    FIRST DERIVATIVE OF MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
!
!   HAVERKAMP FUNCTION
!
!         HK(I,1)=SATURATED HYDRAULIC CONDUCTIVITY
!          HK(I,2)=SPECIFIC STORAGE
!          HK(I,3)=POROSITY
!          HK(I,4)=A PRIME
!          HK(I,5)=RESIDUAL MOISTURE CONTENT
!          HK(I,6)=B PRIME
!          HK(I,7)=ALPHA
!          HK(I,8)=BETA
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      VSDTHUHK=0.0D0
      IF(P.GE.0.0D0)RETURN
      SE=HK(I,3)-HK(I,5)
      ALPH=HK(I,7)
      EM=HK(I,8)
      TOP=P/ALPH
      DEN=1.0D0+TOP**EM
      DEN=DEN*DEN
      VSDTHUHK=-SE*EM*TOP**(EM-1.0D0)/(ALPH*DEN)
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHNVHK(V,I)
!******
!VSTHNVHK
!******
!
!    INITIAL UNSATURATED PRESSURE HEAD AS A FUNCTION OF VOLUMETRIC
!    MOISTURE CONTENT
!
!    HAVERKAMP FUNCTION
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/JCON/JSTOP,JFLAG,jflag1
!      include 'c_rpropsh.inc'
      VSTHNVHK=0.0D0
      IF(V.GE.HK(I,3)) RETURN
      IF(V.GT.HK(I,5)) GO TO 1
      WRITE(6,100) V,I
  100 FORMAT(/,'INITIAL MOISTURE CONTENT OF ',F7.3,'IS LESS THAN RES' &
      ,'IDUAL MOISTURE CONTENT FOR CLASS ',I4,/, &
      'PROGRAM HALTED')
      jstop=6
      return
  1   SE=(V-HK(I,5))/(HK(I,3)-HK(I,5))
      VSTHNVHK=HK(I,7)*(1.0D0/SE-1.0D0)**(1.0D0/HK(I,8))
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHUHK(P,I)
!******
!VSTHUHK
!******
!
!   MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
!
!  HAVERKAMP FUNCTION
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!     include 'c_rpropsh.inc'
      VSTHUHK=HK(I,3)
      IF(P .GE. 0.0D0)RETURN
      VSTHUHK=HK(I,5)+(HK(I,3)-HK(I,5))/((P/HK(I,7))**HK(I,8)+1.0D0)
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSHKUHK(P,I)
!*****
!VSHKUHK
!****
!
!    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
!
!  HAVERKAMP FUNCTION
!
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      VSHKUHK=1.0D0
      IF(P.GE.0.0D0)RETURN
      VSHKUHK=1.0D0/((P/HK(I,4))**HK(I,6)+1.0D0)
      RETURN
      END
       DOUBLE PRECISION FUNCTION VSHKUHKH(P,TT,I)
!*****
!VSHKUHKH
!*****
!
!    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
!
!  HAVERKAMP FUNCTION
!
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      if (trans) then
      R2=10.0D0**(247.80D0*(1.0D0/(293.160D0-140.0D0)-1.0D0/&
      (TT+273.160D0-140.0D0)))
      VSHKUHKH=R2
      else
       VSHKUHKH = 1.0D0
      end if
      IF(P.GE.0.0D0)RETURN
      VSHKUHKH=VSHKUHKH/((P/HK(I,4))**HK(I,6)+1.0D0)
      RETURN
      END     

      SUBROUTINE INTERP (P,I)
!******
!INTERP
!******
!
!C   THIS SUBROUTINE PERFORMS LINEAR INTERPOLATION OF PRESSURE
!   HEADS FOR RELATIVE HYDRAULIC CONDUCTIVITY (VSHKU), VOLUMETRIC
!   MOISTURE CONTENT (VSTHU), AND MOISTURE CAPACITY (VSDTHU).
!
!
!   TO USE THIS METHOD FOR EVALUATING THE NONLINEAR FUNCTIONS,
!   THE USER MUST ENTER A TABLE OF PRESSURE HEADS
!   AND VALUES OF RELATIVE
!   CONDUCTIVITIES,AND MOISTURE CONTENTS
!   WHICH CORRESPOND TO EACH PRESSURE HEAD INTO ARRAY HK ON
!   B-7 CARDS FOR EACH TEXTURAL CLASS.  SET NPROP (CARD B-5) EQUAL
!   TO 3*(NUMBER OF PRESSURE HEADS IN TABLE + 1).
!   BEGINNING WITH HK(ITEX,4), ENTER ALL PRESSURE HEADS IN DESCENDING
!   ORDER STARTING WITH THE HIGHEST VALUE,
!   NEXT ENTER THE NUMBER 99,
!   NEXT ENTER THE RELATIVE HYDRAULIC
!   CONDUCTIVITY FOR EACH PRESSURE HEAD,
!   NEXT ENTER THE NUMBER 99,
!   NEXT ENTER THE VOLUMETRIC MOISTURE CONTENT FOR EACH PRESSURE
!   HEAD, FINALLY ENTER THE NUMBER 99.
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      COMMON/hinterp/ DELPP,nprop,I1,I2,I3,I4,I5,I6
!     IF (I2.GT.0) GO TO 1
      I2=4
      DO 2 J=I2,nprop
      IF (HK(I,J).LT.99.0D0) GO TO 2
      I3=J-I2+1
      I1=I3+I3
      GO TO 1
   2  CONTINUE
   1  IF(HK(I,I2).LE.P) THEN
      DELPP=0.0D0
      I5=I2
      I6=I2
      ELSE
      I4=I2+I3-2
      IF(HK(I,I4).GE.P)THEN
      I5=I4-1
      I6=I4
      DELPP=0.0D0
      ELSE
!      I4=I4-1
      DO 3 J=I2+1,I4
      IF(HK(I,J).GT.P) GO TO 3
      I5=J-1
      I6=J
      DELPP=(P-HK(I,I6))/(HK(I,I5)-HK(I,I6))
      RETURN
   3  CONTINUE
      END IF
      END IF
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSHKUTAB (P,I)
!*****
!VSHKUTAB
!*****
!
!  RELATIVE HYDRAULIC CONDUCTIVITY AS A FUNCTION OF PRESSURE HEAD
!  DETERMINED BY LINEAR INTERPOLATION OF KR VS HP TABLE WHICH IS
!   INPUT BY USER.
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      COMMON/hinterp/ DELPP,nprop,I1,I2,I3,I4,I5,I6
      CALL INTERP (P,I)
      IF(I5.EQ.I6)THEN
      VSHKUTAB=HK(I,I3+I5)
      RETURN
      ELSE
      VSHKUTAB=HK(I,I3+I6)+(HK(I,I3+I5)-HK(I,I3+I6))*DELPP
      RETURN
      END IF
      END
      DOUBLE PRECISION FUNCTION VSHKUTABH (P,TT,I)
!*****
!VSHKUTAB
!*****
!
!   RELATIVE HYDRAULIC CONDUCTIVITY AS A FUNCTION OF PRESSURE HEAD
!  DETERMINED BY LINEAR INTERPOLATION OF KR VS HP TABLE WHICH IS
!   INPUT BY USER.
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      COMMON/hinterp/ DELPP,nprop,I1,I2,I3,I4,I5,I6
      R2=10.0D0**(247.80D0*(1.0D0/(293.160D0-140.0D0)-1.0D0/ &
      (TT+273.160D0-140.0D0)))
      CALL INTERP (P,I)
      IF(I5.EQ.I6)THEN
      VSHKUTABH=R2*HK(I,I3+I5)
      RETURN
      ELSE
      VSHKUTABH=HK(I,I3+I6)+(HK(I,I3+I5)-HK(I,I3+I6))*DELPP
      VSHKUTABH=VSHKUTABH*R2
      RETURN
      END IF
      END
      DOUBLE PRECISION FUNCTION VSDTHUTAB(P,I)
!******
!VSDTHUTAB
!******
!
!   MOISTURE CAPACITY AS A FUNCTION OF PRESSURE HEAD AS
!   DETERMINED FROM TABLE OF THETA VS HP WHICH IS INPUT
!   BY USER.
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      COMMON/hinterp/ DELPP,nprop,I1,I2,I3,I4,I5,I6
      CALL INTERP (P,I)
      IF (I5.EQ.I6) THEN
      VSDTHUTAB=0.0D0
      RETURN
      ELSE
      VSDTHUTAB=(HK(I,I1+I5)-HK(I,I1+I6))/(HK(I,I5)-HK(I,I6))
      RETURN
      END IF
      END
      DOUBLE PRECISION FUNCTION VSTHUTAB (P,I)
!*****
!VSTHUTAB
!*****
!
!   VOLUMETRIC MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
!   AS DETERMINED BY LINEAR INTERPOLATION OF THETA VS HP TABLE
!   WHICH IS INPUT BY USER.
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      COMMON/hinterp/ DELPP,nprop,I1,I2,I3,I4,I5,I6
      IF (DELPP.EQ.0.0D0) THEN
      VSTHUTAB=HK(I,I1+I6)
      ELSE
      VSTHUTAB=HK(I,I1+I6)+(HK(I,I1+I5)-HK(I,I1+I6))*DELPP
      END IF
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHNVTAB(P,I)
!******
!VSTHNVTAB
!******
!
!     NOTE -- THIS FUNCTION IS NOT OPERATIVE WHEN USING INTERPOLATION
!             ROUTINES.  INITIAL CONDITIONS MUST BE INPUT IN TERMS OF
!              PRESSURE HEADS NOT MOISTURE CONTENTS.
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/JCON/JSTOP,JFLAG,jflag1
!     include 'c_rpropsh.inc'
      WRITE(6,100)
      jstop=7
      vsthnvtab=hk(i,3)
      return
  100 FORMAT(5X,'INPUT OF MOISTURE CONTENT FOR INITIAL CONDITIONS IS ', &
      'NOT ALLOWED WHEN USING TABULAR DATA '/ &
      5X,'FOR MOISTURE RETENTION AND CONDUCTIVITY CURVES',/ &
      5X,'SIMULATION TERMINATED')
      END

      DOUBLE PRECISION FUNCTION VSDTHUOT(P,I)
!******
!VSDTHUOT
!******
!     
!  modified for Rossi-Nimmo retention curve may 2006
!
!    FIRST DERIVATIVE OF MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
!         USER-SUPPLIED FUNCTION
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      COMMON/JCON/JSTOP,JFLAG,jflag1
      vsdthuot=0.0D0
      h = -p
      if (h.le.0.0D0) then
       return
      else
       if (h.le.hk(i,7)) then
        vsdthuot = hk(i,3)*hk(i,8)*(h+h)/hk(i,4)**2.0D0
       else
        if (h.le.hk(i,10)) then
         vsdthuot = hk(i,3)*(hk(i,4)**hk(i,6))*hk(i,6)*h**(-1.0D0-hk(i,6))
        else
         vsdthuot = hk(i,3)*hk(i,9)/h
        end if
       end if
      end if
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHNVOT(V,I)
!******
!VSTHNVOT
!******
!
!  revised for Rossi-Nimmo 
!
!    INITIAL UNSATURATED PRESSURE HEAD AS A FUNCTION OF VOLUMETRIC
!    MOISTURE CONTENT
!        USER-SUPPLIED FUNCTION

      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      vsthnvot=0.0D0
      p = V
      if (p.ge.hk(i,3)) then
       return
      else
       if (p.ge.hk(i,11)) then
        vsthnvot = -((hk(i,4)**(2.0D0))*((-p/hk(i,3) + &
          1.0D0)/hk(i,8)))**(.50D0)
       else
        if (p.ge.hk(i,12)) then
         vsthnvot = -(hk(i,4)**hk(i,6)*hk(i,3)/p)**(1.0D0/hk(i,6))
        else
         vsthnvot = -hk(i,5)*exp(-p/(hk(i,3)*hk(i,9)))
        end if
       end if
      end if
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSTHUOT(P,I)
!*****
!VSTHUOT
!*****
!
!  
!  revised for Rossi-Nimmo
!
!    MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD BELOW BUBBLING
!   PRESSURE: = POROSITY ELSEWHERE
!        USER-SUPPLIED FUNCTION

      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      vsthuot=hk(i,3)
      h = -p
      if (h.le.0.0D0) then
       return
      else
       if (h.le.hk(i,7)) then
        vsthuot = hk(i,3)*(1.0D0 - hk(i,8)*(h/hk(i,4))**2.0D0)
       else
        if (h.le.hk(i,10)) then
         vsthuot = hk(i,3)*(hk(i,4)/h)**hk(i,6)
        else
         if (h.le.hk(i,5)) then
          vsthuot = hk(i,3)*hk(i,9)*log(hk(i,5)/h)
         else
          vsthuout = 0.0D0
        end if
       end if
      end if
      end if
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSHKUOT(P,I)
!*****
!VSHKUOT
!*****
!
!  revised for Rossi-Nimmo
!
!    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
 !     USER-SUPPLIED FUNCTION
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!     include 'c_rpropsh.inc'
      vshkuot=1.0D0
      if (p.ge.hk(i,3)) then
       return
      else
       r1 = p/hk(i,3)
       if (p.lt.hk(i,12)) then
        xi3 = hk(i,9)*(exp(r1/hk(i,9)) - 1.0D0)/hk(i,5)
        vshkuot = r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
       else
        if (p.le.hk(i,11)) then
         xi3 = hk(i,18) + (r1**hk(i,14) - hk(i,15))/(hk(i,4)*hk(i,14))        
         vshkuot = r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
        else
         xi3 = hk(i,19) + hk(i,16)*(hk(i,17) - (1.0D0 - r1)**(.50D0))
         vshkuot = r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
        end if
       end if
      end if
      RETURN
      END
      DOUBLE PRECISION FUNCTION VSHKUOTH(P,TT,I)
!*****
!VSHKUOTH
!*****
!
!  revised for Rossi-Nimmo
!
!    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
!      USER-SUPPLIED FUNCTION
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_rpropsh.inc'
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      if (trans) then
      R2=10.0D0**(247.80D0*(1.0D0/(293.160D0-140.0D0)-1.0D0/&
      (CC+273.160D0-140.0D0)))
      VSHKUoth=R2
      else
       VSHKUoth = 1.0D0
      end if
      if (p.ge.hk(i,3)) then
       return
      else
       r1 = p/hk(i,3)
       if (p.lt.hk(i,12)) then
        xi3 = hk(i,9)*(exp(r1/hk(i,9)) - 1.0D0)/hk(i,5)
        vshkuoth = vshkuoth*r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
       else
        if (p.le.hk(i,11)) then
         xi3 = hk(i,18) + (r1**hk(i,14) - hk(i,15))/(hk(i,4)*hk(i,14))        
         vshkuoth = vshkuoth*r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
        else
         xi3 = hk(i,19) + hk(i,16)*(hk(i,17) - (1.0D0 - r1)**(.50D0))
         vshkuoth = vshkuoth*r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
        end if
       end if
      end if
      RETURN
      END
      SUBROUTINE VTVELO
!******
!VTVELO
!******
!
!    ROUTINE TO CALCULATE VELOCITIES AT BOUNDARIES OF ADJACENT CELLS
!    VX IS VELOCITY IN X-DIRECTION BETWEEN CURRENT NODE AND NODE TO
!    THE LEFT.
!    VZ IS VELOCITY IN Z-DIRECTION BETWEEN CURRENT NODE AND NODE
!    ABOVE.
!
      use rspac
      use kcon
      use mprop
      use press
      use hcon
      use trxx
      use trxv
      use temp
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      COMMON/WGT/WUS,WDS
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      LOGICAL HEAT,SOLUTE,FLOW
      COMMON/TRANSTYPE/HEAT,SOLUTE
      IF(HEAT) then
       RHOMAX=0.0D0
      end if
      DO 10 I=2,NXRR
      N1=NLY*(I-1)
      DO 10 J=2,NLYY
      N=N1+J
!      VX(N)=0.0D0
!      VZ(N)=0.0D0
      IF(HX(N).NE.0.0D0) THEN
      JM1=N-1
      IM1=N-NLY
      IF(HX(JM1).NE.0.0D0) THEN
!
!   CALCULATE VERTICAL VELOCITY
!
      if(ntyp(n).eq.1.and.ntyp(jm1).eq.1) then
       vz(n) = 0.0d0
      else
      if(heat)then
        RHO2=VZ(N)
       end if
      AREA=DXR(I)
      IF (RAD) AREA=PI2*RX(I)*DXR(I)
      GRAD=P(JM1)-P(N)
      THETA1=0.5D0*(THETA(N)+THETA(JM1))*AREA
      IF(WUS.EQ.0.0D0) THEN
      VZ(N)=HKTT(N)*DSQRT(HCND(N)*HCND(JM1))*GRAD/THETA1
      ELSE
      IF(P(JM1).GT.P(N))THEN
      ALA=WUS
      BTA=WDS
      ELSE
      ALA=WDS
      BTA=WUS
      END IF
      VZ(N)=HKTT(N)*(ALA*HCND(JM1)+BTA*HCND(N))*GRAD/THETA1
      END IF
      if(heat) then
      RHO2=DABS(RHO2-VZ(N))
      IF(RHO2.GT.RHOMAX) RHOMAX=RHO2
      end if
      END IF
      ELSE
      VZ(N)=0.0D0
      end if
      IF(HX(IM1).NE.0.0D0) THEN
!
!   CALCULATE HORIZONTAL VELOCITY
!
      if(ntyp(n).eq.1.and.ntyp(im1).eq.1) then
       vx(n) = 0.0d0
      else
      if(heat)then
      RHO2=VX(N)
      end if  
      GRAD=P(IM1)-P(N)
      AREA=DELZ(J)
      IF (RAD) AREA=PI2*AREA*(RX(I)-0.5D0*DXR(I))
      THETA1=0.5D0*(THETA(N)+THETA(IM1))*AREA
      IF(WUS.EQ.0.0D0) THEN
      VX(N)=HKLL(N)*DSQRT(HCND(N)*HCND(IM1))*GRAD/THETA1
      ELSE
      IF(P(IM1).GT.P(N)) THEN
      ALA=WUS
      BTA=WDS
      ELSE
      ALA=WDS
      BTA=WUS
      END IF
      VX(N)=HKLL(N)*(ALA*HCND(IM1)+BTA*HCND(N))*GRAD/THETA1
      END IF
      if(heat)then
      RHO2=DABS(RHO2-VX(N))
      IF(RHO2.GT.RHOMAX) RHOMAX=RHO2
      end if  
      END IF
      ELSE
      VX(N)=0.0D0
      END IF
      end if
   10 CONTINUE
      RETURN
      END
      SUBROUTINE VTDCOEF
!*******
!VTDCOEF
!******
!
!    ROUTINE TO CALCULATE DISPERSION COEFFICIENTS AS FUNCTIONS
!    OF DISPERSIVITIES AND VELOCITIES.  DIAGNOL TERMS ARE
!   CONTAINED IN ARRAYS DX1 AND DZ1.  CROSS PRODUCT TERMS
!    ARE IN DX2 AND DZ2
!
      use rspac
      use kcon
      use mprop
      use jtxx
      use trxv
      use rpropsh
      use trxxh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      DO 10 I=2,NXRR
      N1=NLY*(I-1)
      DO 10 J=2,NLYY
      N=N1+J
      DX1(N)=0.0D0
      DX2(N)=0.0D0
      DZ1(N)=0.0D0
      DZ2(N)=0.0D0
      PEX=0.0D0
      PEZ=0.0D0
      IMX=0
      JMX=0
      IMZ=0
      JMZ=0
      IF(HX(N).NE.0.0D0) THEN
      N2=JTEX(N)
      AL=HT(N2,1)
      AT=HT(N2,2)
!      DM=HS(N2,3)
      V1=VX(N)
      V2=VZ(N)
      JM1=N-1
      IM1=N-NLY
      JP1=N+1
      IP1=N+NLY
      IP2=IP1-1
      IM2=IM1+1
      IF(HX(JM1).NE.0.0D0) THEN
      V3=0.25D0*(V1+VX(IP1)+VX(IP2)+VX(JM1))
      V32=V3*V3
      V22=V2*V2
      VV2=V32+V22
!
!   CALCULATE DZ1 AND DZ2
!
      N2=JTEX(JM1)
      AL1=DSQRT(AL*HT(N2,1))
      AT1=DSQRT(AT*HT(N2,2))
!      DM1=DSQRT(DM*HS(N2,3))
       DM1=0.0D0
      AREA=DXR(I)
      IF(RAD) AREA=PI2*AREA*RX(I)
      T1=0.5D0*(THETA(JM1)+THETA(N))
      DD1=(DZZ(J)-DZZ(J-1))/AREA
      T2=T1/DD1
      IF(VV2.EQ.0.0D0) THEN
      DZ1(N)=DM1
      ELSE
      VAVE=DSQRT(VV2)
      DL=AL1*VAVE
      DT=AT1*VAVE
      DZ1(N)=(DL*V22+DT*V32)/VV2
!C#
      IF(HX(IP2).GT.0.0D0 .AND.HX(IP1).GT.0.0D0) THEN
       IF(HX(IM1-1).GT.0.0D0 .AND.HX(IM1).GT.0.0D0) THEN
        DD1=(RX(I+1)-RX(I-1))/AREA
       ELSE
        DD1=(RX(I+1)-RX(I))/AREA
       END IF
      ELSE
       IF(HX(IM1-1).GT.0.0D0 .AND.HX(IM1).GT.0.0D0) THEN
        DD1=(RX(I)-RX(I-1))/AREA
       ELSE
        DD1=1.0D+14
       END IF
      END IF
!C#
      DZ2(N)=T1*(DL-DT)*V2*V3/(DD1*VV2)
      END IF
!
! CALCULATE VERTICAL CELL PECLET NUMBER
!
      IF(DZ1(N).LE.0.0D0) THEN
      PE=0.0D0
      ELSE
      PE=DABS(VZ(N))*(DZZ(J)-DZZ(J-1))/DZ1(N)
      END IF
      DZ1(N)=T2*DZ1(N)
      IF(NTYP(N).EQ.0.OR.NTYP(N).EQ.2.or.ntyp(N).eq.7) THEN
      IF(PE.GT.PEZ) THEN
      PEZ=PE
      IMZ=I
      JMZ=J
      END IF
      END IF
      END IF
      IF(HX(IM1).NE.0.0D0) THEN
      V3=0.25D0*(V2+VZ(JP1)+VZ(IM1)+VZ(IM2))
      V32=V3*V3
      V12=V1*V1
      VV2=V12+V32
!
!   CALCULATE DX1 AND DX2
!
      N2=JTEX(IM1)
      AL1=DSQRT(AL*HT(N2,1))
      AT1=DSQRT(AT*HT(N2,2))
!      DM1=DSQRT(DM*HS(N2,3))
      DM1=0.0D0
      AREA=DELZ(J)
      IF(RAD) AREA=PI2*AREA*(RX(I)-0.5D0*DXR(I))
      DD1=(RX(I)-RX(I-1))/AREA
      T1=0.5D0*(THETA(IM1)+THETA(N))
      T2=T1/DD1
      IF(VV2.EQ.0.0D0) THEN
      DX1(N)=DM1
      ELSE
      VAVE=DSQRT(VV2)
      DL=AL1*VAVE
      DT=AT1*VAVE
      DX1(N)=(DL*V12+DT*V32)/VV2
!C#
      IF(HX(JP1).GT.0.0D0 .AND.HX(JP1-NLY).GT.0.0D0) THEN
       IF(HX(IM1-1).GT.0.0D0 .AND.HX(JM1).GT.0.0D0) THEN
        DD1=(DZZ(J+1)-DZZ(J-1))/AREA
       ELSE
        DD1=(DZZ(J+1)-DZZ(J))/AREA
       END IF
      ELSE
       IF(HX(IM1-1).GT.0.0D0 .AND.HX(JM1).GT.0.0D0) THEN
        DD1=(DZZ(J)-DZZ(J-1))/AREA
       ELSE
        DD1=1.0D+14
       END IF
      END IF
!C#
      DX2(N)=T1*(DL-DT)*V1*V3/(VV2*DD1)
      END IF
!C
!C  CALCULATE HORIZONTAL CELL PECLET NUMBER
!C

      IF(DX1(N).LE.0.0D0) THEN
      PE=0.0D0
      ELSE
      PE=DABS(VX(N))*(RX(I)-RX(I-1))/DX1(N)
      END IF
      DX1(N)=DX1(N)*T2
      IF(NTYP(N).EQ.0.OR.NTYP(N).EQ.2.or.ntyp(N).eq.7) THEN
      IF(PE.GT.PEX) THEN
      PEX=PE
      IMX=I
      JMX=J
      END IF
      END IF
      END IF
      END IF
   10 CONTINUE
!
!  WRITE MAXIMUM CELL PECLET NUMBERS
!
!      WRITE(6,4000) PEX,JMX,IMX,PEZ,JMZ,IMZ
      RETURN
! 4000 FORMAT(4X,'  MAXIMUM CELL PECLET NUMBER  --  HORIZONTAL  ',E14.5,
!     &'     ROW ',I4,'  COLUMN ',I4,/,38X,'VERTICAL    ',E14.5,
!     &'     ROW ',I4,'  COLUMN ',I4)
      END
      SUBROUTINE VTDCOEFSOL
!*******
!VTDCOEFSOL
!*******
!
!   ROUTINE TO CALCULATE DISPERSION COEFFICIENTS AS FUNCTIONS
!    OF DISPERSIVITIES AND VELOCITIES.  DIAGNOL TERMS ARE
!   CONTAINED IN ARRAYS DX1 AND DZ1.  CROSS PRODUCT TERMS
!    ARE IN DX2 AND DZ2
!
      use rspac
      use kcon
      use mprop
      use jtxx
      use trxv
      use rpropsh
      use trxx
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV   
      DO 10 I=2,NXRR
      N1=NLY*(I-1)
      DO 10 J=2,NLYY
      N=N1+J
      DXS1(N)=0.0D0
      DXS2(N)=0.0D0
      DZS1(N)=0.0D0
      DZS2(N)=0.0D0
      PEXS=0.0D0
      PEZS=0.0D0
      IMX=0
      JMX=0
      IMZ=0
      JMZ=0
      IF(HX(N).NE.0.0D0) THEN
      N2=JTEX(N)
      AL=HS(N2,1)
      AT=HS(N2,2)
      DM=HS(N2,3)
      V1=VX(N)
      V2=VZ(N)
      JM1=N-1
      IM1=N-NLY
      JP1=N+1
      IP1=N+NLY
      IP2=IP1-1
      IM2=IM1+1
      IF(HX(JM1).NE.0.0D0) THEN
      V3=0.25D0*(V1+VX(IP1)+VX(IP2)+VX(JM1))
      V32=V3*V3
      V22=V2*V2
      VV2=V32+V22
!
!   CALCULATE DZ1 AND DZ2
!
      N2=JTEX(JM1)
      AL1=DSQRT(AL*HS(N2,1))
      AT1=DSQRT(AT*HS(N2,2))
      DM1=DSQRT(DM*HS(N2,3))
      AREA=DXR(I)
      IF(RAD) AREA=PI2*AREA*RX(I)
      T1=0.5D0*(THETA(JM1)+THETA(N))
      DD1=(DZZ(J)-DZZ(J-1))/AREA
      T2=T1/DD1
      IF(VV2.EQ.0.0D0) THEN
      DZS1(N)=DM1
      ELSE
      VAVE=DSQRT(VV2)
      DL=AL1*VAVE
      DT=AT1*VAVE
      DZS1(N)=(DL*V22+DT*V32)/VV2+DM1
!C#
      IF(HX(IP2).GT.0.0D0 .AND.HX(IP1).GT.0.0D0) THEN
       IF(HX(IM1-1).GT.0.0D0 .AND.HX(IM1).GT.0.0D0) THEN
        DD1=(RX(I+1)-RX(I-1))/AREA
       ELSE
        DD1=(RX(I+1)-RX(I))/AREA
       END IF
      ELSE
       IF(HX(IM1-1).GT.0.0D0 .AND.HX(IM1).GT.0.0D0) THEN
        DD1=(RX(I)-RX(I-1))/AREA
       ELSE
        DD1=1.0D+14
       END IF
      END IF
!      DZS2(N)=T1*(DL-DT)*V2*V3/(DD1*VV2)
      END IF
!C
!C  CALCULATE VERTICAL CELL PECLET NUMBER
!C
      IF(DZS1(N).LE.0.0D0) THEN
      PE=0.0D0
      ELSE
      PE=DABS(VZ(N))*(DZZ(J)-DZZ(J-1))/DZS1(N)
      END IF
      DZS1(N)=T2*DZS1(N)
      IF(NTYP(N).EQ.0.OR.NTYP(N).EQ.2) THEN
      IF(PE.GT.PEZS) THEN
      PEZS=PE
      IMZ=I
      JMZ=J
      END IF
      END IF
      END IF
      IF(HX(IM1).NE.0.0D0) THEN
      V3=0.25D0*(V2+VZ(JP1)+VZ(IM1)+VZ(IM2))
      V32=V3*V3
      V12=V1*V1
      VV2=V12+V32
!C
!C   CALCULATE DX1 AND DX2
!C
      N2=JTEX(IM1)
      AL1=DSQRT(AL*HS(N2,1))
      AT1=DSQRT(AT*HS(N2,2))
      DM1=DSQRT(DM*HS(N2,3))
      AREA=DELZ(J)
      IF(RAD) AREA=PI2*AREA*(RX(I)-0.5D0*DXR(I))
      DD1=(RX(I)-RX(I-1))/AREA
      T1=0.5D0*(THETA(IM1)+THETA(N))
      T2=T1/DD1
      IF(VV2.EQ.0.0D0) THEN
      DXS1(N)=DM1
      ELSE
      VAVE=DSQRT(VV2)
      DL=AL1*VAVE
      DT=AT1*VAVE
      DXS1(N)=(DL*V12+DT*V32)/VV2+DM1
!C#
      IF(HX(JP1).GT.0.0D0 .AND.HX(JP1-NLY).GT.0.0D0) THEN
       IF(HX(IM1-1).GT.0.0D0 .AND.HX(JM1).GT.0.0D0) THEN
        DD1=(DZZ(J+1)-DZZ(J-1))/AREA
       ELSE
        DD1=(DZZ(J+1)-DZZ(J))/AREA
       END IF
      ELSE
       IF(HX(IM1-1).GT.0.0D0 .AND.HX(JM1).GT.0.0D0) THEN
        DD1=(DZZ(J)-DZZ(J-1))/AREA
       ELSE
        DD1=1.0D+14
       END IF
      END IF
!C#
      DXS2(N)=T1*(DL-DT)*V1*V3/(VV2*DD1)
      END IF
!C
!C  CALCULATE HORIZONTAL CELL PECLET NUMBER
!C
      IF(DXS1(N).LE.0.0D0) THEN
      PE=0.0D0
      ELSE
      PE=DABS(VX(N))*(RX(I)-RX(I-1))/DXS1(N)
      END IF
      DXS1(N)=DXS1(N)*T2
      IF(NTYP(N).EQ.0.OR.NTYP(N).EQ.2) THEN
      IF(PE.GT.PEXS) THEN
      PEXS=PE
      IMX=I
      JMX=J
      END IF
      END IF
      END IF
      END IF
  10  CONTINUE 
!
!  WRITE MAXIMUM CELL PECLET NUMBERS
!

!       WRITE(6,4000) PEXS,JMX,IMX,PEZS,JMZ,IMZ
      RETURN

! 4000 FORMAT(4X,'  MAXIMUM CELL PECLET NUMBER  --  HORIZONTAL  ',E14.5
!     &'     ROW ',I4,'  COLUMN ',I4,/,38X,'VERTICAL    ',E14.5,
!     &'     ROW ',I4,'  COLUMN ',I4)
      END
      
      SUBROUTINE VTSETUP
!*******
!VTSETUP
!*******
!
!    ROUTINE TO ASSEMBLE MATRIX EQUATIONS FOR ADVECTION-DISPERSION
!    EQUATIONS AND TO CALL MATRIX SOLVER.
!
      use press
      use rspac
      use kcon
      use mprop
      use dumm
      use disch
      use equat
      use jtxx
      use trxxh
      use trxy1
      use rpropsh
      use ptet
      use scon
      use trxv
      use temp
      use pit
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      COMMON/JCON/JSTOP,JFLAG,jflag1
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      integer hydraulicFunctionType
      common/functiontype/ hydraulicFunctionType
     
!............................................................................
!      
    
      IF(jflag1.EQ.1) THEN
      DO 10 N=1,NNODES
      AO(N)=0.0D0
      BO(N)=0.0D0
      CO(N)=0.0D0
      DO(N)=0.0D0
      EO(N)=0.0D0
   10 CONTINUE
      END IF
!
!   INITIALIZE VARIABLES
!
      do 50 it=1,itmax
      DO 20 I=2,NXRR
      N1=NLY*(I-1)
      DO 20 J=2,NLYY
      N=N1+J
      A(N)=0.0D0
      B(N)=0.0D0
      C(N)=0.0D0
      D(N)=0.0D0
      E(N)=0.0D0
      RHS(N)=0.0D0
      if(it.eq.1) then
!        TTOLD(N)=TT(N)
       IF(NTYP(N).EQ.1) then
        if(nit3.eq.0) dum(n) = qt(n)
        QT(N)=VSFLX1(N)
       else
        qt(n) = 0.0d0
       end if
      end if
!     end if
     IF(HX(N).NE.0.0D0) THEN
      N2=JTEX(N)
!      RHO1=RHO(N)
      RHO(N)=VTRHO(TT(N),N2)
!      RHO2=DABS(RHO1-RHO(N))
!      IF(RHO2.GT.RHOMAX)RHOMAX=RHO2
!      RET(N)=VTRET(CC(N),N2)
!      ret(n)=0.0D0
      IM1=N-NLY
      JM1=N-1
      JP1=N+1
      IP1=N+NLY
      IP2=IP1-1
      IM2=IM1+1
      IM3=IM1-1
      IP3=IP1+1
      IF(RAD) THEN
      AREAX=PI2*DELZ(J)*(RX(I)-0.5D0*DXR(I))
      AREAX1=PI2*DELZ(J)*(RX(I)+0.5D0*DXR(I))
      AREAZ=PI2*DXR(I)*RX(I)
      ELSE
      AREAX=DELZ(J)
      AREAX1=AREAX
      AREAZ=DXR(I)
      END IF
      areax_kt = areax
      areax1_kt = areax1
      areaz_kt = areaz
      VOL=AREAZ*DELZ(J)
      AREAX=AREAX*0.5D0*(THETA(IM1)*RHO(IM1)+THETA(N)*RHO(N))
      AREAX1=AREAX1*0.5D0*(THETA(IP1)*RHO(IP1)+THETA(N)*RHO(N))
      AREAZ1=AREAZ*0.5D0*(THETA(JP1)*RHO(JP1)+THETA(N)*RHO(N))
      AREAZ=AREAZ*0.5D0*(THETA(JM1)*RHO(JM1)+THETA(N)*RHO(N))
!
!   CALCULATE LHS OF MATRIX EQUATION
!
      SS=THETA(N)*(P(N)-PXXX(N))*HK(N2,2)/HK(N2,3)
      E(N)=-DX1(N)*(RHO(N)+RHO(IM1))-DZ1(N)*(RHO(N)+RHO(JM1))&
      -DX1(IP1)*(RHO(N)+RHO(IP1))-DZ1(JP1)*(RHO(N)+RHO(JP1))
!    &-VOL*(HT(N2,4)*(THETA(N)+RET(N)))
      E(N)=0.5D0*E(N)
!
! CHANGE ADDED 8-12-91 TO CORRECT STORAGE TERM
!
!      SS1=HT(N2,4)*(THETA(N)+RET(N))
!
!******************
!  following change made 7-3-04 to correct dctheta/dt 
!   calculation - see written notes
!
!******************
!      if(jflag1.ne.1.or.ntyp(n).ne.1) then
!       SS=THETA(N)+SS-THLST(N)
!      end if
!******************
      TC=THERMC(THETA(N),N2)
      TCA=0.0D0
      TCB=0.0D0
      TCC=0.0D0
      TCD=0.0D0
!C#
      A(N)=DX1(N)
      B(N)=DZ1(N)
      C(N)=DX1(IP1)
      D(N)=DZ1(JP1)
!C#TOP
      IF(HX(IM1).NE.0.0D0) THEN
!c      TCA=0.5D0*(THERMC(THETA(IM1),JTEX(IM1))+TC)*DELZ(J)/
      TCA=0.5D0*(THERMC(THETA(IM1),JTEX(IM1))+TC)*AREAX_kt/&
      (RX(I)-RX(I-1))
!C#    A(N)=0.5D0*(DX1(N)*(RHO(N)+RHO(IM1))+DZ2(N)-DZ2(JP1))
      IF(.NOT.CIS) THEN
      IF(VX(N).GT.0.0D0) THEN
      A(N)=A(N)+AREAX*VX(N)
      ELSE
      E(N)=E(N)+AREAX*VX(N)
      END IF
      ELSE
      VV=AREAX*0.5D0*VX(N)
      A(N)=A(N)+VV
      E(N)=E(N)+VV
      END IF
!C#
      TEMPP=0.5D0*DX2(N)
      IF(HX(IM3).GT.0.0D0.AND.HX(JM1).GT.0.0D0) THEN
       IF(HX(IM2).GT.0.0D0.AND.HX(JP1).GT.0.0D0) THEN
        B(N)=B(N)+TEMPP
        D(N)=D(N)-TEMPP
        RHS(N)=RHS(N)+TEMPP*(TT(IM2)-TT(IM3))
       ELSE
        A(N)=A(N)-TEMPP
        B(N)=B(N)+TEMPP
        E(N)=E(N)-TEMPP
        RHS(N)=RHS(N)-TEMPP*TT(IM3)
       END IF
      ELSE
       IF(HX(IM2).GT.0.0D0.AND.HX(JP1).GT.0.0D0) THEN
        A(N)=A(N)+TEMPP
        D(N)=D(N)-TEMPP
        E(N)=E(N)+TEMPP
        RHS(N)=RHS(N)+TEMPP*TT(IM2)
       END IF
!C#
      END IF
      END IF
!c# Left      
      IF(HX(JM1).NE.0.0D0) THEN
!c      TCB=0.5D0*(THERMC(THETA(JM1),JTEX(JM1))+TC)*DXR(I)/
      TCB=0.5D0*(THERMC(THETA(JM1),JTEX(JM1))+TC)*AREAZ_kt/&
      (DZZ(J)-DZZ(J-1))
!C#    B(N)=0.5D0*(DZ1(N)*(RHO(N)+RHO(JM1))+DX2(N)-DX2(IP1))
      IF(.NOT.CIS) THEN
      IF(VZ(N).GT.0.0D0) THEN
      B(N)=B(N)+AREAZ*VZ(N)
      ELSE
      E(N)=E(N)+AREAZ*VZ(N)
      END IF
      ELSE
      VV=0.5D0*AREAZ*VZ(N)
      B(N)=B(N)+VV
      E(N)=E(N)+VV
      END IF
!C#
      TEMPP=0.5D0*DZ2(N)
      IF(HX(IP2).GT.0.0D0.AND.HX(IP1).GT.0.0D0) THEN
       IF(HX(IM3).GT.0.0D0.AND.HX(IM1).GT.0.0D0) THEN
        A(N)=A(N)+TEMPP
        C(N)=C(N)-TEMPP
        RHS(N)=RHS(N)+TEMPP*(TT(IP2)-TT(IM3))
       ELSE
        B(N)=B(N)+TEMPP
        C(N)=C(N)-TEMPP
        E(N)=E(N)+TEMPP
        RHS(N)=RHS(N)+TEMPP*TT(IP2)
       END IF
      ELSE
       IF(HX(IM3).GT.0.0D0.AND.HX(IM1).GT.0.0D0) THEN
        A(N)=A(N)+TEMPP
        B(N)=B(N)-TEMPP
        E(N)=E(N)-TEMPP
        RHS(N)=RHS(N)-TEMPP*TT(IM3)
       END IF
      END IF
!C#
      END IF
!C# BOTTOM      
      IF(HX(IP1).NE.0.0D0) THEN
!c      TCC=0.5D0*(THERMC(THETA(IP1),JTEX(IP1))+TC)*DELZ(J)/
      TCC=0.5D0*(THERMC(THETA(IP1),JTEX(IP1))+TC)*AREAX1_kt/&
      (RX(I+1)-RX(I))
!C#    C(N)=0.5D0*(DX1(IP1)*(RHO(N)+RHO(IP1))-DZ2(N)+DZ2(JP1))
      IF(.NOT.CIS) THEN
      IF(VX(IP1).LT.0.0D0) THEN
      C(N)=C(N)-AREAX1*VX(IP1)
      ELSE
      E(N)=E(N)-AREAX1*VX(IP1)
      END IF
      ELSE
      VV=0.5D0*AREAX1*VX(IP1)
      C(N)=C(N)-VV
      E(N)=E(N)-VV
      END IF
!C#
      TEMPP=0.5D0*DX2(IP1)
      IF(HX(JP1).GT.0.0D0.AND.HX(IP3).GT.0.0D0) THEN
       IF(HX(IP2).GT.0.0D0.AND.HX(JM1).GT.0.0D0) THEN
        B(N)=B(N)-TEMPP
        D(N)=D(N)+TEMPP
        RHS(N)=RHS(N)+TEMPP*(TT(IP2)-TT(IP3))
       ELSE
        C(N)=C(N)-TEMPP
        D(N)=D(N)+TEMPP
        E(N)=E(N)-TEMPP
        RHS(N)=RHS(N)-TEMPP*TT(IP3)
       END IF
      ELSE
       IF(HX(IP2).GT.0.0D0.AND.HX(JM1).GT.0.0D0) THEN
        B(N)=B(N)-TEMPP
        C(N)=C(N)+TEMPP
        E(N)=E(N)+TEMPP
        RHS(N)=RHS(N)+TEMPP*TT(IP2)
       END IF
      END IF
!#
      END IF
!C# RIGHT      
      IF(HX(JP1).NE.0.0D0) THEN
!c      TCD=0.5D0*(THERMC(THETA(JP1),JTEX(JP1))+TC)*DXR(I)/
      TCD=0.5D0*(THERMC(THETA(JP1),JTEX(JP1))+TC)*AREAZ_kt/&
      (DZZ(J+1)-DZZ(J))
!C#    D(N)=0.5D0*(DZ1(JP1)*(RHO(N)+RHO(JP1))-DX2(N)+DX2(IP1))
      IF(.NOT.CIS) THEN
      IF(VZ(JP1).LT.0.0D0) THEN
      D(N)=D(N)-AREAZ1*VZ(JP1)
      ELSE
      E(N)=E(N)-AREAZ1*VZ(JP1)
      END IF
      ELSE
      VV=0.5D0*AREAZ1*VZ(JP1)
      D(N)=D(N)-VV
      E(N)=E(N)-VV
      END IF
!C#
      TEMPP=0.5D0*DZ2(JP1)
      IF(HX(IM2).GT.0.0D0.AND.HX(IM1).GT.0.0D0) THEN
       IF(HX(IP1).GT.0.0D0.AND.HX(IP3).GT.0.0D0) THEN
        A(N)=A(N)-TEMPP
        C(N)=C(N)+TEMPP
        RHS(N)=RHS(N)+TEMPP*(TT(IM2)-TT(IP3))
       ELSE
        A(N)=A(N)-TEMPP
        D(N)=D(N)+TEMPP
        E(N)=E(N)+TEMPP
        RHS(N)=RHS(N)+TEMPP*TT(IM2)
       END IF
      ELSE
       IF(HX(IP1).GT.0.0D0.AND.HX(IP3).GT.0.0D0) THEN
        C(N)=C(N)+TEMPP
        D(N)=D(N)-TEMPP
        E(N)=E(N)-TEMPP
        RHS(N)=RHS(N)-TEMPP*TT(IP3)
       END IF
      END IF
!C#
      END IF
!      IF(Q(N).LT.0.) E(N)=E(N)+Q(N)*RHO(N)
      IF(QQ(N).LT.0.0D0) E(N)=E(N)+QQ(N)*RHO(N)
      IF(QT(N).GT.0.0D0) E(N)=E(N)-QT(N)
!C
!C  CENTERED-IN-TIME DIFFERENCING CAN BE USED ONLY AFTER THE
!C  FIRST TIME STEP IN ANY RECHARGE PERIOD.
!C
      RHS(N) = RHS(N)*HT(N2,6)
      IF(CIT.AND.JFLAG1.NE.1) THEN
       FACT=0.5D0*HT(N2,6)
       FACT1=0.5D0
      ELSE
       FACT=HT(N2,6)
       FACT1=1.
      END IF
      A(N)=FACT*A(N)+FACT1*TCA
      B(N)=FACT*B(N)+FACT1*TCB
      C(N)=FACT*C(N)+FACT1*TCC
      D(N)=FACT*D(N)+FACT1*TCD
      E(N)=FACT*E(N)+fact1*(-TCA-TCB-TCC-TCD)
!c      END IF
      E(N)=E(N)-VOL*(((THETA(N)+SS)*RHO(N)*HT(N2,6)+HT(N2,3))/DELT)
      end if
!c
!c  above end if moved here 12/2010
!c
   20 CONTINUE
!C
!C  BEGIN LOOP TO CALCULATE RHS AND CALL MATRIX SOLVER
!C
      DO 30 I=2,NXRR
      N1=NLY*(I-1)
      DO 30 J=2,NLYY
      N=N1+J
      IM1=N-NLY
      JM1=N-1
      JP1=N+1
      IP1=N+NLY
      IP2=IP1-1
      IM2=IM1+1
      IM3=IM1-1
      IP3=IP1+1
      IF(RAD) THEN
      VOL=PI2*DELZ(J)*DXR(I)*RX(I)
      ELSE
      VOL=DELZ(J)*DXR(I)
      END IF
      N2=JTEX(N)

      if (ntyp(n).eq.1) then
      RHS(N)=RHS(N)-VOL*(THETA(N)*RHO(N)*HT(N2,6)+HT(N2,3))&
      *TTOLD(N)/DELT&
      -A(N)*TT(IM1)-B(N)*TT(JM1)&
      -C(N)*TT(IP1)-D(N)*TT(JP1)-E(N)*TT(N)
      else
      RHS(N)=RHS(N)-VOL*(THLST(N)*RHO(N)*HT(N2,6)+HT(N2,3))&
      *TTOLD(N)/DELT&
      -A(N)*TT(IM1)-B(N)*TT(JM1)&
      -C(N)*TT(IP1)-D(N)*TT(JP1)-E(N)*TT(N)
      end if
!#
      IF (CIT.AND.JFLAG1.NE.1) RHS(N)=RHS(N)-AO(N)*TTOLD(IM1)-BO(N)&
      *TTOLD(JM1)-CO(N)*TTOLD(IP1)-DO(N)*TTOLD(JP1)-EO(N)*TTOLD(N)
      IF(QQ(N).GT.0.0D0.and.ntyp(n).ne.1) RHS(N)=RHS(N)-QQ(N)*TS(N)&
      *RHO(N)*HT(N2,6)
      IF(QT(N).LT.0.0D0.AND.NHTYP(N).EQ.0) then
       if(cit.and.jflag1.ne.1) then
        RHS(N)=RHS(N)+0.5d0*(dum(n)+QT(N))*TS(N)*HT(N2,6)
       else
        rhs(n) = rhs(n) + qt(n)*TS(n)*ht(n2,6)
       end if
      end if
      IF(QT(N).LE.0.0D0.AND.NHTYP(N).EQ.2) RHS(N)=RHS(N)-TS(N)
   30 CONTINUE
      NIT1=NIT1+1
!
!   CALL MATRIX SOLVER
!
      CALL SLVSIP
      IF(ITEST.EQ.0) THEN
      RETURN
      END IF
   50 CONTINUE
      WRITE(6,4000)
      IF (.NOT.ITSTOP) RETURN
      JSTOP=10
      JFLAG=1
      PRINT*, 'ERROR: MAXIMUM NUMBER OF ITERATIONS EXCEEDED FOR HEAT '&
                ,' TRANSPORT EQUATION'
      WRITE(6,4010)
      RETURN
 4000 FORMAT(' MAXIMUM NUMBER OF ITERATIONS EXCEEDED FOR HEAT TRANSPORT'&
      ,' EQUATION')
 4010 FORMAT(' Simulation terminated')
      END
      SUBROUTINE VTSETUPSOL
!*******
!VTSETUPSOL
!*******
!
!    ROUTINE TO ASSEMBLE MATRIX EQUATIONS FOR ADVECTION-DISPERSION
!    EQUATIONS AND TO CALL MATRIX SOLVER.
!
      use press
      use rspac
      use kcon
      use mprop
      use dumm
      use disch
      use equats
      use jtxx
      use trxx
      use trxy2
      use rpropsh
      use scon
      use trxv
      use temp
      use pit
      use tempcc
      use react
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      COMMON/JCON/JSTOP,JFLAG,jflag1
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      integer hydraulicFunctionType
      common/functiontype/ hydraulicFunctionType
      COMMON/TCON1/NIS,NIS1,NIS3
      COMMON/SCON1/ITESTS     
      COMMON/JCONF/JFLAG2
!
!...........................................................................
!
      do 60 M=1,Nsol
      NIS1=0
        
      IF(jflag2.EQ.1) THEN
      DO 10 N=1,NNODES
      AOC(N)=0.0D0
      BOC(N)=0.0D0
      COC(N)=0.0D0
      DOC(N)=0.0D0
      EOC(N)=0.0D0
   10 CONTINUE
      END IF
!
!   INITIALIZE VARIABLES
!
       
      do 50 it=1,itmax
      DO 20 I=2,NXRR
      N1=NLY*(I-1)
      DO 20 J=2,NLYY
      N=N1+J
      AS(N)=0.0D0
      BS(N)=0.0D0
      CS(N)=0.0D0
      DS(N)=0.0D0
      ES(N)=0.0D0
      RHSS(N)=0.0D0
      if(it.eq.1) then
       CCOLD(M,N)=CC(M,N)
       IF(NTYP(N).EQ.1) then
        dum(n) = qs(n)
        QS(N)=VSFLX1(N)
       else
        qs(n) = 0.0d0
       end if
      end if
      TempC(N)=CC(M,N)
!      WRITE(6,*)'TempC Before ########### ',M
!     CALL VSOUTS(1,TempC(N))
      IF(HX(N).NE.0.0D0) THEN
      N2=JTEX(N)
!      RHO1=RHO(N)
!      RHO(N)=VTRHO(CC(N),N2)
!      RHO2=DABS(RHO1-RHO(N))
!      IF(RHO2.GT.RHOMAX)RHOMAX=RHO2
!      RET(N)=VTRET(CC(N),N2)
!      ret(n)=0.0D0
      IM1=N-NLY
      JM1=N-1
      JP1=N+1
      IP1=N+NLY
      IP2=IP1-1
      IM2=IM1+1
      IM3=IM1-1
      IP3=IP1+1
      IF(RAD) THEN
      AREAX=PI2*DELZ(J)*(RX(I)-0.5D0*DXR(I))
      AREAX1=PI2*DELZ(J)*(RX(I)+0.5D0*DXR(I))
      AREAZ=PI2*DXR(I)*RX(I)
      ELSE
      AREAX=DELZ(J)
      AREAX1=AREAX
      AREAZ=DXR(I)
      END IF
      VOL=AREAZ*DELZ(J)
      AREAX=AREAX*0.5D0*(THETA(IM1)+THETA(N))
      AREAX1=AREAX1*0.5D0*(THETA(IP1)+THETA(N))
      AREAZ1=AREAZ*0.5D0*(THETA(JP1)+THETA(N))
      AREAZ=AREAZ*0.5D0*(THETA(JM1)+THETA(N))
!
!   CALCULATE LHS OF MATRIX EQUATION
!
      SS=THETA(N)*(P(N)-PXXX(N))*HK(N2,2)/HK(N2,3)
      ES(N)=-DXS1(N)-DZS1(N)-DXS1(IP1)-DZS1(JP1)
!   &-VOL*(HT(N2,4)*(THETA(N)+RET(N)))
!
!  CHANGE ADDED 8-12-91 TO CORRECT STORAGE TERM
!
!      SS1=HT(N2,4)*(THETA(N)+RET(N))
!
!c******************
!  following change made 7-3-04 to correct dctheta/dt 
!   calculation - see written notes
!
!******************
!      if(jflag1.ne.1.or.ntyp(n).ne.1) then
!       SS=THETA(N)+SS-THLST(N)
!     end if
!******************
     
!C#
      AS(N)=DXS1(N)
      BS(N)=DZS1(N)

      CS(N)=DXS1(IP1)
      DS(N)=DZS1(JP1)
!C#    TOP(	n,j-1)
      IF(HX(IM1).NE.0.0D0) THEN
!C#    A(N)=0.5D0*(DX1(N)*(RHO(N)+RHO(IM1))+DZ2(N)-DZ2(JP1))
      IF(.NOT.CIS) THEN
      IF(VX(N).GT.0.0D0) THEN
      AS(N)=AS(N)+AREAX*VX(N)
      ELSE
      ES(N)=ES(N)+AREAX*VX(N)
      END IF
      ELSE
      VV=AREAX*0.5D0*VX(N)
      AS(N)=AS(N)+VV
      ES(N)=ES(N)+VV
      END IF
!C#
      TEMPP=0.5D0*DXS2(N)
      IF(HX(IM3).GT.0.0D0 .AND. HX(JM1).GT.0.0D0) THEN
       IF(HX(IM2).GT.0.0D0 .AND. HX(JP1).GT.0.0D0) THEN
        BS(N)=BS(N)+TEMPP
        DS(N)=DS(N)-TEMPP
        RHSS(N)=RHSS(N)+TEMPP*(CC(M,IM2)-CC(M,IM3))
       ELSE
        AS(N)=AS(N)-TEMPP
        BS(N)=BS(N)+TEMPP
        ES(N)=ES(N)-TEMPP
        RHSS(N)=RHSS(N)-TEMPP*CC(M,IM3)
       END IF
      ELSE
       IF(HX(IM2).GT.0.0D0 .AND. HX(JP1).GT.0.0D0) THEN
        AS(N)=AS(N)+TEMPP
        DS(N)=DS(N)-TEMPP
        ES(N)=ES(N)+TEMPP
        RHSS(N)=RHSS(N)+TEMPP*CC(M,IM2)
       END IF
!C#
      END IF
      END IF

!C#    left (n-1,j)      
      IF(HX(JM1).NE.0.0D0) THEN
!C#    B(N)=0.5D0*(DZ1(N)*(RHO(N)+RHO(JM1))+DX2(N)-DX2(IP1))
      IF(.NOT.CIS) THEN
      IF(VZ(N).GT.0.0D0) THEN
      BS(N)=BS(N)+AREAZ*VZ(N)
      ELSE
      ES(N)=ES(N)+AREAZ*VZ(N)
      END IF
      ELSE
      VV=0.5D0*AREAZ*VZ(N)
      BS(N)=BS(N)+VV
      ES(N)=ES(N)+VV
      END IF
!C#
      TEMPP=0.5D0*DZS2(N)
      IF(HX(IP2).GT.0.0D0 .AND. HX(IP1).GT.0.0D0) THEN
       IF(HX(IM3).GT.0.0D0 .AND. HX(IM1).GT.0.0D0) THEN
        AS(N)=AS(N)+TEMPP
        CS(N)=CS(N)-TEMPP
        RHSS(N)=RHSS(N)+TEMPP*(CC(M,IP2)-CC(M,IM3))
       ELSE
        BS(N)=BS(N)+TEMPP
        CS(N)=CS(N)-TEMPP
        ES(N)=ES(N)+TEMPP
        RHSS(N)=RHSS(N)+TEMPP*CC(M,IP2)
       END IF
      ELSE
       IF(HX(IM3).GT.0.0D0 .AND. HX(IM1).GT.0.0D0) THEN
        AS(N)=AS(N)+TEMPP
        BS(N)=BS(N)-TEMPP
        ES(N)=ES(N)-TEMPP
        RHSS(N)=RHSS(N)-TEMPP*CC(M,IM3)
       END IF
      END IF
!C#
      END IF

!C#  Bottom (n,j+1)      
      IF(HX(IP1).NE.0.0D0) THEN
!C#    C(N)=0.5D0*(DX1(IP1)*(RHO(N)+RHO(IP1))-DZ2(N)+DZ2(JP1))
      IF(.NOT.CIS) THEN
      IF(VX(IP1).LT.0.0D0) THEN
      CS(N)=CS(N)-AREAX1*VX(IP1)
      ELSE
      ES(N)=ES(N)-AREAX1*VX(IP1)
      END IF
      ELSE
      VV=0.5D0*AREAX1*VX(IP1)
      CS(N)=CS(N)-VV
      ES(N)=ES(N)-VV
      END IF
!C#
      TEMPP=0.5D0*DXS2(IP1)
      IF(HX(JP1).GT.0.0D0 .AND. HX(IP3).GT.0.0D0) THEN
       IF(HX(IP2).GT.0.0D0 .AND. HX(JM1).GT.0.0D0) THEN
        BS(N)=BS(N)-TEMPP
        DS(N)=DS(N)+TEMPP
        RHSS(N)=RHSS(N)+TEMPP*(CC(M,IP2)-CC(M,IP3))
       ELSE
        CS(N)=CS(N)-TEMPP
        DS(N)=DS(N)+TEMPP
        ES(N)=ES(N)-TEMPP
        RHSS(N)=RHSS(N)-TEMPP*CC(M,IP3)
       END IF
      ELSE
       IF(HX(IP2).GT.0.0D0 .AND. HX(JM1).GT.0.0D0) THEN
        BS(N)=BS(N)-TEMPP
        CS(N)=CS(N)+TEMPP
        ES(N)=ES(N)+TEMPP
        RHSS(N)=RHSS(N)+TEMPP*CC(M,IP2)
       END IF
      END IF
!C#
      END IF

!C#  right (n+1,j)      
      IF(HX(JP1).NE.0.0D0) THEN
!C#    D(N)=0.5D0*(DZ1(JP1)*(RHO(N)+RHO(JP1))-DX2(N)+DX2(IP1))
      IF(.NOT.CIS) THEN
      IF(VZ(JP1).LT.0.0D0) THEN
      DS(N)=DS(N)-AREAZ1*VZ(JP1)
      ELSE
      ES(N)=ES(N)-AREAZ1*VZ(JP1)
      END IF
      ELSE
      VV=0.5D0*AREAZ1*VZ(JP1)
      DS(N)=DS(N)-VV
      ES(N)=ES(N)-VV
      END IF
!C#
      TEMPP=0.5D0*DZS2(JP1)
      IF(HX(IM2).GT.0.0D0 .AND. HX(IM1).GT.0.0D0) THEN
       IF(HX(IP1).GT.0.0D0 .AND. HX(IP3).GT.0.0D0) THEN
        AS(N)=AS(N)-TEMPP
        CS(N)=CS(N)+TEMPP      
 !     CALL VSOUTS(1,TempC(N))
        RHSS(N)=RHSS(N)+TEMPP*(CC(M,IM2)-CC(M,IP3))
       ELSE
        AS(N)=AS(N)-TEMPP
        DS(N)=DS(N)+TEMPP
        ES(N)=ES(N)+TEMPP
        RHSS(N)=RHSS(N)+TEMPP*CC(M,IM2)
       END IF
      ELSE
       IF(HX(IP1).GT.0.0D0 .AND. HX(IP3).GT.0.0D0) THEN
        CS(N)=CS(N)+TEMPP
        DS(N)=DS(N)-TEMPP
        ES(N)=ES(N)-TEMPP
        RHSS(N)=RHSS(N)-TEMPP*CC(M,IP3)
       END IF
      END IF
!C#
      END IF
      if (NPV.ge.0) then
      IF(Q(N).LT.0.0D0 .AND. NTYP(N) .NE. 5) ES(N)=ES(N)+Q(N)
      end if  
      IF(QQ(N).LT.0.0D0) ES(N)=ES(N)+QQ(N)
      IF(QS(N).GT.0.0D0) ES(N)=ES(N)-QS(N)
!C
!C  CENTERED-IN-TIME DIFFERENCING CAN BE USED ONLY AFTER THE
!C  FIRST TIME STEP IN ANY RECHARGE PERIOD.
!C
   
      IF(CIT.AND.JFLAG2.NE.1) THEN
      AS(N)=0.5D0*AS(N)
      BS(N)=0.5D0*BS(N)
      CS(N)=0.5D0*CS(N)
      DS(N)=0.5D0*DS(N)
      ES(N)=0.5D0*ES(N)
      END IF
      ES(N)=ES(N)-VOL*(THETA(N)+SS)/DELT 
      END IF
   20 CONTINUE
 !     WRITE(6,*)'TempC Before ########### ',M
 !     CALL VSOUTS(1,TempC(N))
   
!
!  BEGIN LOOP TO CALCULATE RHS AND CALL MATRIX SOLVER
!
      
      DO 30 I=2,NXRR
       N1=NLY*(I-1)
      DO 30 J=2,NLYY
      N=N1+J
      IM1=N-NLY
      JM1=N-1
      JP1=N+1
      IP1=N+NLY
      IP2=IP1-1
      IM2=IM1+1
      IM3=IM1-1
      IP3=IP1+1
      IF(RAD) THEN
      VOL=PI2*DELZ(J)*DXR(I)*RX(I)
      ELSE
      VOL=DELZ(J)*DXR(I)
      END IF
      N2=JTEX(N)

      if (ntyp(n).eq.1) then
      RHSS(N)=RHSS(N)-VOL*THETA(N)*CCOLD(M,N)/DELT-AS(N)*CC(M,IM1)&
      -BS(N)*CC(M,JM1)-CS(N)*CC(M,IP1)-DS(N)*CC(M,JP1)-ES(N)*CC(M,N)
      else
      RHSS(N)=RHSS(N)-VOL*THLST(N)*CCOLD(M,N)/DELT-AS(N)*CC(M,IM1)&
      -BS(N)*CC(M,JM1)-CS(N)*CC(M,IP1)-DS(N)*CC(M,JP1)-ES(N)*CC(M,N)
      end if
!C#
      IF (CIT.AND.JFLAG2.NE.1) RHSS(N)=RHSS(N)-AOC(N)*CCOLD(M,IM1)&
      -BOC(N)*CCOLD(M,JM1)-COC(N)*CCOLD(M,IP1)-DOC(N)*CCOLD(M,JP1)&
      -EOC(N)*CCOLD(M,N)
      IF(QQ(N).GT.0.0D0 .and. ntyp(n).ne.1)RHSS(N)=RHSS(N)-QQ(N)&
      *CSS(M,N)
      IF(QS(N).LT.0.0D0 .AND. NCTYP(N).EQ.0) then
       if(cit.and.jflag2.ne.1) then
        RHSS(N)=RHSS(N)+0.5d0*(QS(N)+dum(n))*CSS(M,N)
       else
        RHSS(N) = RHSS(N)+ QS(N)*CSS(M,N)
       end if
      end if
      IF(QS(N).LE.0.0D0 .AND.NCTYP(N).EQ.2)RHSS(N)=RHSS(N)-CSS(M,N)
       
   30 CONTINUE

      NIS1=NIS1+1
!
!   CALL MATRIX SOLVER
!
      CALL SLVSIPSOL
      DO 31	I=2,NXRR
       N1=NLY*(I-1)
      DO 31 J=2,NLYY
      N=N1+J
      CC(M,N)=TempC(N)
  31  CONTINUE   
!C      WRITE(6,*)'TempC After ########### ',M
!      CALL VSOUTS(1,TempC(N))
      IF(ITESTS.EQ.0) THEN
      IF (CIT) THEN
      DO 40 I=2,NXRR
      N1=NLY*(I-1)
      DO 40 J=2,NLYY
      N=N1+J
      IF(HX(N).EQ.0.0D0) GO TO 40
      if(nctyp(n).ne.1) then
       AOC(N)=AS(N)
       BOC(N)=BS(N)
       COC(N)=CS(N)
       DOC(N)=DS(N)
      end if
      IF(RAD) THEN
      AREAZ=PI2*DXR(I)*RX(I)
      ELSE
      AREAZ=DXR(I)
      END IF
      VOL=AREAZ*DELZ(J)
      N2=JTEX(N)
      SS=theta(n)*(P(N)-PXXX(N))*HK(N2,2)/HK(N2,3)
!
!  CHANGE 8-12-91 FOR STORAGE
!
!      SS1=HT(N2,4)*(THETA(N)+RET(N))
!
!****************
!c  following change made 7-3-04 to correct dctheta/dt
!   calculation
!
!****************
!      if(jflag1.ne.1.or.ntyp(n).ne.1) then
!       SS=THETA(N)+SS-THLST(N)
!      end if
!****************
      EOC(N)=ES(N)+VOL*(THETA(N)+SS)/DELT
      IF(JFLAG1.EQ.1) THEN
       if(nctyp(n).ne.1) then
        AOC(N)=0.5D0*AOC(N)
        BOC(N)=0.5D0*BOC(N)
        COC(N)=0.5D0*COC(N)
        DOC(N)=0.5D0*DOC(N)
       end if
       EOC(N)=0.5D0*EOC(N)
      END IF
   40 CONTINUE
      END IF
      go to 60
      END IF

   50 CONTINUE
      WRITE(6,4000)
      IF (.NOT.ITSTOP) GO TO 60
      JSTOP=10
      JFLAG=1
      PRINT*, 'ERROR: MAXIMUM NUMBER OF ITERATIONS EXCEEDED FOR SOLUTE '&
                ,' TRANSPORT EQUATION'
      WRITE(6,4010)
   60 CONTINUE   
      RETURN
 4000 FORMAT('MAXIMUM NUMBER OF ITERATIONS EXCEEDED FOR SOLUTE '&
      ,' TRANSPORT EQUATION')
 4010 FORMAT(' Simulation terminated')
      END
            DOUBLE PRECISION FUNCTION VTRHO(TT,I)
!*****
!VTRHO
!*****
!
! DENSITY AS A FUNCTION OF TEMPERATURE CC
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!c      include 'c_rpropsh.inc'
!c      VTRHO=HT(I,6)+HT(I,8)*(CC-HT(I,7))
      vtrho=1.0D0
      RETURN
      END
      DOUBLE PRECISION FUNCTION THERMC(TT,I)
!*****
!THERMC
!*****
!
! THERMAL CONDUCTIVITY AS FUNCTION OF THETA
!
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      integer hydraulicFunctionType
      common/functiontype/ hydraulicFunctionType
!c      include 'c_rpropsh.inc'
      if (hydraulicFunctionType.lt.3) then
       T1=HK(I,5)
      else
       T1 = 0.d0
      end if
      T2=HK(I,3)
      IF(TT.LE.T1) THEN
       THERMC=HT(I,4)
      ELSE
       IF(TT.GE.HK(I,3)) THEN
        THERMC=HT(I,5)
       ELSE
        W1=(TT-HK(I,5))/(HK(I,3)-T1)
        W2=1-W1
        THERMC=W1*HT(I,4)+W2*HT(I,5)
       END IF
      END IF
      RETURN
      END

      SUBROUTINE vsgrav_dr
!******
!CVSgrav_dr
!******
!C
!  PURPOSE: TO COMPUTE flows from gravity drainage boundaries
!
!
!------------------------------------------------------------------
!
!   SPECIFICATIONS FOR ARRAYS AND SCALARS
!
      use kcon
      use hcon
      use disch
      use press
      use rspac
      use trxx
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)

      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
      COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
!
!-----------------------------------------------------------------
!
      DO 10 J=2,NLYY
      DO 10 N=2,NXRR
      IN=NLY*(N-1)+J
      IF(NTYP(IN).EQ.7) then
        AREA=DXR(N)
        IF(RAD)AREA=PI2*RX(N)*DXR(N)
        qq(in) = -hx(in)*hcnd(in)*AREA
      END IF
   10 CONTINUE
      RETURN
      END



!
!   Following are subroutines that are required for connecting
!  VS2DT fortran program to VS2DTI post processor
!
      SUBROUTINE GETNX(NX)
! *** GET THE NUMBER OF CELLS IN THE X DIRECTION
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      NX = NXR
      RETURN
      END

      SUBROUTINE GETNZ(NZ)
! *** GET THE NUMBER OF CELLS IN THE Z DIRECTION
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      NZ = NLY
      RETURN
      END

      SUBROUTINE GETDX(DX, NX)
!C *** GET THE CELL SIZES IN THE X DIRECTION AND RETURN IT IN THE
!C *** ARRAY DX PROVIDED BY THE CALLING PROGRAM
      use rspac
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!c      include 'c_rspac.inc'
      DIMENSION DX(NX)
      DO 10 I=1, NX
         DX(I) = DXR(I)
  10  CONTINUE
      RETURN
      END

      SUBROUTINE GETDZ(DZ, NZ)
!C *** GET THE CELL SIZES IN THE Z DIRECTION AND RETURN IT IN THE
!C *** ARRAY DZ PROVIDED BY THE CALLING PROGRAM
      use rspac
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!c      include 'c_rspac.inc'
      DIMENSION DZ(NZ)
      DO 10 I=1, NZ
         DZ(I) = DELZ(I)
  10  CONTINUE
      RETURN
      END

      SUBROUTINE GETCONC(C, N,NC)
!C *** GET THE CONCENTRATION ARRAY AND PUT IT IN C, WHICH IS PROVIDED
!C *** BY THE CALLING PROGRAM
      use trxx
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!c      include 'c_trxx.inc'
      DIMENSION C(N,NC)
      DO 10 I=1,NC
      DO 10 N=1,Nsol  
         C(N,I) = CC(N,I)    
   10 CONTINUE
      RETURN
      END

      SUBROUTINE GETKSAT(HX1, NN)
!C *** GET THE SATURATED HYDRAULIC CONDUCTIVITY AND RETURN IT IN HX1, WHICH IS PROVIDED
!C *** BY THE CALLING PROGRAM
      use kcon
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!c      include 'c_kcon.inc'
      DIMENSION HX1(NN)
      DO 10 I=1,NN
         HX1(I) = HX(I)
   10 CONTINUE
      RETURN
      END

      SUBROUTINE GETTEX(JT, NN)
!C *** GET THE TEXTURAL CLASS MAP AND RETURN IT IN JT, WHICH IS PROVIDED
!C *** BY THE CALLING PROGRAM
      use jtxx
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!c      include 'c_jtxx.inc'
      DIMENSION JT(NN)
      DO 10 I=1,NN
         JT(I) = JTEX(I)
   10 CONTINUE
      RETURN
      END
      SUBROUTINE GETMOIST(THETA1, NN)
!C *** GET THE MOISTURE CONTENTS AND RETURN IT IN THETA1, WHICH IS PROVIDED
!C *** BY THE CALLING PROGRAM
      use mprop
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!      include 'c_mprop.inc'
      DIMENSION THETA1(NN)
      DO 10 I=1,NN
         THETA1(I) = THETA(I)
   10 CONTINUE
      RETURN
      END

      SUBROUTINE GETSAT(SAT, NN)
!C *** GET THE SATURATION AND RETURN IT IN SAT, WHICH IS PROVIDED
!C *** BY THE CALLING PROGRAM
      use mprop
      use jtxx
      use rpropsh
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!c      include 'c_mprop.inc'
!c      include 'c_jtxx.inc'
!c      include 'c_rpropsh.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      DIMENSION SAT(NN)
      DO 70 J=2,NLYY
        DO 70 N=2,NXRR
          IN=NLY*(N-1)+J
          TTX=HK(JTEX(IN),3)
          IF(TTX.EQ.0.0D0) THEN
            SAT(IN)=0.0D0
          ELSE
            SAT(IN)=THETA(IN)/TTX
          END IF
   70 CONTINUE
      RETURN
      END

      SUBROUTINE GETPHEAD(PHEAD, NN)
!C *** GET THE PRESSURE HEAD AND RETURN IT IN PHEAD, WHICH IS PROVIDED
!C *** BY THE CALLING PROGRAM
      use press
      use rspac
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!c      include 'c_press.inc'
!c      include 'c_rspac.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      DIMENSION PHEAD(NN)
      DO 70 J=1,NLY
        DO 70 N=1,NXR
          IN=NLY*(N-1)+J
          IF(CS1.EQ.1.0D0) THEN
            Z1=DZZ(J)
          ELSE
            Z1=DZZ(J)*CS1+RX(N)*CS2
          END IF
          PHEAD(IN) = P(IN)+Z1
   70 CONTINUE
      RETURN
      END

      SUBROUTINE GETSTIME(STIME)
!C *** GET THE SIMULATION TIME AND RETURN IT IN STIME
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      STIME = STIM
      RETURN
      END

      SUBROUTINE GETSTEP(KTIME)
!C *** GET THE TIME STEP AND RETURN IT IN KTIME
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      KTIME = KTIM
      RETURN
      END

      SUBROUTINE CLOSEIO
!C *** CLOSE ALL IO UNITS
      CLOSE(2)
      CLOSE(5)
      CLOSE(6)
      CLOSE(7)
      CLOSE(8)
      CLOSE(9)
      CLOSE(10)
      CLOSE(11)
      CLOSE(12)
      CLOSE(13)
!      CLOSE(14)
!      CLOSE(15)
!      CLOSE(16)
!      CLOSE(17)
!      CLOSE(18)
!      CLOSE(19)
      RETURN
      END

      SUBROUTINE RELEASEMEMORY
      use rspac
      use kcon
      use mprop
      use press
      use disch
      use hcon
      use equat
      use equats
      use temp
      use jtxx
      use dumm
      use dumm1
      use dumm2
      use dumm3
      use ptet
      use trxx
      use trxxh
      use trxv
      use trxy1
      use trxy2
      use pit
      use sip
      use idumm
      use plott
      use rpropsh
      use spfc
      use scon
      use ptet
      use tempcc
      use coordin
      use solindex
      use phreecc
      use pricon
      use solmass
      use compnam
      use BF
      use isdumm
      use ihdumm
      use itemblo
      use itemtxb
      use react
      !!@@include 'd_cleanup.inc'
      if (allocated(idum)) deallocate(idum)
      if (allocated(delz)) deallocate(delz)
      if (allocated(DZZ)) deallocate(DZZ)
      if (allocated(DXR)) deallocate(DXR)
      if (allocated(RX)) deallocate(RX)
      if (allocated(HX)) deallocate(HX)
      if (allocated(NTYP)) deallocate(NTYP)
      if (allocated(THETA)) deallocate(THETA)
      if (allocated(THLST)) deallocate(THLST)
      IF (allocated(SATUR)) deallocate(SATUR)
      IF (allocated(POROSITY)) deallocate(POROSITY)
      if (allocated(P)) deallocate(P)
      if (allocated(PXXX)) deallocate(PXXX)
      if (allocated(THEAD)) deallocate(THEAD)
      if (allocated(Q)) deallocate(Q)
      if (allocated(QQ)) deallocate(QQ)
      if (allocated(HCND)) deallocate(HCND)
      if (allocated(HKLL)) deallocate(HKLL)
      if (allocated(HKTT)) deallocate(HKTT)
      if (allocated(A)) deallocate(A)
      if (allocated(B)) deallocate(B)
      if (allocated(C)) deallocate(C)
      if (allocated(D)) deallocate(D)
      if (allocated(E)) deallocate(E)
      if (allocated(RHS)) deallocate(RHS)
      if (allocated(XI)) deallocate(XI)
       if (allocated(AS)) deallocate(AS)
      if (allocated(BS)) deallocate(BS)
      if (allocated(CS)) deallocate(CS)
      if (allocated(DS)) deallocate(DS)
      if (allocated(ES)) deallocate(ES)
      if (allocated(RHSS)) deallocate(RHSS)
      if (allocated(XIS)) deallocate(XIS) 
      if (allocated(JTEX)) deallocate(JTEX)
      if (allocated(DUM)) deallocate(DUM)
      if (allocated(PDUM)) deallocate(PDUM)  
      if (allocated(DUM1)) deallocate(DUM1)
      if (allocated(DUM2)) deallocate(DUM2)  
      if (allocated(DPTH)) deallocate(DPTH)
      if (allocated(RT)) deallocate(RT)
      if (allocated(DX1)) deallocate(DX1)
      if (allocated(DX2)) deallocate(DX2)
      if (allocated(DZ1)) deallocate(DZ1)
      if (allocated(DZ2)) deallocate(DZ2)
      if (allocated(DXS1)) deallocate(DXS1)
      if (allocated(DXS2)) deallocate(DXS2)
      if (allocated(DZS1)) deallocate(DZS1)
      if (allocated(DZS2)) deallocate(DZS2) 
      if (allocated(VX)) deallocate(VX)
      if (allocated(VZ)) deallocate(VZ)
      if (allocated(CC)) deallocate(CC)
      if (allocated(CCOLD)) deallocate(CCOLD)
      if (allocated(CS)) deallocate(CS)
      if (allocated(QT)) deallocate(QT)
      if (allocated(NCTYP)) deallocate(NCTYP)
      if (allocated(CONC)) deallocate(CONC)  
      if (allocated(TT)) deallocate(TT)
      if (allocated(TTOLD)) deallocate(TTOLD)
      if (allocated(TS)) deallocate(TS)
      if (allocated(QT)) deallocate(QT)
      if (allocated(NHTYP)) deallocate(NHTYP) 
      if (allocated(AO)) deallocate(AO)
      if (allocated(BO)) deallocate(BO)
      if (allocated(CO)) deallocate(CO)
      if (allocated(DO)) deallocate(DO)
      if (allocated(EO)) deallocate(EO)
      if (allocated(AOC)) deallocate(AOC)
      if (allocated(BOC)) deallocate(BOC)
      if (allocated(COC)) deallocate(COC)
      if (allocated(DOC)) deallocate(DOC)
      if (allocated(EOC)) deallocate(EOC) 
      if (allocated(PITT)) deallocate(PITT)
      if (allocated(DEL)) deallocate(DEL)
      if (allocated(ETA)) deallocate(ETA)
      if (allocated(V)) deallocate(V)
      if (allocated(pltim)) deallocate(pltim)
      if (allocated(ijobs)) deallocate(ijobs)
      if (allocated(hk)) deallocate(hk)
      if (allocated(ht)) deallocate(ht)
      if (allocated(hs)) deallocate(hs) 
      if (allocated(aniz)) deallocate(aniz)
      if (allocated(jspx)) deallocate(jspx)
      if (allocated(nfc)) deallocate(nfc)
      if (allocated(jlast)) deallocate(jlast)
      if (allocated(dhmx)) deallocate(dhmx)
      if (allocated(PEVAL)) deallocate(PEVAL)
      if (allocated(PTVAL)) deallocate(PTVAL)
      if (allocated(RDC)) deallocate(RDC)
      if (allocated(JSPX)) deallocate(JSPX)
      if (allocated(NFC)) deallocate(NFC)
      if (allocated(JLAST)) deallocate(JLAST)
      if (allocated(RHO))deallocate(RHO)
      if (allocated(RHOOLD))deallocate(RHOOLD)
      if (allocated(TempC))deallocate(TempC)
      if (allocated(XNODE))deallocate(XNODE)
      if (allocated(ZNODE))deallocate(ZNODE)
      if (allocated(phreeC))deallocate(phreeC)
      if (allocated(CMIXFARC))deallocate(CMIXFARC)
      if (allocated(BCSOL))deallocate(BCSOL)
      if (allocated(INDSOL1))deallocate(INDSOL1)
      if (allocated(INDSOL2))deallocate(INDSOL2)
      if (allocated(ic1_reordered))deallocate(ic1_reordered)
      if (allocated(NPRCHEM))deallocate(NPRCHEM)
      if (allocated (NPRCHXZ))deallocate(NPRCHXZ) 
      if (allocated(BLSOL))deallocate(BLSOL)
      if (allocated(bl62I))deallocate(bl62I)
      if (allocated(bl62IT))deallocate(bl62IT)
      if (allocated(bl62O))deallocate(bl62O)
      if (allocated(bl62OT))deallocate(bl62OT)
      if (allocated(bcmtt))deallocate(bcmtt)
      if (allocated(bcmt))deallocate(bcmt)
      if (allocated(bcmtr))deallocate(bcmtr)
      if (allocated(bltemp36))deallocate(bltemp36)
      if (allocated(bltemp39))deallocate(bltemp39)
      if (allocated(bltemp42))deallocate(bltemp42)
      if (allocated(bltemp45))deallocate(bltemp45)
      if (allocated(bltemp60))deallocate(bltemp60)
      if (allocated(COMPNAME))deallocate(COMPNAME)
      if (allocated(idBF)) deallocate(idBF)
      if (allocated(numcellsBF)) deallocate(numcellsBF)
      if (allocated(nodenum)) deallocate(nodenum)
      if (allocated(totalBF)) deallocate(totalBF)
      if (allocated(currentBF)) deallocate(currentBF)
      if (allocated(CCBR)) deallocate(CCBR)
      if (allocated(CCAR)) deallocate(CCAR)    
      
      RETURN
      END

      SUBROUTINE GETFLOWMBERR(ERR)
!C *** GET TOTAL AND RATE FLOW MASS BALANCE ERRORS AND RETURN IN ERR
      use scon
      use solmass
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!c     include 'c_scon.inc'      
      COMMON/MASSB/BL(99),bcmft,bcmht,bl29I,bl29IT,bl29O,bl29OT, &
      bl95I,bl95IT,bl95o,bl95OT
      common/massb1/bcmf,bcmh, &
      bltemp69,bltemp72,bltemp75,bltemp78,bltemp91
 !     common/massb2/label9
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      DIMENSION ERR(2)
      IF(KTIM.EQ.0) THEN
        ERR(1) = 0
        ERR(2) = 0
        RETURN
      END IF
      FMB1 = BL(13)
      FMB2 = BL(16) + BL(25)
      FMB3 = bl29IT
      FMB4 = bl29OT
      FMB5 = BL(15)
      FMB6 = BL(18) + BL(27)
      FMB7 = bl29I/DELT
      FMB8 = bl29O/DELT
      E1 = FMB1 - FMB4
      E2 = -FMB2 + FMB3
      D = (E1 + E2)/2
      IF (D.NE.0) THEN
        ERR(1) = 100 * (E1 - E2)/D
      ELSE
        ERR(1) = 0
      END IF
      E1 = FMB5 - FMB8
      E2 = -FMB6 + FMB7
      D = (E1 + E2)/2
      IF (D.NE.0) THEN
        ERR(2) = 100 * (E1 - E2)/D
      ELSE
        ERR(2) = 0
      END IF
      RETURN
      END

      SUBROUTINE GETHEATTRANSMBERR(ERR)
!C *** GET TOTAL AND RATE CHEMICAL MASS BALANCE ERRORS AND RETURN IN ERR
      use scon
      use solmass
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!c      include 'c_scon.inc'
      COMMON/MASSB/BL(99),bcmft,bcmht,bl29I,bl29IT,bl29O,bl29OT, &
      bl95I,bl95IT,bl95o,bl95OT
      common/massb1/bcmf,bcmh, &
      bltemp69,bltemp72,bltemp75,bltemp78,bltemp91
      COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
      DIMENSION ERR(2)
      IF(KTIM.EQ.0) THEN
        ERR(1) = 0
        ERR(2) = 0
        RETURN
      END IF
      TMB1 = BL(85)
      TMB2 = BL(88)+BL(91)
      TMB3 = bl68IT
      TMB4 = bl68OT
      TMB5 = BL(54)
      TMB6 = BL(90)+BL(93)
      TMB7 = bl95I/DELT
      TMB8 = bl95O/DELT
      E1 = TMB1 - TMB4
      E2 = -TMB2 + TMB3
      D = (E1 + E2)/2
      IF (D.NE.0) THEN
        ERR(1) = 100 * (E1 - E2)/D
      ELSE
        ERR(1) = 0
      END IF
      E1 = TMB5 - TMB8
      E2 = -TMB6 + TMB7
      D = (E1 + E2)/2
      IF (D.NE.0) THEN
        ERR(2) = 100 * (E1 - E2)/D
      ELSE
        ERR(2) = 0
      END IF
      RETURN
      END

      SUBROUTINE GETVX(VELX, NN)
!C *** GET THE X VELOCITY AND RETURN IT IN VELX, WHICH IS PROVIDED
!C *** BY THE CALLING PROGRAM
      use kcon
      use trxv
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!c      include 'c_kcon.inc'
!c      include 'c_trxx.inc'
     LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      DIMENSION VELX(NN)
      IF(.NOT.TRANS) CALL VTVELO
      DO 70 J=1,NLY
        DO 70 N=1,NXR
          IN=NLY*(N-1)+J
          IF(HX(IN).EQ.0.0D0) THEN
            VELX(IN)=0.0D0
          ELSE
            VELX(IN)=(VX(IN)+VX(IN+NLY))/2
          END IF
   70 CONTINUE
      RETURN
      END

      SUBROUTINE GETVZ(VELZ, NN)
!C *** GET THE Z VELOCITY AND RETURN IT IN VELZ, WHICH IS PROVIDED
!C *** BY THE CALLING PROGRAM
      use kcon
      use trxv
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
!c      include 'c_kcon.inc'
!c      include 'c_trxx.inc'
      COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
      DIMENSION VELZ(NN)
      DO 70 J=1,NLY
        DO 70 N=1,NXR
          IN=NLY*(N-1)+J
          IF(HX(IN).EQ.0.0D0) THEN
            VELZ(IN)=0.0D0
          ELSE
            VELZ(IN)=(VZ(IN)+VZ(IN+1))/2
          END IF
   70 CONTINUE
      RETURN
      END

      SUBROUTINE DOTRANS(IFLAG)
      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
      LOGICAL TRANS,TRANS1,TRANS2,SSTATE
      COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
      IF (TRANS) THEN
        IFLAG=1
      ELSE
        IFLAG=0
      ENDIF
      RETURN
      END
